! ***************************************************************!
!  This software and related documentation are provided under a  !
!  license agreement containing restrictions on use and          !
!  disclosure and are protected by intellectual property         !
!  laws. Except as expressly permitted in your license agreement !
!  or allowed by law, you may not use, copy, reproduce,          !
!  translate, broadcast, modify, license, transmit, distribute,  !
!  exhibit, perform, publish or display any part, in any form or !
!  by any means. Reverse engineering, disassembly, or            !
!  decompilation of this software, unless required by law for    !
!  interoperability, is prohibited.                              !
!  The information contained herein is subject to change without !
!  notice and is not warranted to be error-free. If you find any !
!  errors, please report them to us in writing.                  !
!                                                                !
!  Copyright (C) 1988, 2011, Oracle and/or its affiliates.       !
!  All Rights Reserved.                                          !
! ***************************************************************!
 
!                                                                    !
!***********************************************************************
! DBTSFIX  : CORRECT DBNAME AND TSNAME                                 *
!***********************************************************************
!                                                                      *
!                                                                      *
!***********************************************************************
!                                                                      *
!                                                                      *
!                                                                      *
!                                                                      *
!                                                                      *
!***********************************************************************

#include 'setenv.sqc'           ! Set environment
#include 'setup06.sqc'          ! Setup for extract files

begin-program

        #IFDEF DB2400
                show 'DBTSFIX.SQR is not applicable for DB2/400'
                stop quiet
        #ENDIF

        #IFDEF MICROSOFT
                show 'DBTSFIX.SQR is not applicable for MICROSOFT'
                stop quiet
        #ENDIF

        #IFDEF SYBASE
                show 'DBTSFIX.SQR is not applicable for SYBASE'
                stop quiet
        #ENDIF

        do 1000_initialize

        do 6300_open_ddlin
        do 7300_read_ddlin

        if #end-file = 0
           do 2000_process_ddl
        else
           show 'DDL input file has no data !!'
        END-IF

        do 9000_terminate
        do Commit-Transaction

end-program

!----------------------------------------------------------------------!
! Procedure: 1000_initialize                                           !
! Descr:     Initialize working storage fields and call procedure      !
!            to build array the cross-refs tables to tablespaces.      !
!----------------------------------------------------------------------!

begin-procedure 1000_initialize

    create-array name=a_DBTS_list size=65535
       field=a_RECname:char
       field=a_DBname:char
       field=a_TSname:char

    !Array to hold CREATE TABLE script column variables
    create-array name=a_table_col_list size=1000
      field=a_colname:char
    
    move 0                          to #DDL_in_ct
    move 0                          to #DDL_out_ct
    let #j = 0
    move 0                          to #array_count

    move 'DBTSFIX '                        to $ReportID
    move 'Rel script conversion program'   to $ReportTitle
    Display $ReportID
    Display $ReportTitle
    Display ' '

    input $crossref 'Read Tablespace Names from File (Y) or select Tablespaces from database catalogs (N)? <default = N>'

    if isnull($crossref) or (($crossref <> 'Y') and ($crossref <> 'y'))

     let $build_from_file = 'n'
     do 5000-read-sys-catalog

    else

     let $build_from_file = 'y'
     do 6100_open_dbtsin
     do 7100_read_dbtsin

     While #end-file = 0
        do 1100_build_array
     END-WHILE

     do 8100_close_dbtsin

    end-if

#ifdef debugx
       show '#array_count = ' #array_count      edit 999,999
       show '#ts_count    = ' #ts_count         edit 999,999
#end-if

end-procedure

!----------------------------------------------------------------------!
! Procedure: 1100_build_array                                          !
! Descr:     Build the array the cross-refs tables to tablespaces      !
!            for the database that you are connected to.               !
!----------------------------------------------------------------------!

begin-procedure 1100_build_array

#ifdef debugz
        show 'i_recname = ' $i_recname
        show 'i_dbname  = ' $i_dbname
        show 'i_tsname  = ' $i_tsname
#end-if

    put $i_recname into a_DBTS_list(#ts_count) a_RECname
    put $i_dbname  into a_DBTS_list(#ts_count) a_DBname
    put $i_tsname  into a_DBTS_list(#ts_count) a_TSname

    let #array_count = #array_count + 1

    if  $build_from_file  = 'y'
     do 7100_read_dbtsin
    else
     add +1 to #ts_count
    end-if

end-procedure

!----------------------------------------------------------------------!
! Procedure: 9000_terminate                                            !
! Descr:     Show counts and end                                       !
!----------------------------------------------------------------------!

begin-procedure 9000_terminate
    show '  Run Counts'
    show '  Number of lines read from input   = ' #DDL_in_ct     edit 999,999
    show '  Number of lines written to output = ' #DDL_out_ct    edit 999,999
    show '  Number of tables input into array = ' #array_count   edit 999,999

#ifdef debugx
    show '  Number of matches     = ' #match_cnt
    show '  Number of non-matches = ' #nomatch_cnt
#end-if

end-procedure


!----------------------------------------------------------------------!
! Procedure: 2000_process_ddl                                          !
! Descr:     Main loop that parses through input lines looking for     !
!            match on 'Create Table' or 'Alter Table'. When match is   !
!            found then existing tablespace (and database for          !
!            DB2/OS390 only) is replaced with tablespace name from     !
!            xref array. The end result is tablespace name in output   !
!            file is set to tablespace name from existing database.    !
!----------------------------------------------------------------------!


begin-procedure 2000_process_ddl
    do 6200_open_ddlout
    While #end-file = 0
      #ifdef DB2
         do 2100_db2_build_ddlfile
      #else
         do 2100_build_ddlfile
      #endif
    END-WHILE
    do 8200_close_ddlout
END-PROCEDURE


!----------------------------------------------------------------------!
! Procedure: 2100_build_ddlfile                                        !
! Descr:     Match on 'Create Table' or 'Alter Table' then replace     !
!            tablespace in input file with tablespace name from        !
!            xref array.                                               !
!----------------------------------------------------------------------!

begin-procedure 2100_build_ddlfile

#ifdef debugy
       show '2100_build_ddlfile'
#end-if

    let $DDL_create  = substr($DDL_line_in,1,15)
    let $DDL_alter   = substr($DDL_line_in,1,23)
    let $DDL_CreateUniqIdx = substr($DDL_line_in,1,23)
    let $DDL_CreateUniqIdx_1 = substr($DDL_line_in,1,22)
    let $DDL_CreateIdx = substr($DDL_line_in,1,17)
    let $DDL_CreateIdx_1 = substr($DDL_line_in,1,15)
    let $DDL_idxname = ' '
    let $DDL_TYPE ='TABLE'
    
     if ($DDL_create  = 'CREATE TABLE PS') and
        substr($DDL_line_in,14,5) <> 'PS_1 '
        if $DDL_create  = 'CREATE TABLE PS'
           if (substr($DDL_line_in,16,1) = '_'   or
                 substr($DDL_line_in,16,1) = 'X' or
                 substr($DDL_line_in,16,1) = 'Y') and
                 substr($DDL_line_in,17,1) <> '_'
         
              let $DDL_temp_recname = substr($DDL_line_in,17,15)
           else
              let $DDL_temp_recname = substr($DDL_line_in,14,15)
           end-if
        else
           if substr($DDL_line_in,24,1) = '_'
              let $DDL_temp_recname = substr($DDL_line_in,25,15)
           else
              let $DDL_temp_recname = substr($DDL_line_in,22,15)
           end-if
        end-if
       unstring $DDL_temp_recname by ' ' into $DDL_recname $junk
       move 1 to #no_match
       let #j = 0
       while #no_match
           let #j = #j + 1
           if $DDL_recname =  a_DBTS_list.a_RECname(#j)
              show $DDL_recname ' match'
              let #match_cnt = #match_cnt + 1
              move 0 to #no_match

#IFDEF DB2
                do 2110_Replace_ts_db2_os390
#ENDIF

#IFDEF DB2UNIX
                do 2110_Replace_ts_db2_unix

#ENDIF

#IFDEF ORACLE
                !do 2110_Replace_ts_oracle
                let $DDL_TYPE ='TABLE'
                do 2110_Replace_tablepart_info_oracle
#ENDIF

#IFDEF INFORMIX
                do 2110_Replace_ts_informix
#ENDIF

           end-if
           if #j = #ts_count+ 1
              move 0 to #no_match
              show $DDL_recname ' nomatch'
              let #nomatch_cnt = #nomatch_cnt + 1
              move $DDL_line_in to $DDL_new_line
              move $DDL_new_line to $DDL_line_out
              
              do 7200_write_ddlout
              do 7300_read_ddlin
           end-if
       end-while
         let $DDL_create = ' '
    else
         let $DDL_idxname = ' '
         let $DDL_temp_idxname = ' '
       
    if $DDL_CreateUniqIdx  = 'CREATE UNIQUE  INDEX PS'
       let $DDL_temp_idxname =  substr($DDL_line_in,22,20)
     end-if

    if $DDL_CreateUniqIdx = 'CREATE UNIQUE  iNDEX PS'
       let $DDL_temp_idxname= substr($DDL_line_in,22,20)
    end-if
    
    if $DDL_CreateUniqIdx_1 = 'CREATE UNIQUE INDEX PS' 
       let $DDL_temp_idxname =  substr($DDL_line_in,21,20)
    end-if 
    
    if $DDL_CreateIdx = 'CREATE   INDEX PS'
       let $DDL_temp_idxname =  substr($DDL_line_in,16,20)
    end-if
 
    if $DDL_CreateIdx_1 = 'CREATE INDEX PS'
       let $DDL_temp_idxname =  substr($DDL_line_in,14,20)
    end-if
    
    unstring $DDL_temp_idxname by ' ' into $DDL_idxname $junk
    
    if $DDL_idxname <> ' '
        DO check_index_exists
        if $INDEX_FOUND = 'Y'
            let $DDL_TYPE ='INDEX'
            do 2110_Replace_tablepart_info_oracle
        else
            move $DDL_line_in to $DDL_new_line
            move $DDL_new_line to $DDL_line_out
            do 7200_write_ddlout
            do 7300_read_ddlin
        end-if
    else
        move $DDL_line_in to $DDL_new_line
        move $DDL_new_line to $DDL_line_out
        do 7200_write_ddlout
        do 7300_read_ddlin
     end-if
  end-if

END-PROCEDURE

!----------------------------------------------------------------------!
! Procedure: 2100_db2_build_ddlfile                                    !
! Descr:     Match on 'Create Table' or 'Alter Table' then replace     !
!            tablespace in input file with tablespace name from        !
!            xref array.                                               !
!----------------------------------------------------------------------!

begin-procedure 2100_db2_build_ddlfile

#ifdef debugy
       show '2100_db2_build_ddlfile'
#end-if

    let $DDL_createR84 = substr($DDL_line_in,1,25)
    let $DDL_createR81 = substr($DDL_line_in,1,15)
    let $DDL_alter   = substr($DDL_line_in,1,23)
    if ($DDL_createR84  = 'CREATE TABLE OBJ#OWNER.PS' or
        $DDL_alter   = '-- Alters for record PS') and
        substr($DDL_line_in,24,5) <> 'PS_1 '
        if $DDL_createR84  = 'CREATE TABLE OBJ#OWNER.PS'
           if (substr($DDL_line_in,26,1) = '_'   or
                 substr($DDL_line_in,26,1) = 'X' or
                 substr($DDL_line_in,26,1) = 'Y') and
                 substr($DDL_line_in,27,1) <> '_'
              let $DDL_temp_recname = substr($DDL_line_in,27,15)
           else
              let $DDL_temp_recname = substr($DDL_line_in,24,15)
           end-if
        else
           if substr($DDL_line_in,24,1) = '_'
              let $DDL_temp_recname = substr($DDL_line_in,25,15)
           else
              let $DDL_temp_recname = substr($DDL_line_in,22,15)
           end-if
        end-if
       unstring $DDL_temp_recname by ' ' into $DDL_recname $junk

       move 1 to #no_match
       let #j = 0
       while #no_match
           let #j = #j + 1
           if $DDL_recname =  a_DBTS_list.a_RECname(#j)
              show $DDL_recname ' match'
              let #match_cnt = #match_cnt + 1
              move 0 to #no_match

             do 2110_Replace_ts_db2_os390

           end-if
           if #j = #ts_count+ 1
              move 0 to #no_match
              show $DDL_recname ' nomatch'
              let #nomatch_cnt = #nomatch_cnt + 1
              move $DDL_line_in to $DDL_new_line
              move $DDL_new_line to $DDL_line_out
              do 7200_write_ddlout
              do 7300_read_ddlin
           end-if
       end-while
       let $DDL_createR84 = ' '
       let $DDL_createR81 = ' '
    else
      if ($DDL_createR81  = 'CREATE TABLE PS' or
         $DDL_alter   = '-- Alters for record PS') and
         substr($DDL_line_in,14,5) <> 'PS_1 '
         if $DDL_createR81  = 'CREATE TABLE PS'
            if (substr($DDL_line_in,16,1) = '_'   or
                  substr($DDL_line_in,16,1) = 'X' or
                  substr($DDL_line_in,16,1) = 'Y') and
                  substr($DDL_line_in,17,1) <> '_'
               let $DDL_temp_recname = substr($DDL_line_in,17,15)
            else
               let $DDL_temp_recname = substr($DDL_line_in,14,15)
            end-if
         else
            if substr($DDL_line_in,24,1) = '_'
               let $DDL_temp_recname = substr($DDL_line_in,25,15)
            else
               let $DDL_temp_recname = substr($DDL_line_in,22,15)
            end-if
         end-if
        unstring $DDL_temp_recname by ' ' into $DDL_recname $junk

        move 1 to #no_match
        let #j = 0
        while #no_match
            let #j = #j + 1
            if $DDL_recname =  a_DBTS_list.a_RECname(#j)
               show $DDL_recname ' match'
               let #match_cnt = #match_cnt + 1
               move 0 to #no_match

              do 2110_Replace_ts_db2_os390
 
            end-if
            if #j = #ts_count+ 1
               move 0 to #no_match
               show $DDL_recname ' nomatch'
               let #nomatch_cnt = #nomatch_cnt + 1
               move $DDL_line_in to $DDL_new_line
               move $DDL_new_line to $DDL_line_out
               do 7200_write_ddlout
               do 7300_read_ddlin
            end-if
        end-while
        let $DDL_createR84 = ' '
        let $DDL_createR81 = ' ' 
      else 
       move $DDL_line_in to $DDL_new_line
       move $DDL_new_line to $DDL_line_out
       do 7200_write_ddlout
       do 7300_read_ddlin
      end-if
    end-if

END-PROCEDURE


!----------------------------------------------------------------------!
! Procedure: 2110_Replace_ts_db2_os390                                 !
! Descr:     We have matched on 'Create Table' or 'Alter Table'.Now    !
!            locate line the has 'IN' or 'TABLESPACE' syntax and       !
!            replace tablespace name. So the output file will contain  !
!            the table/tablespace grouping equal to the xref array.    !
!----------------------------------------------------------------------!

begin-procedure 2110_Replace_ts_db2_os390

#ifdef debugy
       show '2110_replace_ts_os390'
#end-if

     move 1 to #TS_found
     while #TS_found
        find ' IN ' in $DDL_line_in 0 #loc

        if #loc < 0
! Check if IN starts in first position
         find 'IN ' in $DDL_line_in 0 #loc2
         if #loc2 = 0
           let #loc = #loc2
           let #offset = 3
         end-if
        else
        let #offset = 4
        end-if

        if #loc >= 0
         move 0 to #TS_found
         find 'PSIMAGE' in $DDL_line_in 0 #locpsimg
          if #locpsimg < 0
           let #new_loc = #loc + #offset
           let $Part_1 = substr($DDL_line_in,1,#new_loc)
           let $Part_2 = a_DBTS_list.a_DBname(#j)
           let $Part_3 = '.'
           let $Part_4 = a_DBTS_list.a_TSname(#j)
           string $Part_1 $Part_2 $Part_3 $Part_4
              by '' into $DDL_new_line
          else
           move $DDL_line_in to $DDL_new_line
          end-if 
        else
           move $DDL_line_in to $DDL_new_line
        end-if

#ifdef debugx
        show '$DDL_line_in  = ' $DDL_line_in
        show '$DDL_new_line = ' $DDL_new_line
        show '#offset = ' #offset
        show '#loc    = ' #loc
#end-if

        move $DDL_new_line to $DDL_line_out
        do 7200_write_ddlout
        do 7300_read_ddlin
     end-while
END-PROCEDURE


!----------------------------------------------------------------------!
! Procedure: 2110_Replace_ts_db2_unix                                  !
! Descr:     We have matched on 'Create Table' or 'Alter Table'.Now    !
!            locate line the has 'IN' or 'TABLESPACE' syntax and       !
!            replace tablespace name. So the output file will contain  !
!            the table/tablespace grouping equal to the xref array.    !
!----------------------------------------------------------------------!

begin-procedure 2110_Replace_ts_db2_unix

#ifdef debugy
       show '2110_replace_ts_unix'
#end-if

     move 1 to #TS_found
     while #TS_found
        find ' IN ' in $DDL_line_in 0 #loc

        if #loc < 0
! Check if IN starts in first position
         find 'IN ' in $DDL_line_in 0 #loc2

         if #loc2 = 0
           let #loc = #loc2
           let #offset = 3
         end-if
        else
        let #offset = 4
        end-if

        if #loc >= 0
           let #new_loc = #loc + #offset
           let $Part_1 = substr($DDL_line_in,1,#new_loc)
           let $Part_2 = a_DBTS_list.a_TSname(#j)

           find ' INDEX IN ' in $DDL_line_in 0 #loc3
           let $Part_3 = substr($DDL_line_in, #loc3+1, 10)

           if $Part_2 <> 'USERSPACE1'
             string $Part_2 'IDX' by '' into $Part_4
           else
             move $Part_2 to $Part_4
           end-if

           find ' NOT LOGGED ' in $DDL_line_in 0 #loc4
           let $Part_5 = substr($DDL_line_in, #loc4+1, length($DDL_line_in))

           string $Part_1 $Part_2 $Part_3 $Part_4 $Part_5
              by '' into $DDL_new_line
           move 0 to #TS_found
        else
           move $DDL_line_in to $DDL_new_line
        end-if

#ifdef debugx
        show '$DDL_line_in  = ' $DDL_line_in
        show '$DDL_new_line = ' $DDL_new_line
        show '#offset = ' #offset
        show '#loc    = ' #loc
#end-if

        move $DDL_new_line to $DDL_line_out
        do 7200_write_ddlout
        do 7300_read_ddlin
     end-while
END-PROCEDURE


!----------------------------------------------------------------------!
! Procedure: 2110_Replace_ts_oracle                                    !
! Descr:     We have matched on 'Create Table' or 'Alter Table'.Now    !
!            locate line the has 'IN' or 'TABLESPACE' syntax and       !
!            replace tablespace name. So the output file will contain  !
!            the table/tablespace grouping equal to the xref array.    !
!----------------------------------------------------------------------!

begin-procedure 2110_Replace_ts_oracle

#ifdef debugy
       show '2110_replace_ts_oracle'
#end-if

     move 1 to #TS_found
     while #TS_found
        find ' TABLESPACE ' in $DDL_line_in 0 #loc

        if #loc < 0
! Check if TABLESPACE starts in first position
         find 'TABLESPACE ' in $DDL_line_in 0 #loc2

         if #loc2 = 0
           let #loc = #loc2
           let #offset = 11
         end-if
        else
        let #offset = 12
        end-if

        if #loc >= 0
           let #new_loc = #loc + #offset
           let $Part_1 = substr($DDL_line_in,1,#new_loc)
           let $Part_2 = a_DBTS_list.a_TSname(#j)
           let #lenline = length($DDL_line_in)
           let #lenPart1 = length($Part_1)   
           let #lenPart2 = length($Part_2)
           let $SubPart_2 = substr($DDL_line_in,#lenPart1+1,#lenline)
           let #lenSubPart2 = length($SubPart_2)
           find ' ' in $SubPart_2 0 #locTsn
           if #locTsn < 0
              if #lenSubPart2 > #lenPart2
                 let $Part_3 = substr($DDL_line_in,#lenSubPart2+#lenPart1+1,#lenline)
              else
                 let $Part_3 = substr($DDL_line_in,#lenPart2+#lenPart1+1,#lenline)
              end-if
           else
              if #locTsn > #lenPart2
                 let $Part_3 = substr($DDL_line_in,#locTsn+#lenPart1+1,#lenline)
              else
                 let $Part_3 = substr($DDL_line_in,#lenPart2+#lenPart1+1,#lenline)
              end-if
           end-if
           string $Part_1 $Part_2 $Part_3
              by '' into $DDL_new_line
           move 0 to #TS_found
        else
           move $DDL_line_in to $DDL_new_line
        end-if

#ifdef debugx
        show '$DDL_line_in  = ' $DDL_line_in
        show '$DDL_new_line = ' $DDL_new_line
        show '#offset = ' #offset
        show '#loc    = ' #loc
#end-if

        move $DDL_new_line to $DDL_line_out
        do 7200_write_ddlout
        do 7300_read_ddlin
     end-while
END-PROCEDURE


!-----------------------------------------------------------------------------!
! Procedure: 2110_Replace_tablepart_info_oracle                               ! 
! Descr:     We have matched on 'Create Table' and 'Create Index'.Now         !
!            locate the section having table partition and compression        ! 
!            info in the rel script file and replace with the table partition ! 
!            and compression info read from the target DB during the DB       !
!            upgrade.So the output file will contain the customized           !
!            table/index partition and compression info read from the DB.     !
!-----------------------------------------------------------------------------!

begin-procedure 2110_Replace_tablepart_info_oracle

  !Gets the table name from the table USER_TABLES
  DO GET_TABLENAME
  !Gets the table/index metadata from the catalog
#IFDEF ORACLE
  DO GET_TBLMETADATA
  move &VALUE  to $metadata
#ENDIF 
  !Partially selects the table partition info from the tables
  let #strlen=length($metadata)
  find ' PCTFREE ' in $metadata 0 #loc
  let $tabl-partinfo = substr($metadata,#loc+2,#strlen)
  let #column_count = 1  
  let #TS_found = 1
  let #end-of-stmt = 1
  let #loc = 0
  
  let #length=LENGTH($tabl-partinfo)
  let $control_char = substr($tabl-partinfo,#length - 1, 1 )

  LET $tabl-partinfo = replace($tabl-partinfo, chr(10),chr(13)||chr(10))

  let #length=LENGTH($tabl-partinfo)
  if $control_char = chr(10)
     let #length= #length - 3
  end-if 

  while #end-of-stmt
  
  if  $DDL_TYPE = 'TABLE' and #TS_found <> 0

     DO FILL_TABLE_COLUMN
     
  end-if

 
  find ';' in $DDL_line_in 0 #EOS

  if #EOS >= 0
   let #end-of-stmt=0
  else
   let #end-of-stmt=1
  end-if
  
  !Find the keyword 'TABLESPACE' in the relscripts and replace
  !with the customized parameters
  
  if #TS_found <> 0
  find 'TABLESPACE' in $DDL_line_in 0 #loc
  end-if
  
  if #loc < 0 and  #TS_found <> 0
      find 'PCTFREE' in $DDL_line_in 0 #loc
  end-if
 
  if #loc >= 0 and  #TS_found <> 0  

  let $formatted-original = substr($DDL_line_in,1,#loc)
  
  if $DDL_TYPE = 'TABLE'

     DO REMOVE_REDUNDANT_PARTITION
     DO REMOVE_REDUNDANT_LOB

  end-if

  if $DDL_TYPE = 'INDEX'

      DO REMOVE_REDUNDANT_PARTITION

  end-if
  

  LET $tabl-partinfo = substr($tabl-partinfo,1, #length)
  
  string $formatted-original $tabl-partinfo
              by '' into $DDL_new_line         

  let #TS_found = 0
  let #loc = 0

 else
   
  move $DDL_line_in to $DDL_new_line
  let #loc = -1
  
  end-if
 
  move $DDL_new_line to $DDL_line_out
 
  if #TS_found = 0 and #end-of-stmt=1 and #loc < 0

     do 7300_read_ddlin
  else
     do 7200_write_ddlout
     do 7300_read_ddlin
  end-if
end-while

END-PROCEDURE

!----------------------------------------------------------------------!
! Procedure: GET_TABLENAME                                             ! 
! Descr: To get table name from user tables                            !
!----------------------------------------------------------------------!
begin-procedure GET_TABLENAME

let $ps_tblname='PS_'||$DDL_recname
#IFDEF ORACLE 
begin-SELECT

O.Table_Name    &tblname
         
    let $CHK_PS = substr(&tblname,1,3)

!Check whether the table exists in the database 

    if $CHK_PS = 'PS_'
       let $DDL_tblname='PS_'||$DDL_recname
    else
       let $DDL_tblname = $DDL_recname
    end-if
        
FROM USER_TABLES O
WHERE O.TABLE_NAME=$DDL_recname OR O.TABLE_NAME=$ps_tblname
end-SELECT
#ENDIF
END-PROCEDURE

!----------------------------------------------------------------------!
! Procedure: GET_TBLMETADATA                                           !
! Descr: To get metadata about table/index from dual                   !
!----------------------------------------------------------------------!
begin-procedure GET_TBLMETADATA

if $DDL_TYPE='TABLE'
   let $DDL_TYPE_NAME=$DDL_tblname
else
   let $DDL_TYPE_NAME=$DDL_idxname
end-if 
#IFDEF ORACLE
BEGIN-SELECT

!Calls the function to get the metadata about index/table
DBMS_METADATA.GET_DDL($DDL_TYPE,$DDL_TYPE_NAME) &VALUE

FROM dual

END-SELECT
#ENDIF 
end-procedure

!----------------------------------------------------------------------!
! Procedure: check_index_exists                                        !
! Descr: Check whether the index exists for a table                    !
!----------------------------------------------------------------------!
begin-procedure check_index_exists

  let $INDEX_FOUND='N' 
  find ' ON ' in $DDL_line_in 0 #loc
  if #loc >= 0
     let $temp_tbl_name = substr($DDL_line_in,#loc+5,#loc+15)
     unstring $temp_tbl_name by ' ' into $tablename $junk
  end-if
#IFDEF ORACLE  
begin-SELECT

I.INDEX_NAME     &index_name

    let $INDEX_FOUND='Y'

FROM USER_INDEXES I
WHERE I.INDEX_NAME= $DDL_idxname 
end-SELECT
#ENDIF 
end-procedure

!----------------------------------------------------------------------!
! Procedure: FILL_TABLE_COLUMN                                         !
! Descr: Function to fill the column names of table to an array        !
!----------------------------------------------------------------------!

begin-procedure  FILL_TABLE_COLUMN 
    
  if #TS_found <> 0
     if #column_count = 1
      
        find ' (' in $DDL_line_in 0 #loc
        if #loc >= 0
         
           let $DDL_temp_colname = substr($DDL_line_in,#loc+3,#loc+18)
           unstring $DDL_temp_colname  by ' ' into $colname $junk
           
           put $colname into a_table_col_list(#column_count) a_colname
           let #column_count = #column_count + 1
        end-if
     else
        let $DDL_temp_colname = substr($DDL_line_in,4,18)
        unstring $DDL_temp_colname  by ' ' into $colname $junk
        put $colname into a_table_col_list(#column_count) a_colname
        let #column_count = #column_count + 1
    end-if
 end-if 

end-procedure

!------------------------------------------------------------------------!
! Procedure: REMOVE_REDUNDANT_LOB                                        !
! Descr: Remove the redundant LOB column's attributes from the customized!
!        parameters retrieved from the target DB                         !
!------------------------------------------------------------------------!
begin-procedure REMOVE_REDUNDANT_LOB
  
  let #lob_count = 0         
  let $temp-tabl-partinfo = $tabl-partinfo  
  let #lob_found = 0
  let $match_pattern = ''
  let #loc_lob = 0
  let #lob_found = 0
 
  find 'LOB (' in $tabl-partinfo  0 #loc_lob
  !show #loc_lob
 
  if #loc_lob >= 0
   
     let #PARSE_STRING = 1
     let $match_pattern = 'LOB ('
     let $start-tabl-partinfo = substr($tabl-partinfo,1, #loc_lob )
     let #lob_found = 1
      
  end-if

  let #str_length = length( $tabl-partinfo )
  let $temp_str_pattern = ''

  let $append_lob_string = ''
  let $rel_colname  = ''
  let #lob_loc_start = 0
  let #PARSE_STRING = 1
  let #count_open_braces = 0

  while   #str_length <> #loc_lob
  
          let $temp_str_pattern = ''
         
          let $temp_match_pattern_1 = substr($tabl-partinfo,#loc_lob ,1)
          let $temp_match_pattern_2 = substr($tabl-partinfo,#loc_lob + 1,1)
          let $temp_match_pattern_3 = substr($tabl-partinfo,#loc_lob + 2,1)
          let $temp_match_pattern_4 = substr($tabl-partinfo,#loc_lob + 3,1)
          let $temp_match_pattern_5 = substr($tabl-partinfo,#loc_lob + 4,1)
          let $temp_match_pattern_6 = substr($tabl-partinfo,#loc_lob + 5,1)

      
          let $append_lob_string = $append_lob_string ||   substr($tabl-partinfo,#loc_lob ,1)
          
          let $temp_str_pattern = $temp_str_pattern_1 || $temp_match_pattern_2
                                  || $temp_match_pattern_3 || $temp_match_pattern_4 
                                  || $temp_match_pattern_5 || $temp_match_pattern_6
          
         
          if $temp_str_pattern = $match_pattern

             let #lob_loc_start = #loc_lob             
             let $temp_rel_col_name = substr($tabl-partinfo,#loc_lob + 7, 20)
             unstring $temp_rel_col_name  by ' ' into $rel_colname $junk
             
             let #length_rel_col = length ($rel_colname)
              
             let  #lob_loc_start = #lob_loc_start + #length_rel_col + 7

             let #length_rel_col = #length_rel_col - 2 
             let $rel_colname = substr($rel_colname,1, #length_rel_col)
             !show $rel_colname       
             
             DO CHECK_LOB_COLUMN_EXISTS
            
             if  #lob_col_notfound = 0
    
                 let #lob_found = 1

             else
                 
                 let #PARSE_STRING = 1
                 let #count_open_braces = 0
    
                 while #PARSE_STRING = 1
                                         
                       let $temp_str_pattern = ''
                       let $temp_str_pattern =  $temp_str_pattern || substr($tabl-partinfo, #lob_loc_start + 1,1)

                       if $temp_str_pattern = '('
                          let #count_open_braces = #count_open_braces + 1
                       end-if

                       if $temp_str_pattern = ')'
                          let #count_open_braces = #count_open_braces - 1 
                       end-if
        
                       if #count_open_braces = 0 and $temp_str_pattern = ')'
                          let #PARSE_STRING = 0
                       end-if

                       let #lob_loc_start = #lob_loc_start + 1
                      
                end-while
                
                let #loc_lob = #lob_loc_start
                                            
             end-if

          end-if              
       
          let #loc_lob = #loc_lob + 1

  end-while       

if #lob_found = 1  
  
let $tabl-partinfo  = $start-tabl-partinfo || $append_lob_string

end-if
 
end-procedure

!----------------------------------------------------------------------!
! Procedure:  CHECK_LOB_COLUMN_EXISTS                                  !
! Descr: Check whether the LOB column exists in the RELSCRIPT file     !    
!        relative to the target DB                                     !
!----------------------------------------------------------------------!
begin-procedure CHECK_LOB_COLUMN_EXISTS

let #lob_col_notfound = 1
let #loop_counter = #column_count
let #counter = 1
let $lob_col_name= ''
let #partn_col_match = 0

while #lob_col_notfound and #loop_counter <> 0 

      let $lob_col_name = a_table_col_list.a_colname(#counter)
      let #counter = #counter + 1 
      let #loop_counter =  #loop_counter - 1

      if $lob_col_name = $rel_colname
 
         let #lob_col_notfound = 0
         let #partn_col_match  = 1

      end-if
    
end-while

end-procedure

!----------------------------------------------------------------------!
! Procedure:  REMOVE_REDUNDANT_PARTITION                               !
! Descr: Remove the redundant partition attributes from the customized ! 
!        parameters retrieved from the target DB, if columns on which  ! 
!        partitions are made is dropped                                !
!----------------------------------------------------------------------!
begin-procedure REMOVE_REDUNDANT_PARTITION

       
  let $temp-tabl-partinfo = $tabl-partinfo  
  let $match_pattern = ''
  let #loc_partition = 0
  let #count_open_braces = 0
  let #PARSE_STRING = 1  
  let #str-start = 0

  find 'PARTITION BY' in $tabl-partinfo  0 #loc_partition
 
  if #loc_partition >= 0   

     let $start-tabl-partinfo = substr($tabl-partinfo,1, #loc_partition)
     find '(PARTITION' in $tabl-partinfo  0 #loc_partition
     !let #count_open_braces = #count_open_braces + 1 
     !show $start-tabl-partinfo 
  end-if 

  let #str_length = length( $tabl-partinfo )
  let $temp_str_pattern = ''

  let $append_partn_string = ''
  let $new-tabl-partinfo = $start-tabl-partinfo
  
  DO VALIDATE_PARTITIONED_COLS
  !show ' #set_partn_remove'
  !show #set_partn_remove 

  while #PARSE_STRING = 1 and #set_partn_remove = 1 

        let $temp_str_pattern =  $temp_str_pattern || substr($tabl-partinfo, #loc_partition + 1 ,1)
        !show $temp_str_pattern 

        if $temp_str_pattern = '('
           let #count_open_braces = #count_open_braces + 1
           !show #count_open_braces
        end-if

         if $temp_str_pattern = ')'
           let #count_open_braces = #count_open_braces - 1 
        end-if
        
        if #count_open_braces = 0 and $temp_str_pattern = ')'
           let #PARSE_STRING = 0
        end-if
       
        let #loc_partition = #loc_partition + 1
        let $temp_str_pattern = ''
  end-while
       
  if #set_partn_remove = 1

     let $append_partn_string = substr($tabl-partinfo,#loc_partition + 1, #str_length)
     let $tabl-partinfo  = $new-tabl-partinfo ||  $append_partn_string

  end-if
  !show $new-tabl-partinfo
 
end-procedure

!----------------------------------------------------------------------!
! Procedure: VALIDATE_PARTITIONED_COLS                                 !
! Descr: Function contains, the query to get from the target DB list of!
! columns for a table on which partition/subpartitions are made        !
!                                                                      !
!----------------------------------------------------------------------!
begin-procedure VALIDATE_PARTITIONED_COLS


if $DDL_TYPE='TABLE'

   let $DDL_TYPE_NAME=$DDL_tblname

else

   let $DDL_TYPE_NAME=$DDL_idxname

end-if

let #set_partn_remove = 0 
let $rel_colname = ''
#IFDEF ORACLE
begin-SELECT

O.COLUMN_NAME    &COLUMN_NAME

    let  $rel_colname  = &COLUMN_NAME
    DO CHECK_LOB_COLUMN_EXISTS

    if #partn_col_match = 0
       let #set_partn_remove = 1
    end-if
        
FROM USER_PART_KEY_COLUMNS O
WHERE O.NAME=$DDL_TYPE_NAME  AND O.OBJECT_TYPE=$DDL_TYPE
UNION SELECT B.COLUMN_NAME FROM USER_SUBPART_KEY_COLUMNS B WHERE B.NAME=$DDL_TYPE_NAME and B.OBJECT_TYPE=$DDL_TYPE
end-SELECT
#ENDIF 
end-procedure

!----------------------------------------------------------------------!
! Procedure: 2110_Replace_ts_informix                                  !
! Descr:     We have matched on 'Create Table' or 'Alter Table'.Now    !
!            locate line that has 'IN' syntax and replace tablespace   !
!            name. So the output file will contain the                 !
!            table/tablespace grouping equal to the xref array.        !
!----------------------------------------------------------------------!

begin-procedure 2110_Replace_ts_informix

#ifdef debugy
       show '2110_replace_ts_informix'
#end-if

     move 1 to #TS_found
     while #TS_found
        find ' IN ' in $DDL_line_in 0 #loc

        if #loc < 0
! Check if IN starts in first position
         find 'IN ' in $DDL_line_in 0 #loc2

         if #loc2 = 0
           let #loc = #loc2
           let #offset = 3
         end-if
        else
        let #offset = 4
        end-if

        if #loc >= 0
           let #new_loc = #loc + #offset
           let $Part_1 = substr($DDL_line_in,1,#new_loc)
           let $Part_2 = a_DBTS_list.a_TSname(#j)
           string $Part_1 $Part_2
              by '' into $DDL_new_line
           move 0 to #TS_found
        else
           move $DDL_line_in to $DDL_new_line
        end-if

#ifdef debugx
        show '$DDL_line_in  = ' $DDL_line_in
        show '$DDL_new_line = ' $DDL_new_line
        show '#offset = ' #offset
        show '#loc    = ' #loc
#end-if

        move $DDL_new_line to $DDL_line_out
        do 7200_write_ddlout
        do 7300_read_ddlin
     end-while
END-PROCEDURE


!----------------------------------------------------------------------!
! Procedure: 5000-read-sys-catalog                                     !
! Descr:     Build the xref array be reading the database catalogs     !
!            to get table/tablespace cross reference.                  !
!----------------------------------------------------------------------!


begin-procedure 5000-read-sys-catalog

 let $i_recname = ' '
 let $i_dbname  = ' '
 let $i_tsname  = ' '
 move 1 to #ts_count


#IFDEF DB2
begin-SELECT

NAME            &i_recname_1
DBNAME          &i_dbname_1
TSNAME          &i_tsname_1

        let $i_recname = rtrim(substr(&i_recname_1,4,15),' ')
        let $i_dbname  = rtrim(substr(&i_dbname_1,1,8),' ')
        let $i_tsname  = rtrim(substr(&i_tsname_1,1,8),' ')

        do 1100_build_array

FROM SYSIBM.SYSTABLES
WHERE CREATOR = CURRENT SQLID
  AND TYPE = 'T'
  AND SUBSTR(NAME, 1, 3) = 'PS_'

end-SELECT

begin-SELECT

NAME            &i_recname_2
DBNAME          &i_dbname_2
TSNAME          &i_tsname_2

        let $i_recname = rtrim(substr(&i_recname_2,1,15),' ')
        let $i_dbname  = rtrim(substr(&i_dbname_2,1,8),' ')
        let $i_tsname  = rtrim(substr(&i_tsname_2,1,8),' ')

        do 1100_build_array

FROM SYSIBM.SYSTABLES
WHERE CREATOR = CURRENT SQLID
  AND TYPE = 'T'
  AND SUBSTR(NAME, 1, 3) <> 'PS_'

end-SELECT

#ENDIF


#IFDEF DB2UNIX

begin-SELECT

TABNAME         &i_recname_1
TBSPACE         &i_tsname_1

        let $i_recname = rtrim(substr(&i_recname_1,4,15),' ')
        let $i_tsname  = rtrim(&i_tsname_1,' ')

        do 1100_build_array

FROM SYSCAT.TABLES
WHERE SUBSTR(TABNAME, 1, 3) = 'PS_' AND
TYPE = 'T'

end-SELECT

begin-SELECT

TABNAME         &i_recname_2
TBSPACE         &i_tsname_2

        let $i_recname = rtrim(substr(&i_recname_2,1,15),' ')
        let $i_tsname  = rtrim(&i_tsname_2,' ')

        do 1100_build_array

FROM SYSCAT.TABLES
WHERE SUBSTR(TABNAME, 1, 3) <> 'PS_' AND
TYPE = 'T'

end-SELECT

#ENDIF


#IFDEF ORACLE

begin-SELECT

O.Table_Name            &i_recname_1
O.Tablespace_Name       &i_tsname_1

        let $i_recname = rtrim(substr(&i_recname_1,4,15),' ')
        let $i_tsname  = rtrim(&i_tsname_1,' ')

        do 1100_build_array

FROM USER_TABLES O
WHERE SUBSTR(TABLE_NAME, 1, 3) = 'PS_'
end-SELECT

begin-SELECT

O.Table_Name            &i_recname_2
O.Tablespace_Name       &i_tsname_2

        let $i_recname = rtrim(substr(&i_recname_2,1,15),' ')
        let $i_tsname  = rtrim(&i_tsname_2,' ')

        do 1100_build_array

FROM USER_TABLES O
WHERE SUBSTR(TABLE_NAME, 1, 3) <> 'PS_'
end-SELECT

#ENDIF

#IFDEF INFORMIX

begin-SELECT

UPPER(tabname)                &i_recname_1
DBINFO('dbspace', partnum)    &i_tsname_1

        let $nameprefix = substr(&i_recname_1, 1,3)
        if $nameprefix = 'PS_'
                let $i_recname = rtrim(substr(&i_recname_1,4,15),' ')
        else
                let $i_recname = rtrim(substr(&i_recname_1,1,15),' ')
        end-if
        let $i_tsname  = rtrim(&i_tsname_1,' ')

        do 1100_build_array

FROM 'informix'.systables
WHERE tabid > 99        ! User table id starts at 100 and on
AND   tabtype = 'T'
end-SELECT

#ENDIF

let #ts_count = #ts_count - 1
end-procedure


!----------------------------------------------------------------------!
! Procedure: 6100_open_dbtsin                                          !
! Descr:     Called if xref array is built from existing file. This    !
!            may be handy if you want to create your own xref array    !
!            and then manually change the tablespace names.            !
!----------------------------------------------------------------------!

begin-procedure 6100_open_dbtsin

let #user_input_err = 1

while #user_input_err = 1

   input $dbtsin 'Input file with list of tables and tablespaces (i.e. C:\TEMP\DBTSIN.SQL). Enter ? to Quit'

   if $dbtsin = '?'
      show 'Program Ending per user request'
      stop quiet
   end-if

   let #user_input_err = 0

   if isnull($dbtsin)

    #ifdef ORACLE
        show 'Program Error: Input file required. Please enter full path to input file!!'
      let #user_input_err = 1
    #else
     #ifdef DB2ALL
      #ifdef MVS
         let $dbtsin = '{FILEPREFIX}DBTSIN{FILESUFFIX}'
      #else
         show 'Program Error: Input file required. Please enter full path to input file!!'
         let #user_input_err = 1
      #end-if

     #end-if

    #end-if

   end-if

open $dbtsin as 100 for-reading
record=340
STATUS=#100_Status

#ifdef debugx
        show '100 status Open DBTS List In ===> ' #100_Status
        show ' '
#end-if

if #100_Status <> 0
  show 'Program Error: Could not open Input file:' $dbtsin
  let #user_input_err = 1
end-if

end-while

let #end-file = 99
END-PROCEDURE

!----------------------------------------------------------------------!
! Procedure: 6200_open_ddlout                                          !
! Descr:     Open output file.                                         !
!----------------------------------------------------------------------!

begin-procedure 6200_open_ddlout

let #user_input_err = 1

while #user_input_err = 1

   input $ddlout 'Specify output file name (i.e. N:\PS_HOME\SCRIPTS\REL800DBTSFIX.SQL). Enter ? to Quit: '

   if $ddlout = '?'
      show 'Program Ending per user request'
      stop quiet
   end-if

   let #user_input_err = 0

   if isnull($ddlout)

    #ifdef ORACLE
      show 'Program Error: Output file required. Please enter full path to input file!!'
      let #user_input_err = 1
    #else
     #ifdef DB2ALL
      #ifdef MVS
         let $ddlout = '{FILEPREFIX}DDLOUT{FILESUFFIX}'
      #else
         show 'Program Error: Output file required. Please enter full path to input file!!'
         let #user_input_err = 1
      #end-if

     #end-if

    #end-if

   end-if

open $ddlout as 200 for-writing
     record=4000
STATUS=#200_Status

#ifdef debugx
        show '200 status Open DDL Out ==> ' #200_Status
        show ' '
#end-if

if #200_Status <> 0
  show 'Program Error: Could not open file for writing:' $ddlout
  let #user_input_err = 1
end-if

end-while

END-PROCEDURE

!----------------------------------------------------------------------!
! Procedure: 6300_open_ddlin                                           !
! Descr:     Open input file.                                          !
!----------------------------------------------------------------------!

begin-procedure 6300_open_ddlin

let #user_input_err = 1

while #user_input_err = 1

  input $ddlin 'Specify input file name (i.e. N:\PS_HOME\SCRIPTS\REL800.SQL). Enter ? to Quit: '

  if $ddlin = '?'
     show 'Program Ending per user request'
     stop quiet
  end-if

  let #user_input_err = 0

  if isnull($ddlin)

  #ifdef ORACLE
     show 'Program Error: Input file required. Please enter full path to input file!!'
     let #user_input_err = 1
  #else
   #ifdef DB2ALL
     #ifdef MVS
        let $ddlin = '{FILEPREFIX}DDLIN{FILESUFFIX}'
     #else
        show 'Program Error: Input file required. Please enter full path to input file!!'
        let #user_input_err = 1
     #end-if

    #end-if

   #end-if

  end-if

open $ddlin as 300 for-reading
    record=340
STATUS=#300_Status

#ifdef debugx
        show '300 status Open DDL In ===> ' #300_Status
        show ' '
#end-if

if #300_Status <> 0
  show 'Program Error: Could not open Input Script:' $ddlin
  let #user_input_err = 1
end-if

end-while

let #end-file = 99
END-PROCEDURE

!----------------------------------------------------------------------!
! Descr:     READ and WRITE                                            !
!----------------------------------------------------------------------!

begin-procedure 7100_read_dbtsin
 let $i_recname = ' '
 let $i_dbname  = ' '
 let $i_tsname  = ' '

READ 100 INTO $i_recname:15 $i_dbname:8 $i_tsname:30
STATUS=#100_Status

if #end-file = 0
    add +1 to #ts_count
end-if
END-PROCEDURE

begin-procedure 7200_write_ddlout
 let $o_DDL_line_out = rtrim($DDL_line_out,' ')

 !T-GROMIT-7888301 - s.bacon 07/11/01 removed length 
 !specification from WRITE statement

WRITE 200 FROM $o_DDL_line_out
STATUS=#200_Status
add +1   to #DDL_out_ct
move ' ' to $DDL_line_out
END-PROCEDURE

begin-procedure 7300_read_ddlin
 let $DDL_line_in = ' '
READ 300 INTO $DDL_line_in:340
STATUS=#300_Status
if #end-file = 0
    add +1 to #DDL_in_ct
end-if
END-PROCEDURE

!----------------------------------------------------------------------!
! Descr:     CLOSE                                                     !
!----------------------------------------------------------------------!

begin-procedure 8100_close_dbtsin
close 100
END-PROCEDURE

begin-procedure 8200_close_ddlout
close 200
END-PROCEDURE

begin-procedure 8300_close_ddlin
close 300
END-PROCEDURE


#include 'tranctrl.sqc'      ! TRANSACTION CONTROL

