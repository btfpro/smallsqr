!***********************************************************************
! TBLUTILS: General library functions used by the Table Access Utility
!***********************************************************************
!                                                                      *
!               Confidentiality Information:                           *
!                                                                      *
! This module contains confidential and proprietary information        *
! of Oracle; it is not to be copied, reproduced, or transmitted        *
! in any form, by any means, in whole or in part, nor is it to         *
! be used for any purpose other than that for which it is              *
! expressly provided under the applicable license agreement.           *
!                                                                      *
! Copyright (C) 2006 Oracle. All Rights Reserved.                      *
!                                                                      *
!***********************************************************************
!                                                                      *
!          $Date:  2006/07/19:15:37:29                                 !
!       $Release:  HR9                                                 !
!      $Revision:  101                                                 !
!                                                                      *
!***********************************************************************

!These definitions must be made by application depending on libraries in use...

!#define USE_TOKEN_PARSING_LIB
!#define USE_OS_FILE_MGMT_LIB
!#define USE_STACK_LIB
!  #define STACK_SIZE   1000
!#define USE_LINKED_LIST_LIB
!  #define LIST_SIZE    7500
!#define USE_DATETIME_LIB

!This setup must be incorporated by the application in it's initialization section...

!   do Init-Token-Parsing-Lib
!   do Init-OS-File-Mgmt-Lib
!   do Init-Stack-Lib(#UniqueValues)
!   do Init-Link-Lists-Lib(#SortList)

!******************************************************************************
! Token Parsing Public Routines
!
! Init-Token-Parsing-Lib
! Set-Ignore-Quoted-String(#Mode)
! NameValuePair($Input, :$Name, :$Value)
! Parse_Token($Input, $Delim, :$Token, :$Output)
! Parse_Token_From_End($Input, $Delim, :$Token, :$Output)
! Find_In_CharList($Input, $List, #IgnoreQuoted, :#Posn)
! Find_Last_In_CharList($Input, $List, #IgnoreQuoted, :#Posn)
! Get-PS-Table(:$Str, :$Table)
!
!******************************************************************************
! OS File Management Public Routines
!
! Init-OS-File-Mgmt-Lib
! Set-File-Abort-On-Error(#Abort)
! Make-FileName ($Base, $Extension, :$FileName)
! Make-FileSpec ($Path, $Base, $Extension, :$FileSpec)
! Parse-FileSpec ($FileSpec, :$Path, :$Base, :$Extension)
! Get-First-Wildcard-FileName ($FileSpec, :$FileName)
! Get-Next-Wildcard-FileName (:$FileName)
! Open-File ($FileSpec, #RecSize, :#FileNum)
! Open-File-For-Writing ($FileSpec, #RecSize, :#FileNum)
! Close-File (:#FileNum)
! Close-All-Files
! Read-Line (#FileNum, :$Str, :#EOF)
! Write-Line (#FileNum, $Str)
!
!******************************************************************************
! Stack Management Public Routines
!
! Init-Stack-Lib(#UniqueValues)
! ClearStack
! Push($Str1)
! Push1($Str1, #Num1)
! Push2($Str1, $Str2, #Num1, #Num2)
! Push3($Str1, $Str2, $Str3, #Num1, #Num2, #Num3)
! Pop(:$Str1, :#EndOfStack)
! Pop1(:$Str1, :#Num1, :#EndOfStack)
! Pop2(:$Str1, :$Str2, :#Num1, :#Num2, :#EndOfStack)
! Pop3(:$Str1, :$Str2, :$Str3, :#Num1, :#Num2, :#Num3, :#EndOfStack)
! StackCount(:#StackCount)
!
!******************************************************************************
! Double Linked-list Management Public Routines
!
! Init-Link-Lists-Lib(#SortList)
! ClearLinkedList
! Top-Of-List(:#FirstLink)
! Bottom-Of-List(:#LastLink)
! List-Count(:#Count)
! Find-Key($Key, :#Idx)
! Add-Key-To-List($Key, :#Idx)
! Delete-Key-From-List($Key)
! Relocate-Node(#SrcLink, #DestLink, $Mode)
!
!******************************************************************************
! DateTime Display Public Routines
!
! Display-Time($Msg)
!
!******************************************************************************

#ifdef USE_TOKEN_PARSING_LIB

!******************************************************************************
!                      Token Parsing Routines
!******************************************************************************

!******************************************************************************
begin-procedure Init-Token-Parsing-Lib
!
!Must be called before any other parsing routines are called to establish the
!global management variables.
!******************************************************************************

#define SQUOTE           ''''
#define DQUOTE           '"'

   let #IgnoreQuotedStr = 1

end-procedure

!******************************************************************************
begin-procedure Set-Ignore-Quoted-String(#Mode)
!
!Inputs
! #Mode:  Pass 1 to ignore quoted text (that is, quoted text will not be
!         analyzed when searching for tokens), or 0 to make the entire string
!         significant.
!
!******************************************************************************

   let #_IgnoreQuotedStr = #Mode

end-procedure

!******************************************************************************
begin-procedure NameValuePair($Input, :$Name, :$Value)
!
!Inputs
! $Input:   The "Name=Value" string to be parsed.
!
!Outputs
! $Name:    The "Name" part of the "Name=Value" pair
! $Value:   The "Value" part of the "Name=Value" pair
!
!******************************************************************************

   let #Idx = InStr($Input, '=', 1)
   if (#Idx = 0)
      let $Name = ''
      let $Value = ''
   else
      let #Length = Length($Input)
      let $Name = SubStr($Input, 1, (#Idx - 1))
      let $Value = SubStr($Input, (#Idx + 1), (#Length - #Idx))

      let $Name = RTrim($Name,' ')
      let $Value = LTrim($Value,' ')
      let $Value = RTrim($Value,' ')
   end-if

end-procedure

!******************************************************************************
begin-procedure Parse_Token($Input, $Delim, :$Token, :$Output)
!
!Inputs
! $Input:   The string to be parsed.
! $Delim:   The set of token-delimiting characters.
!
!Outputs
! $Token:   The extracted token (that is, characters from the beginning of
!           $Input up to the first delimiter, with leading and trailing
!           spaces removed, and quotes, if any, removed). If a delimiter is not
!           found, the entire $Input is returned as the current token.
! $Output:  Remainder of $Input string after token and delimter were removed.
!
!******************************************************************************

   do Find_In_CharList($Input, $Delim, #_IgnoreQuotedStr, #Idx)
   if (#Idx = 0)
      let $Token = $Input
      let $Output = ''
   else
      let #Len = Length($Input)
      let $Token = SubStr($Input, 1, (#Idx - 1))
      let $Token = LTrim($Token,' ')
      let $Token = RTrim($Token,' ')
      do RemoveQuotes($Token)
      let $Output = SubStr($Input, (#Idx + 1), (#Len - #Idx))
      let $Output = LTrim($Output,' ')
   end-if

end-procedure

!******************************************************************************
begin-procedure Parse_Token_From_End($Input, $Delim, :$Token, :$Output)
!
!Inputs
! $Input:   The string to be parsed.
! $Delim:   The set of token-delimiting characters.
!
!Outputs
! $Token:   The extracted token (that is, characters from the end of $Input
!           back to the first delimiter, with leading and trailing spaces
!           removed, and quotes, if any, removed). If a delimiter is not
!           found, the entire $Input is returned as the current token.
! $Output:  Remainder of $Input string after token and delimter were removed.
!
!******************************************************************************

   do Find_Last_In_CharList($Input, $Delim, #_IgnoreQuotedStr, #Idx)
   if (#Idx = 0)
      let $Token = $Input
      let $Output = ''
   else
      let #Len = Length($Input)
      let $Token = SubStr($Input, (#Idx + 1), (#Len - #Idx))
      let $Token = LTrim($Token,' ')
      let $Token = RTrim($Token,' ')
      do RemoveQuotes($Token)
      let $Output = SubStr($Input, 1, (#Idx - 1))
      let $Output = RTrim($Output,' ')
   end-if

end-procedure

!******************************************************************************
begin-procedure Find_In_CharList($Input, $List, #IgnoreQuoted, :#Posn)
!
!Inputs
! $Input:        The string to be searched.
! $List:         The set of target characters to find.
! #IgnoreQuoted: Flag to ignore (TRUE) or include (FALSE) characters within a
!                quoted portion of the $Input string,
!
!Outputs
! #Posn:    The position of the first character in $Input which is contained in
!           the target $List, or zero (0) if no match is found.
!
!******************************************************************************

   if IsNull($List)
      let $Msg = 'Error: Find_In_CharList(): No target character list supplied'
      display $Msg
      stop
   end-if
   if (#IgnoreQuoted)
      let #QS = InStr($List, {SQUOTE}, 1)
      let #QD = InStr($List, {DQUOTE}, 1)
      if (#QS Or #QD)
         let $Msg = 'Error: Find_In_CharList: IgnoreQuotedString is TRUE but Target list contains quotes'
         display $Msg
         stop
      end-if
   end-if

   let #Posn = 0
   let $InQuotes = ''

   let #Len = Length($Input)
   let #Idx = 1
   while (#Idx <= #Len)
      let $TestChar = SubStr($Input, #Idx, 1)
      if (#IgnoreQuoted)
         if ($InQuotes = '')
            if ($TestChar = {SQUOTE}) Or ($TestChar = {DQUOTE})
               let $InQuotes = $TestChar
            end-if
         else
            if ($InQuotes = $TestChar)
               let $InQuotes = ''
            end-if
         end-if
      end-if
      if (Not #IgnoreQuoted) Or ($InQuotes = '')
         let #Found = InStr($List, $TestChar, 1)
         if (#Found)
            let #Posn = #Idx
            break
         end-if
      end-if
      let #Idx = #Idx + 1
   end-while

end-procedure

!******************************************************************************
begin-procedure Find_Last_In_CharList($Input, $List, #IgnoreQuoted, :#Posn)
!
!Inputs
! $Input:   The string to be searched.
! $List:    The set of target characters to find.
! #IgnoreQuoted: Flag to ignore (TRUE) or include (FALSE) characters within a
!                quoted portion of the $Input string,
!
!Outputs
! #Posn:    The position of the last character in $Input which is contained in
!           the target $List, or zero (0) if no match is found.
!
!******************************************************************************

   if IsNull($List)
      let $Msg = 'Error: Find_Last_In_CharList: No target character list supplied'
      display $Msg
      stop
   end-if
   if (#IgnoreQuoted)
      let #QS = InStr($List, {SQUOTE}, 1)
      let #QD = InStr($List, {DQUOTE}, 1)
      if (#QS Or #QD)
         let $Msg = 'Error: Find_Last_In_CharList: IgnoreQuotedString is TRUE but Target list contains quotes'
         display $Msg
         stop
      end-if
   end-if

   let #Posn = 0
   let $InQuotes = ''

   let #Idx = Length($Input)
   while (#Idx > 0)
      let $TestChar = SubStr($Input, #Idx, 1)
      if (#IgnoreQuoted)
         if ($InQuotes = '')
            if ($TestChar = {SQUOTE}) Or ($TestChar = {DQUOTE})
               let $InQuotes = $TestChar
            end-if
         else
            if ($InQuotes = $TestChar)
               let $InQuotes = ''
            end-if
         end-if
      end-if
      if (Not #IgnoreQuoted) Or ($InQuotes = '')
         let #Found = InStr($List, $TestChar, 1)
         if (#Found)
            let #Posn = #Idx
            break
         end-if
      end-if
      let #Idx = #Idx - 1
   end-while

end-procedure

!******************************************************************************
begin-procedure Get-PS-Table(:$Str, :$Table)
!
!Inputs
! $Str  :        The string to be searched.
!
!Outputs
! $Table:   The first PS Table name found, or Blank if no match is found.
! $Str  :   Remainder of input string after $Table has been extracted.
!
!******************************************************************************

   let $Table = ''

   if ($_IncludeToolsTables = 'N')
      let #Token = InStr($Str, 'PS_', 1)
   else
      let #Token = InStr($Str, 'PS', 1)
   end-if
   if Not (#Token)
      !Translate Table is special case because it is a pseudo-application table...
      let #Token = InStr($Str, 'PSXLATITEM', 1)
      if Not (#Token)
         let #Token = InStr($Str, 'XLATTABLE', 1)
      end-if
   end-if

   if (#Token)

      let #SubstTablesUsed = 0
      if (#Token > 1)
         let #SubstTablesUsed = (SubStr($Str, #Token - 1, 1) = '[')
      end-if

      let #EndPos1 = InStr($Str, ' ', #Token)
      let #EndPos2 = InStr($Str, ',', #Token)
      let #EndPos3 = InStr($Str, '.', #Token)
      let #EndPos4 = InStr($Str, ':', #Token)
      let #EndPos5 = InStr($Str, ')', #Token)
      let #EndPos6 = InStr($Str, ';', #Token)

      let #EndPos = #EndPos1
      if (#EndPos2 <> 0) And ((#EndPos2 < #EndPos) Or (#EndPos = 0))
         let #EndPos = #EndPos2
      end-if
      if (#EndPos3 <> 0) And ((#EndPos3 < #EndPos) Or (#EndPos = 0))
         let #EndPos = #EndPos3
      end-if
      if (#EndPos4 <> 0) And ((#EndPos4 < #EndPos) Or (#EndPos = 0))
         let #EndPos = #EndPos4
      end-if
      if (#EndPos5 <> 0) And ((#EndPos5 < #EndPos) Or (#EndPos = 0))
         let #EndPos = #EndPos5
      end-if
      if (#EndPos6 <> 0) And ((#EndPos6 < #EndPos) Or (#EndPos = 0))
         let #EndPos = #EndPos6
      end-if
      if (#EndPos = 0)
         let #Len = Length($Str) - #Token + 1
      else
         let #Len = #EndPos - #Token
      end-if

      let $Table = SubStr($Str, #Token, #Len)
      if (#SubstTablesUsed)
         let $Table = '[' || $Table || ']'
      end-if

      let #Token = #Token + #Len
      let #Len = Length($Str) - #Token + 1
      let $Str = SubStr($Str, #Token, #Len)

   end-if

end-procedure

!******************************************************************************
begin-procedure RemoveQuotes(:$Input)
!
!Inputs
! $Str:    The string to be modified.
!******************************************************************************

   do IsQuoted($Input, #IsQuoted)
   if (#IsQuoted)

      let $Input = LTrim($Input,' ')
      let $Input = RTrim($Input,' ')
      let $Quote = SubStr($Input, 1, 1)

      if ($Quote = {SQUOTE})
         let $Input = LTrim($Input,{SQUOTE})
         let $Input = RTrim($Input,{SQUOTE})
      else
         let $Input = LTrim($Input,{DQUOTE})
         let $Input = RTrim($Input,{DQUOTE})
      end-if
   end-if

end-procedure

!******************************************************************************
begin-procedure IsQuoted($Input, :#IsQuoted)
!
!Inputs
! $Input:    The string to be analyzed.
!
!Outputs
! #IsQuoted: 1 if the string is enclosed in quotes, 0 if not.
!******************************************************************************

   let #IsQuoted = 0

   let $Input = LTrim($Input,' ')
   let $Input = RTrim($Input,' ')

   let #Len = Length($Input)
   let $FirstChar = SubStr($Input, 1, 1)
   let $LastChar  = SubStr($Input, #Len, 1)

   if ($FirstChar = {SQUOTE}) And ($LastChar = {SQUOTE})
      let #IsQuoted = 1
   end-if
   if ($FirstChar = {DQUOTE}) And ($LastChar = {DQUOTE})
      let #IsQuoted = 1
   end-if

end-procedure

#end-if

#ifdef USE_OS_FILE_MGMT_LIB

!******************************************************************************
!                     OS File Management Routines
!******************************************************************************

!******************************************************************************
begin-procedure Init-OS-File-Mgmt-Lib
!
!Must be called before any other OS File routines are called to establish the
!global management variables and create the File handle array.
!
!******************************************************************************

#define MAX_BUF_SIZE       2048
#define FILENO_BASE        50
#define MAX_FILE_HANDLES   10
#define WILDCARD_LIST      '~DIRLIST.LIS'
#ifdef NT
  #define PATH_SEPARATOR      '\'
  #define PATH_SEPLIST        '\\'
#end-if
#ifdef UNIX
  #define PATH_SEPARATOR      '/'
  #define PATH_SEPLIST        '//'
#end-if

   let #WildCardFileNo = 0
   let #AbortOnFileOpenErr = 0
   let #OpenForWriting = 0

   create-array name=FileHandles size={MAX_FILE_HANDLES}
   field=FileSpec:char
   field=RecSize:number
   field=Writeable:number
   field=EOF:number

end-procedure

!******************************************************************************
begin-procedure Set-File-Abort-On-Error(#Abort)
!
!Inputs...
!  #Abort: Pass 1 to abort the program in response to a file error, or 0 to
!          only generate warnings but continue processing.
!
!******************************************************************************

   let #_AbortOnFileOpenErr = #Abort

end-procedure

!******************************************************************************
begin-procedure Make-FileName ($Base, $Extension, :$FileName)
!
!Inputs...
!  $Base:       The root file name (may optionally include an extension)
!  $Extension:  The optional file extension
!
!Outputs...
!  $FileName:   The FileName is constructed by appending the $Extension (if
!               supplied) to the $Base, replacing any existing extension.
!******************************************************************************

   if IsBlank($Extension)
      let $FileName = $Base
   else
      let #Pos = InStr($Base,'.',1)
      if (#Pos > 0)
        let #Pos = #Pos - 1
         let $Base = SubStr($Base, 1, #Pos)
      end-if
      if (SubStr($Extension, 1, 1) = '.')
         let $FileName = $Base || $Extension
      else
         let $FileName = $Base || '.' || $Extension
      end-if
   end-if

end-procedure

!******************************************************************************
begin-procedure Make-FileSpec ($Path, $Base, $Extension, :$FileSpec)
!
!Inputs...
!  $Path:       The optional file path (drive:\path\path\...)
!  $Base:       The root file name (may optionally include a path and/or
!               extension)
!  $Extension:  The optional file extension
!
!Outputs...
!  $FileSpec:   The FileSpec is constructed by appending the $Extension (if
!               supplied) to the $Base, replacing any existing extension; and
!               prepending the $Path (if supplied) to the $Base, replacing any
!               existing path.
!******************************************************************************

   let $Path = Translate($Path, '/\', {PATH_SEPLIST})
   let $Base = Translate($Base, '/\', {PATH_SEPLIST})

   do Parse-FileSpec ($Base, $BasePath, $BaseBase, $BaseExtension)

   if IsBlank($Extension)
      if IsBlank($BaseExtension)
         let $FileName = $BaseBase
      else
         let $FileName = $BaseBase || '.' || $BaseExtension
      end-if
   else
      if (SubStr($Extension, 1, 1) = '.')
         let $FileName = $BaseBase || $Extension
      else
         let $FileName = $BaseBase || '.' || $Extension
      end-if
   end-if

   if IsBlank($Path)
      if IsBlank($BasePath)
         let $FileSpec =  $FileName
      else
         let $FileSpec = $BasePath || $FileName
      end-if
   else
      let #Pos = Length($Path)
      if (SubStr($Path, #Pos, 1) = {PATH_SEPARATOR})
         let #Pos = #Pos - 1
         let $Path = SubStr($Path, 1, #Pos)
      end-if
      let $FileSpec = $Path || {PATH_SEPARATOR} || $FileName
   end-if

end-procedure

!******************************************************************************
begin-procedure Parse-FileSpec ($FileSpec, :$Path, :$Base, :$Extension)
!
!Inputs...
!  $FileSpec:   The FileSpec to be parsed to it's components
!
!Outputs...
!  $Path:       The path part, including any terminal backslash or colon.
!  $Base:       The root file name part
!  $Extension:  The extension part
!******************************************************************************

   let $FileSpec = Translate($FileSpec, '\/', {PATH_SEPLIST})
   let $Path = ''
   let $Base = $FileSpec
   let $Extension = ''

   let #Pos = Length($FileSpec)
   while (#Pos)
      let $Test = SubStr($FileSpec, #Pos, 1)
      if ($Test = '.') And IsBlank($Extension)
         let #Len = Length($FileSpec) - #Pos
         let $Extension = SubStr($FileSpec, #Pos + 1, #Len)
         let $Base = SubStr($FileSpec, 1, #Pos - 1)
      end-if
      if ($Test = {PATH_SEPARATOR}) Or ($Test = ':')
         let #Len = Length($Base) - #Pos
         let $Path = SubStr($FileSpec, 1, #Pos)
         let $Base = SubStr($FileSpec, #Pos + 1, #Len)
         break
      end-if
      let #Pos = #Pos - 1
   end-while

end-procedure

!******************************************************************************
begin-procedure Get-First-Wildcard-FileName ($FileSpec, :$FileName)
!
!Inputs...
!  $FileSpec:   The FileSpec to drive the filename search.
!
!Outputs...
!  $FileName:   The first filename found matching the search specification, or
!               an empty string if no files were found.  Only the Base.Ext are
!               returned.  Note that directories, system files and hidden files
!               are excluded from the search.
!******************************************************************************

   if (#_WildCardFileNo)
      do Close-File(#_WildCardFileNo)
   end-if

   let $TempDir = getenv('TEMP')
   if IsBlank($TempDir)
      let $Msg = 'Error: %TEMP% environment variable not defined.'
      display $Msg
      stop
   end-if
   do Make-FileSpec ($TempDir, {WILDCARD_LIST}, '', $DirList)

   let $ComSpec = getenv('COMSPEC')
   if IsBlank($ComSpec)
      let $Msg = 'Error: %COMSPEC environment variable not defined.'
      display $Msg
      stop
   end-if

#ifdef NT
   let $Cmd = $ComSpec || ' /c DIR ' || $FileSpec || ' /B /O:N /A:-D-S-H > ' || $DirList
#end-if
#ifdef UNIX
   let $Cmd = 'ls ' || $FileSpec || ' ?flags? > ' || $DirList
#end-if
   CALL SYSTEM USING $Cmd #RtnCd WAIT
   if (#RtnCd)
      let $Msg = 'Error: System call failed: ' || $Cmd
      display $Msg
      let $Msg = 'Error: System call failed: ErrorCode=' || to_char(#RtnCd)
      display $Msg
      stop
   end-if

   do Open-File($DirList, 256, #_WildCardFileNo)
   let $FileName = ''
   if (#_WildCardFileNo)
      do Read-Line (#_WildCardFileNo, $Str, #EOF)
      if (#EOF)
         let $FileName = ''
         do Close-File(#_WildCardFileNo)
      else
         let $FileName = $Str
      end-if
   end-if

end-procedure

!******************************************************************************
begin-procedure Get-Next-Wildcard-FileName (:$FileName)
!
!Outputs...
!  $FileName:   The next filename found matching the search specification, or
!               an empty string if not more files exist.
!******************************************************************************

   let $FileName = ''
   if (#_WildCardFileNo)
      do Read-Line (#_WildCardFileNo, $Str, #EOF)
      if (#EOF)
         let $FileName = ''
         do Close-File(#_WildCardFileNo)
      else
         let $FileName = $Str
      end-if
   end-if

end-procedure

!******************************************************************************
begin-procedure Open-File ($FileSpec, #RecSize, :#FileNum)
!
!Inputs...
!  $FileSpec:   The FileSpec to be opened in READ-ONLY mode.
!  #RecSize:    The maximum record-size that will be read from the file.
!               Note: At this time we cannot dynamically specify RecSize so this
!               parameter is never used.
!
!Outputs...
!  #FileNum:    A handle to the opened file - must be passed by the application
!               to all subsequent file management routines.
!******************************************************************************

   do Find-Available-File-Handle (#FileNum)

   let #FilePtr = #FileNum - {FILENO_BASE}
   put $FileSpec #RecSize #_OpenForWriting 0 into FileHandles(#FilePtr)

   !At this time cannot dynamically pass RecSize so must use {MAX_BUF_SIZE}
   if (#_OpenForWriting)
      open $FileSpec as #FileNum for-writing record={MAX_BUF_SIZE}:vary status=#RtnCd
   else
      open $FileSpec as #FileNum for-reading record={MAX_BUF_SIZE}:vary status=#RtnCd
   end-if
   if (#RtnCd)
      if (#_AbortOnFileOpenErr)
         let $Msg = 'Error: '
      else
         let $Msg = 'Warning: '
      end-if
      let $Msg = $Msg || 'Unable to open file ' || $FileSpec || ' (ErrorCode=' || to_char(#RtnCd) || ')'
      display $Msg
      if (#_AbortOnFileOpenErr)
         stop
      else
         let #FileNum = 0
         put '' 0 0 into FileHandles(#FilePtr)
      end-if
   end-if

   let #_OpenForWriting = 0

end-procedure

!******************************************************************************
begin-procedure Open-File-For-Writing ($FileSpec, #RecSize, :#FileNum)
!
!Inputs...
!  $FileSpec:   The FileSpec to be opened in WRITE-ONLY mode.
!  #RecSize:    The maximum record-size that will be written to the file.
!               Note: At this time we cannot dynamically specify RecSize so this
!               parameter is never used.
!
!Outputs...
!  #FileNum:    A handle to the opened file - must be passed by the application
!               to all subsequent file management routines.
!******************************************************************************

   let #_OpenForWriting = 1
   do Open-File ($FileSpec, #RecSize, #FileNum)

end-procedure

!******************************************************************************
begin-procedure Close-File (:#FileNum)
!
!Inputs...
!  #FileNum:    The handle to an open file.
!
!Outputs...
!  #FileNum:    The handle will be reset to zero to indicate no longer valid.
!******************************************************************************

   do Validate-File-Handle (#FileNum)
   close #FileNum
   let #FilePtr = #FileNum - {FILENO_BASE}
   put '' 0 0 0 into FileHandles(#FilePtr)
   let #FileNum = 0

end-procedure

!******************************************************************************
begin-procedure Close-All-Files
!******************************************************************************

   let #FilePtr = 0
   while (#FilePtr < {MAX_FILE_HANDLES})
      get $Test from FileHandles(#FilePtr) FileSpec
      if Not IsBlank($Test)
         let #FileNum = #FilePtr + {FILENO_BASE}
         close #FileNum
         put '' 0 0 0 into FileHandles(#FilePtr)
      end-if
      let #FilePtr = #FilePtr + 1
   end-while

end-procedure

!******************************************************************************
begin-procedure Read-Line (#FileNum, :$Str, :#EOF)
!
!Inputs...
!  #FileNum:    The handle to an open file.
!
!Outputs...
!  $Str:        The line read from the file.
!  #EOF:        Will be zero (false) if more data exists, or non-zero (true) if
!               the end of the file was reached.
!******************************************************************************

   !Get data for specified file handle...
   do Validate-File-Handle (#FileNum)
   let #FilePtr = #FileNum - {FILENO_BASE}
   get $FileSpec #RecSize #IsWriteable #EOF From FileHandles(#FilePtr)

   if (#IsWriteable)
      let $Msg = 'Error: File ' || $FileSpec || ' was opened for writing, not reading.'
      display $Msg
      stop
   end-if

   let $Str = ''

   while (Not #EOF)

      let $Str = ''
      !At this time cannot dynamically pass RecSize
      !read #FileNum into $Str:#RecSize status=#RtnCd
      read #FileNum into $Str:{MAX_BUF_SIZE} status=#RtnCd
      if (#RtnCd)
         let $Msg = 'Error reading file ' || $FileSpec || ' (ErrorCode=' || to_char(#RtnCd) || ')'
         display $Msg
         stop
      end-if

      if (#_end-file)
         let #EOF = 1
         break
      end-if

      if Not IsBlank($Str)
         break
      end-if

   end-while

   put #EOF Into FileHandles(#FilePtr) EOF

end-procedure

!******************************************************************************
begin-procedure Write-Line (#FileNum, $Str)
!
!Inputs...
!  #FileNum:    The handle to an open file.
!  $Str:        The line to be written to the file.
!******************************************************************************

   !Get data for specified file handle...
   do Validate-File-Handle (#FileNum)
   let #FilePtr = #FileNum - {FILENO_BASE}
   get $FileSpec #IsWriteable From FileHandles(#FilePtr) FileSpec Writeable

   if (Not #IsWriteable)
      let $Msg = 'Error: File ' || $FileSpec || ' was not opened for writing.'
      display $Msg
      stop
   end-if

   write #FileNum from $Str status=#RtnCd
   if (#RtnCd)
      let $Msg = 'Error writing file ' || $FileSpec || ' (ErrorCode=' || to_char(#RtnCd) || ')'
      display $Msg
      stop
   end-if

end-procedure

!==============================================================================
! Private Routines not intended for direct application use.
!==============================================================================

begin-procedure Validate-File-Handle (#FileNum)

   let #FilePtr = #FileNum - {FILENO_BASE}
   if (#FilePtr < 0) Or (#FilePtr >= {MAX_FILE_HANDLES})
      let $Msg = 'Error: Invalid file-handle ' || to_char(#FileNum) || '.'
      display $Msg
      stop
   end-if

   get $Test from FileHandles(#FilePtr) FileSpec
   if IsBlank($Test)
      let $Msg = 'Error: Attempt to use unassigned file-handle ' || to_char(#FileNum) || '.'
      display $Msg
      stop
   end-if

end-procedure

begin-procedure Find-Available-File-Handle (:#FileNum)

   let #FilePtr = 0
   while (#FilePtr < {MAX_FILE_HANDLES})
      get $Test from FileHandles(#FilePtr) FileSpec
      if IsBlank($Test)
         break
      end-if
      let #FilePtr = #FilePtr + 1
   end-while

   if (#FilePtr >= {MAX_FILE_HANDLES})
      let $Msg = 'Error: Maximum number of open files (' || to_char({MAX_FILE_HANDLES}) || ') exceeded.'
      display $Msg
      stop
   end-if

   let #FileNum = #FilePtr + {FILENO_BASE}

end-procedure

#end-if

#ifdef USE_STACK_LIB

!******************************************************************************
!                        Stack Management Routines
!******************************************************************************

!******************************************************************************
begin-procedure Init-Stack-Lib(#UniqueValues)
!
!Must be called before any other Stack routines are called to establish the
!global management variables and create the array.
!
!Inputs
! #UniqueValues:  Pass 1 to only place unique values onto the stack (duplicate
!                 values will be ignored/discarded)(only applies to first String
!                 value), or 0 to accept all values onto the stack.
!
!******************************************************************************

!#define STACK_SIZE   1000

   let #_StackPtr = 0
   let #_StackUnique = #UniqueValues

   create-array name=Stack size={STACK_SIZE}
   field=StackKey:char
   field=StackStr2:char
   field=StackStr3:char
   field=StackNum1:number
   field=StackNum2:number
   field=StackNum3:number

end-procedure

!******************************************************************************
begin-procedure ClearStack
!
!Clears the stack by resetting the "top-of-stack" pointer to zero.
!
!******************************************************************************

   let #StackPtr = 0
   clear-array Name=Stack

end-procedure

!******************************************************************************
begin-procedure Push($Key)
!
!Inputs
! $Str:  String Value(s) to be placed onto the stack.
!
!******************************************************************************

   do Push3($Key, '', '', 0, 0, 0)

end-procedure

!******************************************************************************
begin-procedure Push1($Key, #Num1)
!
!Inputs
! $Key:   String Value(s) to be placed onto the stack.
! #Num9:  Numeric Value(s) to be placed onto the stack.
!
!******************************************************************************

   do Push3($Key, '', '', #Num1, 0, 0)

end-procedure

!******************************************************************************
begin-procedure Push2($Key, $Str2, #Num1, #Num2)
!
!Inputs
! $Key, $Str9:  String Value(s) to be placed onto the stack.
! #Num9:        Numeric Value(s) to be placed onto the stack.
!
!******************************************************************************

   do Push3($Key, $Str2, '', #Num1, #Num2, 0)

end-procedure

!******************************************************************************
begin-procedure Push3($Key, $Str2, $Str3, #Num1, #Num2, #Num3)
!
!Inputs
! $Key, $Str9:  String Value(s) to be placed onto the stack.
! #Num9:        Numeric Value(s) to be placed onto the stack.
!
!******************************************************************************

   let #AlreadyOnStack = 0
   if (#_StackUnique)
      let #Idx = 1
      while (#Idx <= #_StackPtr)
         get $TestVal from Stack(#Idx) StackKey
         if ($TestVal = $Str1)
            let #AlreadyOnStack = 1
            break
         end-if
         let #Idx = #Idx + 1
      end-while
   end-if

   if (Not #_StackUnique) Or (Not #AlreadyOnStack)
      let #_StackPtr = #_StackPtr + 1
      if (#_StackPtr >= {STACK_SIZE})
         let $Msg = 'Error: Stack size (' || to_char({STACK_SIZE}) || ') exceeded.'
         display $Msg
         stop
      end-if
      put $Key $Str2 $Str3 #Num1 #Num2 #Num3 into Stack(#_StackPtr)
   end-if

end-procedure

!******************************************************************************
begin-procedure Pop(:$Key, :#EndOfStack)
!
!Outputs
! $Key:        String Value(s) retrieved from the stack.
! #EndOfStack: Set to TRUE if at top of the Stack
!
!******************************************************************************

   do Pop3($Key, $Dummy, $Dummy, #Dummy, #Dummy, #Dummy, #EndOfStack)

end-procedure

!******************************************************************************
begin-procedure Pop1(:$Key, :#Num1, :#EndOfStack)
!
!Outputs
! $Key:        String Value(s) retrieved from the stack.
! #Num1:       Numeric Value(s) retrieved from the stack.
! #EndOfStack: Set to TRUE if at top of the Stack
!
!******************************************************************************

   do Pop3($Key, $Dummy, $Dummy, #Num1, #Dummy, #Dummy, #EndOfStack)

end-procedure

!******************************************************************************
begin-procedure Pop2(:$Key, :$Str2, :#Num1, :#Num2, :#EndOfStack)
!
!Outputs
! $Key:        String Value(s) retrieved from the stack.
! #Num9:       Numeric Value(s) retrieved from the stack.
! #EndOfStack: Set to TRUE if at top of the Stack
!
!******************************************************************************

   do Pop3($Key, $Str2, $Dummy, #Num1, #Num2, #Dummy, #EndOfStack)

end-procedure

!******************************************************************************
begin-procedure Pop3(:$Key, :$Str2, :$Str3, :#Num1, :#Num2, :#Num3, :#EndOfStack)
!
!Outputs
! $Key, $Str9: String Value(s) retrieved from the stack.
! #Num9:       Numeric Value(s) retrieved from the stack.
! #EndOfStack: Set to TRUE if at top of the Stack
!
!******************************************************************************

   let $Key = ''
   let $Str2= ''
   let $Str3= ''
   let #Num1 = 0
   let #Num2= 0
   let #Num3= 0
   let #EndOfStack = 0

   if (#_StackPtr)
      get $Key $Str2 $Str3 #Num1 #Num2 #Num3 from Stack(#_StackPtr)
      let #_StackPtr = #_StackPtr - 1
   else
      let #EndOfStack = 1
      !let $Msg = 'Error: Attempt to access beyond top of Stack'
      !display $Msg
      !stop
   end-if

end-procedure

!******************************************************************************
begin-procedure StackCount(:#StackCount)
!
!Outputs
! #StackCount:  Number of items currently on the Stack.
!
!******************************************************************************

   let #StackCount = #_StackPtr

end-procedure

#end-if

#ifdef USE_LINKED_LIST_LIB

!******************************************************************************
!                  Double Linked-list Management Routines
!******************************************************************************

!******************************************************************************
begin-procedure Init-Link-Lists-Lib(#SortList)
!
!Must be called before any other List routines are called to establish the
!global management variables and create the array.
!
! #SortList:  Pass 1 to maintain a ordered/sorted list, or 0 to maintain an
!             unstructured list.
!
!******************************************************************************

!#define LIST_SIZE   7500

   let #_IsSortedList = #SortList
   let #_ListHead = 0
   let #_ListTail = 0
   let #_LastIdxUsed = 0

   create-array name=List size={LIST_SIZE}
   field=ListKey:char
   field=StrData1:char
   field=StrData2:char
   field=NumData1:number
   field=NumData2:number
   field=ForwardLink:number
   field=BackwardLink:number

end-procedure

!******************************************************************************
begin-procedure ClearLinkedList
!
!******************************************************************************

   clear-array Name=List
   let #ListHead = 0
   let #ListTail = 0
   let #LastIdxUsed = 0

end-procedure

!******************************************************************************
begin-procedure Top-Of-List(:#FirstLink)
!
!Outputs
! #FirstLink:   The index to the first array row.
!
!******************************************************************************

   let #FirstLink = #_ListHead

end-procedure

!******************************************************************************
begin-procedure Bottom-Of-List(:#LastLink)
!
!Outputs
! #FirstLink:   The index to the last array row.
!
!******************************************************************************

   let #LastLink = #_ListTail

end-procedure

!******************************************************************************
begin-procedure List-Count(:#Cnt)
!
!Outputs
! #Cnt:   The number of items in the list.
!
!******************************************************************************

   let #Cnt = 0
   let #Idx = #_ListHead
   while (#Idx > 0)
      get #Link from List(#Idx) ForwardLink
      let #Cnt = #Cnt + 1
      let #Idx = #Link
   end-while

end-procedure

!******************************************************************************
begin-procedure Find-Key($Key, :#Idx)
!
!Inputs
! $Key:   The key value to find in the list.
!
!Outputs
! #Idx:   The index to the array row containing the $Key, or zero (0) if the
!         key was not found.
!
!******************************************************************************

   let #Idx = #_ListHead
   while (#Idx > 0)
      get $TestKey #Link from List(#Idx) ListKey ForwardLink
      if ($TestKey = $Key)
         break
      end-if
      if (#_IsSortedList) And ($TestKey > $Key)
         let #Idx = 0
         break
      end-if
      let #Idx = #Link
   end-while

end-procedure

!******************************************************************************
begin-procedure Add-Key-To-List($Key, :#Idx)
!
!Inputs
! $Key:   The key value to add to the list.
!
!Outputs
! #Idx:   The index to the array row containing the added $Key or the current
!         $Key if the $Key already exists (duplicate Keys are not supported).
!
!******************************************************************************

   do Find-Key-Insertion-Point($Key, #KeyIdx)

   if (#KeyIdx < 0)
      let #Idx = -1 * #KeyIdx
   else
      do Allocate-Node(#Idx)
      if (#KeyIdx = 0)
         ! Append new node to list
         let #TargetLink = #_ListTail
         do Link-Node-Into-List(#Idx, #TargetLink, 'A')
      else
         ! Insert new node into list
         let #TargetLink = #KeyIdx
         do Link-Node-Into-List(#Idx, #TargetLink, 'B')
      end-if
      put $Key into List(#Idx) ListKey
   end-if

end-procedure

!******************************************************************************
begin-procedure Delete-Key-From-List($Key)
!
!Inputs
! $Key:   The key value to remove from the list.
!
!******************************************************************************

   do Find-Key($Key, #DelIdx)
   if (#DelIdx > 0)
      do Unlink-Node-From-List(#DelIdx)
   end-if

end-procedure

!******************************************************************************
begin-procedure Relocate-Node(#SrcLink, #DestLink, $Mode)
!
!Inputs
! #SrcLink:  The index to the "source" array row to be moved.
! #DestLink: The index to the "destination" array row.
! $Mode:     Flag to indicate the position of the "source" row with respect to
!            the "destination" row.  "A" indicates "source" row should be
!            moved to After "destination" row; "B" indicates "source" row
!            should be moved to Before "destination" row.
!
!******************************************************************************

   if (#_IsSortedList)
      let $Msg = 'Error: Nodes cannot be relocated in a sorted list.'
      display $Msg
      stop
   end-if

   let $ModeChar = Upper(SubStr($Mode, 1, 1))
   if ($ModeChar <> 'A') And ($ModeChar <> 'B')
      let $Msg = 'Error: Invalid Mode (' || $Mode || ') for Relocate-Node() function'
      display $Msg
      stop
   end-if

   do Unlink-Node-From-List(#SrcLink)
   if ($ModeChar = 'A')
      let #TargetLink = #DestLink
   else
      get #TargetLink from List(#DestLink) BackwardLink
   end-if
   do Link-Node-Into-List(#SrcLink, #TargetLink, 'A')

end-procedure

!==============================================================================
! Private Routines not intended for direct application use.
!==============================================================================

begin-procedure Find-Key-Insertion-Point($Key, :#Idx)

   ! #Idx < 0: Key already exists at [index]
   ! #Idx = 0: Key should be appended at tail
   ! #Idx > 0: Key should be inserted at index

   let #Idx = #_ListHead
   while (#Idx > 0)
      get $TestKey #Link from List(#Idx) ListKey ForwardLink
      if ($TestKey = $Key)
         let #Idx = -1 * #Idx
         break
      end-if
      if (#_IsSortedList) And ($TestKey > $Key)
         break
      end-if
      let #Idx = #Link
   end-while

end-procedure

begin-procedure Allocate-Node(:#NewLink)

   let #_LastIdxUsed = #_LastIdxUsed + 1
   if (#_LastIdxUsed >= {LIST_SIZE})
      let $Msg = 'Error: List array size (' || to_char({LIST_SIZE}) || ') exceeded.'
      display $Msg
      stop
   end-if
   let #NewLink = #_LastIdxUsed

end-procedure

begin-procedure Link-Node-Into-List(#SrcLink, #DestLink, $Mode)

   let $ModeChar = Upper(SubStr($Mode, 1, 1))
   if ($ModeChar <> 'A') And ($ModeChar <> 'B')
      let $Msg = 'Error: Invalid Mode (' || $Mode || ') for Add-Node-To-List() function'
      display $Msg
      stop
   end-if

   if ($ModeChar = 'A')
      let #BLink = #DestLink
      get #FLink from List(#DestLink) ForwardLink
   else
      let #FLink = #DestLink
      get #BLink from List(#DestLink) BackwardLink
   end-if

   put #FLink #BLink into List(#SrcLink) ForwardLink BackwardLink
   if (#BLink = 0)
      let #_ListHead = #SrcLink
   else
      put #SrcLink into List(#BLink) ForwardLink
   end-if
   if (#FLink = 0)
      let #_ListTail = #SrcLink
   else
      put #SrcLink into List(#FLink) BackwardLink
   end-if

end-procedure

begin-procedure Unlink-Node-From-List(#DelLink)

   ! At this time, there is no free-space management built in
   ! so unlinked nodes may be lost permanently.

   get #FLink #BLink from List(#DelLink) ForwardLink BackwardLink
   if (#BLink = 0)
      let #_ListHead = #FLink
   else
      put #FLink into List(#BLink) ForwardLink
   end-if
   if (#FLink = 0)
      let #_ListTail = #BLink
   else
      put #BLink into List(#FLink) BackwardLink
   end-if

end-procedure

#end-if

#ifdef USE_DATETIME_LIB

!******************************************************************************
! DateTime Display Routines
!******************************************************************************

!******************************************************************************
begin-procedure Display-Time($Msg)
!
!Inputs...
!  $Msg:  An optional progress message to be displayed along with the current
!         date and time.
!******************************************************************************

   let $DateTimeNow = datenow()
   let $AsOfDate = edit($DateTimeNow, 'DD-MON-YYYY')
   let $AsOfTime = edit($DateTimeNow, 'HH:MI PM')

   display ''
   if Not IsBlank($Msg)
      display $Msg      noline
   else
      display '['       noline
   end-if
   display $AsOfDate    noline
   display ', '         noline
   display $AsOfTime    noline
   if Not IsBlank($Msg)
      display ''
   else
      display ']'       noline
   end-if

end-procedure

#end-if

!*************************** End of TBLUTILS.SQC ******************************

