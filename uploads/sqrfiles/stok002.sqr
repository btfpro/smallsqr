!-----------------------------------------------------------------------
! Report Name: STOK002 - Stock Activity Summary
!-----------------------------------------------------------------------
!
! Confidentiality Information:
!
!                                                                      *
! This module contains confidential and proprietary information        *
! of Oracle; it is not to be copied, reproduced, or transmitted        *
! in any form, by any means, in whole or in part, nor is it to         *
! be used for any purpose other than that for which it is              *
! expressly provided under the applicable license agreement.           *
!                                                                      *
! Copyright (C) 2007 Oracle. All Rights Reserved.                      *
!                                                                      *
!***********************************************************************
!----------------------------------------------------------------------
!
!          $Date:  2007/04/24:13:32:34                                 !
!       $Release:  HR9                                                 !
!    $Resolution:  689716                                              !
!
!-----------------------------------------------------------------------
! Program Descr: Reports stock activity summary by employee
!-----------------------------------------------------------------------
! Prompts:      Stock_ID, Process_Group, Emplid, Insider Type, From Date,
!               Thru Date, Options and/or ESPP checkboxes.
! Tables:       ST_GRANT
!               ST_GRANT_EXER
!               ST_EXER_RELEASE
!               ST_EXER_DISPOSN
!               ST_REL_DISPOSN
!               ST_STOK002_TBL
!               ST_GRNT_REPURCH
!               ST_ESPP_PURCH
!               PERSONAL_DATA
!               PERSON_ADDROTH
!               PERSON_NAME
!               ST_ESPP_DIPOSN
! Sorts:        Process Group, Name
!-----------------------------------------------------------------------

#include 'setenv.sqc'

!-----------------------------------------------------------------------
Begin-Setup

 #include 'ptpsl177.sqc'               ! Landscape 177 Columns

End-Setup

!-----------------------------------------------------------------------
! Procedure: Begin-Program
! Descr:     Main Report procedure.
!-----------------------------------------------------------------------
Begin-Program

  do Init-Report
  do Build-Where-Clause
  do Expand-Process-Group                       !stprcgrp.sqc

 ! Build ST_STOK002_TBL
  do Select-Vesting-Info
  do Get-Shares-Exercised
  do Process-Shares-Exercised

 ! Build ST_STOK002A_TBL
  do Select-Vesting-Info-002A
  do Get-Shares-Exercised-002A
  do Get-Shares-Released-002A
  do Process-Shares-Exercised-002A

  evaluate $RC_RunType
  when = 'E'
  when = 'N'
    do Get-Employees
    break
  when = 'I'
    do Get-Insiders
    break
  when = 'P'
    do Get-Process-Groups
    break
  end-evaluate
  
  do Delete-Temp
  do Reset
  do Successful-EOJ

 show 'Process ended at:   ' $SysDateTime      !standard output info to sqr.log

End-Program

!-----------------------------------------------------------------------
! Procedure: Begin-Heading
! Descr:     Prints at the beginning of each page
!-----------------------------------------------------------------------
Begin-Heading 4

  #include 'stdhdg01.sqc'

  let #Advance = 0
  print $StockIdLbl                                        (-1,001,008)
  print $Colon                                             (  ,000,001)
  print $StockID                                           (  , +3,010)
  print $AsOfDtLbl                                         (  ,080,010)
  print ':'                                                (  ,000,001)
  print $RunDate                                           (  , +1,010)

End-Heading

  !-----------------------------------------------------------
  ! Only print the following section on the first page for
  ! each employee
  !-----------------------------------------------------------

Begin-Procedure new-page

  if $NewEmp = 'Y'
    if #Advance <> 0
       new-page
    end-if
    do Get-Personal-Data
    do Get-Insider-Info
    print $Name                                            (+3,001,040)
    print $EAddress1                                       (+1,001,035)
    add 1 to #Advance
    if $EAddress2 <> ''
       print $EAddress2                                    (+1,001,035)
       add 1 to #Advance
    end-if
    if $EAddress3 <> ''
       print $EAddress3                                    (+1,001,035)
       add 1 to #Advance
    end-if
    let $CityStZip = $ECity || ', ' || $EState || ' '
    let #Length = Length($EPostal)
    if $ECountry = 'USA'
       if #Length = 5
          let $EPostal = edit($EPostal, 'XXXXX')
       else
          let $EPostal = edit($EPostal, 'XXXXX-XXXX')
       end-if
    end-if
    let $CityStZip = $CityStZip || $EPostal
    print $CityStZip                                       (+1,001,051)
    let $CityStZip = ''
    print $ECountry                                        (+1,001,003)
    add 2 to #Advance
    let #Advance = (#Advance * -1)
    print $EmpidLbl                                        (+#Advance,050,006)
    print ':'                                              (  ,000,001)
    print $Emplid                                          (  , +1,011)
    print $PrcsGrpLbl                                      (  ,087,013)
    print ':'                                              (  ,000,001)
    print $PrcsGrp                                         (  , +1,010)
    print $InsiderLbl                                      (  ,123,007)
    print ':'                                              (  ,000,001)
    print $Insider                                         (  , +1,020)
    print $NidLbl                                          (+1,050,003)
    print ':'                                              (  ,   ,001)

    evaluate $TaxCountry
      when = 'USA'
        print $NID                                         (  , +1,011)  edit XXX-XX-XXXX
        break
      when = 'CAN'
        print $NID                                         (  , +1,013)  edit XXX-XXX-XXXXX
        break
      when-other
        print $NID                                         (  , +1,020)  !no format for other countries?
        break
    end-evaluate

    print $CompanyLbl                                      (  ,087,007)
    print ':'                                              (  ,000,001)
    print $Company                                         (  , +1,003)
    print $TaxLocnLbl                                      (+1,050,012)
    print ':'                                              (  ,000,001)
    print $TaxCode                                         (  , +1,010)
    print $PaygroupLbl                                     (  ,087,008)
    print ':'                                              (  ,   ,001)
    print $Paygroup                                        (  , +1,003)
  end-if

  let $NewEmp = 'N'

End-Procedure new-page


!-----------------------------------------------------------------------
! Procedure: Init-Report
! Descr:     Report initialization procedure.  Set titles , variables.
!            This is called from the Begin-Program procedure.
!-----------------------------------------------------------------------
Begin-Procedure Init-Report

  let $ReportID    = 'STOK002'
  let $PlanType    = 'O'   !option
  let $cur = $basecurr

  do Init-DateTime
  do Init-Number
  do Get-Current-DateTime
  do Define-Prcs-Vars
  do Get-Run-Control-Parms

  do Get-Report-Language    ! Procedure that decides the report language
                            ! and then calls 'Report-Translation' procedure
                            ! that reads the language dep. text.

  lowercase $CntdLbl
  let $Continue = '(' || $CntdLbl || ')'
 
  if $prcs_process_instance = ''
  else
    let #Instance = to_number($prcs_process_instance)
    do Get-SQR-Parms
  end-if

  let $StockID       = rtrim($RC_Stock_ID,' ')
  let $RC_Stock_Plan = rtrim($RC_Stock_Plan,' ')
  let $RC_Emplid     = rtrim($RC_Emplid,' ')
  let $RC_RunType    = rtrim($RC_RunType,' ')
  let $AsOfDate      = rtrim($RC_AsOfDate,' ')
  let $RC_PrcsGrp    = rtrim($RC_PrcsGrp,' ')
  let $RC_Insider    = rtrim($RC_Insider,' ')
  let $RC_Options    = rtrim($RC_Options,' ')
  let $RC_ESPP       = rtrim($RC_ESPP,' ')
  do Format-DateTime ($AsOfDate, $RunDate, {DEFDATE}, '', '')
  do Format-DateTime ($AsOfDate, $AsOfCmp,  {DEFCMP}, '', '')
  let $CurrentTime = datenow()
  show 'Process started at: ' $SysDateTime      !standard output info to sqr.log

End-Procedure Init-Report

!-----------------------------------------------------------------------
! Procedure: Report-Translation
! Descr:     This procedure is used to read language-dependent text from
!            the database.
!-----------------------------------------------------------------------
Begin-Procedure Report-Translation

  do Init_Report_Translation ('STOCK',$language_cd)
  do Append_Report_Translation ('STOK001')

  do Get_Field_Information ('STOCK', 'STOCK_ID',           $StockIdLbl,    #DW)
  do Get_Field_Information ('STOCK', 'EMPLID',             $EmpidLbl,      #DW)
  do Get_Field_Information ('STOCK', 'NID',                $NidLbl,        #DW)
  do Get_Field_Information ('STOCK', 'PROCESS_GRP',        $PrcsGrpLbl,    #DW)
  do Get_Field_Information ('STOCK', 'COMPANY',            $CompanyLbl,    #DW)
  do Get_Field_Information ('STOCK', 'INSIDER',            $InsiderLbl,    #DW)
  do Get_Field_Information ('STOCK', 'TOTAL',              $TotalLbl,      #DW)
  do Get_Field_Information ('STOCK', 'GRANT',              $GrantLbl,      #DW)
  do Get_Field_Information ('STOCK', 'GRANT_PRICE',        $GrntPriceLbl,  #DW)
  do Get_Field_Information ('STOCK', 'DATE',               $DateLbl,       #DW)
  do Get_Field_Information ('STOCK', 'NUMBER',             $NbrLbl,        #DW)
  do Get_Field_Information ('STOCK', 'SHARES',             $SharesLbl,     #DW)
  do Get_Field_Information ('STOCK', 'SHARES_GRANTED',     $ShrGrntLbl,    #DW)
  do Get_Field_Information ('STOCK', 'SHARES_CANCELLED',   $ShrCnclLbl,    #DW)
  do Get_Field_Information ('STOCK', 'SHARES_EXPIRED',     $ShrExprLbl,    #DW)
  do Get_Field_Information ('STOCK', 'SHARES_EXERCISED',   $ShrExerLbl,    #DW)
  do Get_Field_Information ('STOCK', 'GRANT_DT',           $GrantDtLbl,    #DW)
  do Get_Field_Information ('STOCK', 'SHARES_DISPOSED',    $ShrDispLbl,    #DW)
  do Get_Field_Information ('STOCK', 'CANCEL',             $CancelLbl,     #DW)
  do Get_Field_Information ('STOCK', 'SHARES_PURCHASED',   $ShrPurchLbl,   #DW)
  do Get_Field_Information ('STOCK', 'GRANT_FMV',          $GrantFmvLbl,   #DW)
  do Get_Field_Information ('STOCK', 'PURCHASE_PRICE',     $PurchPriceLbl, #DW)
  do Get_Field_Information ('STOCK', 'PURCHASE_FMV',       $PurchFmvLbl,   #DW)
  do Get_Field_Information ('STOCK', 'STOCK_PLAN_DESC',    $StPlanLbl,     #DW)
  do Get_Field_Information ('STOCK', 'ASOFDATE',           $AsOfDtLbl,     #DW)
  do Get_Field_Information ('STOCK', 'SHARES_RELEASED',    $ReldLbl,       #DW)
  do Get_Field_Information ('STOCK', 'SHARES_REPURCHASED', $RepdLbl,       #DW)
  do Get_Field_Information ('STOCK', 'PAYGROUP',           $PaygroupLbl,   #DW)

  do Get_Field_Information ('STOK001', 'STOK002',            $ReportTitle,   #DW)
  do Get_Field_Information ('STOK001', 'TAX_LOCATION',       $TaxLocnLbl,    #DW)
  do Get_Field_Information ('STOK001', 'OPTION',             $OptLbl,        #DW)
  do Get_Field_Information ('STOK001', 'TYPE',               $TypeLbl,       #DW)
  do Get_Field_Information ('STOK001', 'REASON',             $ReasonLbl,     #DW)
  do Get_Field_Information ('STOK001', 'PURCHASE_PERIOD',    $PurchPerLbl,   #DW)
  do Get_Field_Information ('STOK001', 'SHARES_HOLDING',     $ShrHoldLbl,    #DW)
  do Get_Field_Information ('STOK001', 'ESPP_PURCH',         $EsppPurchLbl,  #DW)
  do Get_Field_Information ('STOK001', 'REPORTING_PERSON',   $InsiderR,      #DW)
  do Get_Field_Information ('STOK001', 'OFFICER',            $InsiderO,      #DW)
  do Get_Field_Information ('STOK001', 'DIRECTOR',           $InsiderD,      #DW)
  do Get_Field_Information ('STOK001', 'COMPANY_INSIDER',    $InsiderC,      #DW)
  do Get_Field_Information ('STOK001', 'ST_BEN_OWNER',       $InsiderB,      #DW)
  do Get_Field_Information ('STOK001', 'PROXY_REPORT',       $InsiderP,      #DW)
  do Get_Field_Information ('STOK001', 'CONTINUED',          $CntdLbl,       #DW)
  do Get_Field_Information ('STOK001', 'OPT_SUMMARY',        $OptSumLbl,     #DW)
  do Get_Field_Information ('STOK001', 'OPT_CNCL_EXPR',      $OptCnclLbl,    #DW)
  do Get_Field_Information ('STOK001', 'OPT_REL_REPURCH',    $OptRelLbl,     #DW)
  do Get_Field_Information ('STOK001', 'SHARES_VESTED',      $VestLbl,       #DW)
  do Get_Field_Information ('STOK001', 'SHARES_UNVESTED',    $UnvestLbl,     #DW)
  do Get_Field_Information ('STOK001', 'SHARES_EXERABLE',    $ExerableLbl,   #DW)
  do Get_Field_Information ('STOK001', 'SHARES_REPABLE',     $RepableLbl,    #DW)
  do Get_Field_Information ('STOK001', 'SHARES_RELABLE',     $RelableLbl,    #DW)

End-Procedure Report-Translation

!-----------------------------------------------------------------------
! Section: Build-Where-Clause
! Descr:   Constructs portion of where clauses, used in retrieving the data.
!-----------------------------------------------------------------------
Begin-Procedure Build-Where-Clause

  let $SQLQuote      = ''''
  let $WhereInsider  = ''

  if $RC_RunType = 'P'
    if $RC_PrcsGrp <> '' 
      let $WherePrcsGrp    = ' and B.PROCESS_GROUP  = ' || $SQLQuote || $RC_PrcsGrp || $SQLQuote
    else
      let $WherePrcsGrp    = ''
    end-if
  end-if

  if $RC_RunType = 'E'
    if $RC_Emplid <> ''
      let $WhereEmplid     = ' and AAA.EMPLID = ' || $SQLQuote || $RC_Emplid || $SQLQuote
    else
      let $WhereEmplid     = ''
    end-if
  end-if

  if $RC_RunType = 'I'
    evaluate $RC_Insider
      when = 'R'
        let $WhereInsider = ' and BB.REPORTING_PERSON = ''Y'''
        break
      when = 'O'
        let $WhereInsider = ' and BB.ST_OFFICER = ''Y'''
        break
      when = 'D'
        let $WhereInsider = ' and BB.ST_DIRECTOR = ''Y'''
        break
      when = 'I'
        let $WhereInsider = ' and BB.COMPANY_INSIDER = ''Y'''
        break
      when = 'B'
        let $WhereInsider = ' and BB.ST_BEN_OWNER = ''Y'''
        break
      when = 'P'
        let $WhereInsider = ' and BB.PROXY_REPORT = ''Y'''
        break
      when-other
        let $WhereInsider = ''
        break
    end-evaluate
  end-if

End-Procedure

!-----------------------------------------------------------------------
! Section: Select-Vesting-Info
! Descr:   Selects values to insert into ST_STOK002_TBL.
!-----------------------------------------------------------------------
Begin-Procedure Select-Vesting-Info

Begin-Select
XA.EMPLID
XA.STOCK_ID
XA.STOCK_PLAN
XA.GRANT_NBR
XB.VEST_DT
XA.GRANT_PRICE
XB.SHARES_VESTED
XB.EXPIRATN_DT
XB.TERM_EXPIRATN_DT
XA.ST_CANCEL_REASON
XA.ST_CANCEL_DT
XA.VEST_SUSPEND_DT
XA.EXERCISE_HOLD_DT

  let $MSCancelDt  = rtrim(&xa.st_cancel_dt,' ')
  let $MSTermExpDt = rtrim(&xb.term_expiratn_dt,' ')
  let $MSVestSusDt = rtrim(&xa.vest_suspend_dt,' ')
  let $MSExerHldDt = rtrim(&xa.exercise_hold_dt,' ')
  do Insert-Vesting-Info

from PS_ST_GRANT        XA,
     PS_ST_GRNT_VST_DTL XB
where XA.GRANT_STATUS = 'A'
  and XA.EMPLID     = XB.EMPLID
  and XA.STOCK_ID   = XB.STOCK_ID
  and XA.GRANT_NBR  = XB.GRANT_NBR
  and XB.VEST_EFFDT = (select MAX(VEST_EFFDT)
                        from PS_ST_GRNT_VST_DTL
                       where EMPLID       = XB.EMPLID
                          and STOCK_ID    = XB.STOCK_ID
                          and GRANT_NBR   = XB.GRANT_NBR
                          and VEST_EFFDT <= $AsOfDate
  and XB.SEQ_NUM    = (select MAX(SEQ_NUM)
                        from PS_ST_GRNT_VST_DTL
                       where EMPLID     = XB.EMPLID
                         and STOCK_ID   = XB.STOCK_ID
                         and GRANT_NBR  = XB.GRANT_NBR
                         and VEST_EFFDT = XB.VEST_EFFDT ))
  and XA.STOCK_ID   = $StockID
End-Select

End-Procedure Select-Vesting-Info

!-----------------------------------------------------------------------
! Section: Insert-Vesting-Info
! Descr:   Inserts vesting info into a temp table as the first step in creating
!          the vesting schedule.  CurrentTime and Instance are used to 
!          eliminate the chance of data being accessed by two different runs
!          of the report at the same time.
!-----------------------------------------------------------------------
Begin-Procedure Insert-Vesting-Info

 let $Procedure = 'Insert-Vesting-Temp'
 let $SQL-Statement = 'Procedure: ' || $Procedure

Begin-Sql                           on-error = SQL-Error
INSERT into PS_ST_STOK002_TBL
  
(DATETIME_STAMP
,PROCESSINSTANCE
,EMPLID
,STOCK_ID
,STOCK_PLAN
,GRANT_NBR
,VEST_DT
,GRANT_PRICE
,SHARES_VESTED
,SHARES_EXERCISED
,EXPIRATN_DT
,TERM_EXPIRATN_DT
,VEST_SUSPEND_DT
,EXERCISE_HOLD_DT
,ST_CANCEL_REASON
,ST_CANCEL_DT)

VALUES
($CurrentTime
,#Instance
,&xa.emplid
,&xa.stock_id
,&xa.stock_plan
,&xa.grant_nbr
,&xb.vest_dt
,&xa.grant_price
,&xb.shares_vested
,0
,&xb.expiratn_dt,

! Workaround for TPRD T-MLEAN-Q54CT
#ifdef MICROSOFT
   $MSTermExpDt
  ,$MSVestSusDt
  ,$MSExerHldDt
  ,&xa.st_cancel_reason
  ,$MSCancelDt)
#else
   &xb.term_expiratn_dt
  ,&xa.vest_suspend_dt
  ,&xa.exercise_hold_dt
  ,&xa.st_cancel_reason
  ,&xa.st_cancel_dt)
#endif

End-Sql

End-Procedure Insert-Vesting-Info

!-----------------------------------------------------------------------
! Section: Get-Shares-Exercised
! Descr:   Sums all exercises for a particular emplid, stock_id, grant_nbr
!          and vest_dt. Report lumps the sum in a particular vesting date and
!          then trickles the excess down to the next higher vesting date.
!-----------------------------------------------------------------------
Begin-Procedure Get-Shares-Exercised

Begin-Select
XC.EMPLID
XC.STOCK_ID
XC.GRANT_NBR
XD.VEST_DT
SUM(XC.SHARES_EXERCISED) &SumExer

  Do Update-Shares-ExercisedA

from PS_ST_GRANT_EXER   XC,
     PS_ST_STOK002_TBL  XD
where XC.EMPLID           = XD.EMPLID
  and XC.GRANT_NBR        = XD.GRANT_NBR
  and XC.STOCK_ID         = XD.STOCK_ID
  and XC.EXERCISE_STATUS  = 'A'
  and XC.STOCK_ID         = $StockID
  and XC.EXERCISE_DT     <= $AsOfDate
  and XD.DATETIME_STAMP   = $CurrentTime
  and XD.PROCESSINSTANCE  = #Instance
  and XD.VEST_DT          = (select MIN(VEST_DT)
                             from  PS_ST_STOK002_TBL
                             where EMPLID              = XC.EMPLID
                               and GRANT_NBR           = XC.GRANT_NBR
                               and STOCK_ID            = XC.STOCK_ID
                               and STOCK_PLAN          = XC.STOCK_PLAN
                               and DATETIME_STAMP      = $CurrentTime
                               and PROCESSINSTANCE     = #Instance
                               and (XC.EXERCISE_DT     < EXPIRATN_DT
                               and (XC.EXERCISE_DT     < TERM_EXPIRATN_DT
                                or TERM_EXPIRATN_DT is null)))
GROUP BY XC.EMPLID,
         XC.STOCK_ID,
         XC.GRANT_NBR,
         XD.VEST_DT
End-Select

End-Procedure Get-Shares-Exercised

!-----------------------------------------------------------------------
! Section: Update-Shares-ExercisedA
! Descr:   Updates the temp table with the sum of shares_exercised for a given
!          emplid, stock_id, grant_nbr, and vest_dt.
!-----------------------------------------------------------------------
Begin-Procedure Update-Shares-ExercisedA

 let $Procedure = 'Update-Shares-ExercisedA'
 let $SQL-Statement = 'Procedure: ' || $Procedure

Begin-Sql                           on-error = SQL-Error
UPDATE PS_ST_STOK002_TBL
  SET SHARES_EXERCISED = &SumExer
where EMPLID          = &xc.emplid
  and STOCK_ID        = &xc.stock_id
  and GRANT_NBR       = &xc.grant_nbr
  and VEST_DT         = &xd.vest_dt
  and DATETIME_STAMP  = $CurrentTime
  and PROCESSINSTANCE = #Instance
End-Sql

End-Procedure Update-Shares-ExercisedA

!-----------------------------------------------------------------------
! Section: Process-Shares-Exercised
! Descr:   For each emplid and grant_nbr put info into array and call
!          Update-Shares-ExercisedB.
!-----------------------------------------------------------------------
Begin-Procedure Process-Shares-Exercised

  create-array name=Exer                -
                  size=500              -
                  field=VestDt:char     -
                  field=Vest:number     -
                  field=Exer:number
  let #x = 0

Begin-Select
XE.EMPLID       () on-break print=never level=1 procedure=Update-Shares-ExercisedB  save=$OldEmp
XE.STOCK_ID     
XE.STOCK_PLAN   
XE.GRANT_NBR    () on-break print=never level=1 procedure=Update-Shares-ExercisedB  save=$OldGrant
XE.VEST_DT
XE.SHARES_VESTED
XE.SHARES_EXERCISED

  put &xe.vest_dt &xe.shares_vested &xe.shares_exercised into EXER(#x) VestDt Vest Exer
  add 1 to #x
  
from PS_ST_STOK002_TBL XE
where XE.STOCK_ID        = $StockID
  and XE.DATETIME_STAMP  = $CurrentTime
  and XE.PROCESSINSTANCE = #Instance
order by 1,4,5
End-Select

 do Update-Shares-ExercisedB    !to process last on-break

End-Procedure Process-Shares-Exercised

!-----------------------------------------------------------------------
! Section: Update-Shares-ExercisedB
! Descr:   For each row in the array, check if shares exercised are greater
!          than shares vested for a particular vest date. If so, trickle down
!          the excess to the next vesting date.
!-----------------------------------------------------------------------
Begin-Procedure Update-Shares-ExercisedB

  let #TotalRow  = 0
  let #Remainder = 0
  
  while #totalRow <= #x   !to run thru all elements
    
    
    get $VestDtArray #ShrVestArray #ShrExerArray  -
         from EXER(#totalRow) VestDt Vest Exer

    let #ShareToExer = #ShrExerArray + #Remainder
    
    if #ShareToExer > #ShrVestArray
       let #UpdateExer  = #ShrVestArray
       let #Remainder   = #ShareToExer  - #ShrVestArray
       do Update-Shares-ExercisedC
    else
       if #Remainder > #ShrExerArray
          let #UpdateExer = #Remainder
          do Update-Shares-ExercisedC
          let #Remainder = 0
       end-if
    end-if

    add 1 to #totalRow
   
  end-while
  
  clear-array  name=EXER

  let #x = 0

End-Procedure Update-Shares-ExercisedB

!-----------------------------------------------------------------------
! Section: Update-Shares-ExercisedC
! Descr:   Updates the temp table.
!-----------------------------------------------------------------------
Begin-Procedure Update-Shares-ExercisedC

 let $Procedure     = 'Update-Shares-ExercisedC'
 let $SQL-Statement = 'Procedure: ' || $Procedure

Begin-Sql                           on-error = SQL-Error
UPDATE PS_ST_STOK002_TBL
  SET SHARES_EXERCISED = #UpdateExer

where EMPLID          = $OldEmp
  and STOCK_ID        = $StockID
  and GRANT_NBR       = $OldGrant
  and VEST_DT         = $VestDtArray
  and DATETIME_STAMP  = $CurrentTime
  and PROCESSINSTANCE = #Instance
End-Sql

End-Procedure Update-Shares-ExercisedC

!-----------------------------------------------------------------------
! Section: Select-Vesting-Info-002A
! Descr:   Selects values to insert into ST_STOK002A_TBL.
!-----------------------------------------------------------------------
Begin-Procedure Select-Vesting-Info-002A

Begin-Select
AXA.EMPLID
AXA.STOCK_ID
AXA.STOCK_PLAN
AXA.GRANT_NBR
AXB.VEST_DT
AXA.GRANT_PRICE
AXB.SHARES_VESTED
AXB.EXPIRATN_DT
AXB.TERM_EXPIRATN_DT
AXA.ST_CANCEL_REASON
AXA.ST_CANCEL_DT
AXA.VEST_SUSPEND_DT
AXA.EXERCISE_HOLD_DT

  let $MSCancelDt  = rtrim(&axa.st_cancel_dt,' ')
  let $MSTermExpDt = rtrim(&axb.term_expiratn_dt,' ')
  let $MSVestSusDt = rtrim(&axa.vest_suspend_dt,' ')
  let $MSExerHldDt = rtrim(&axa.exercise_hold_dt,' ')
  do Insert-Vesting-Info-002A

from PS_ST_GRANT        AXA,
     PS_ST_GRNT_VST_DTL AXB
where AXA.GRANT_STATUS = 'A'
  and AXA.EMPLID     = AXB.EMPLID
  and AXA.STOCK_ID   = AXB.STOCK_ID
  and AXA.GRANT_NBR  = AXB.GRANT_NBR
  and AXB.VEST_EFFDT = (select MAX(VEST_EFFDT)
                        from PS_ST_GRNT_VST_DTL
                       where EMPLID       = AXB.EMPLID
                          and STOCK_ID    = AXB.STOCK_ID
                          and GRANT_NBR   = AXB.GRANT_NBR
                          and VEST_EFFDT <= $AsOfDate
  and AXB.SEQ_NUM    = (select MAX(SEQ_NUM)
                        from PS_ST_GRNT_VST_DTL
                       where EMPLID     = AXB.EMPLID
                         and STOCK_ID   = AXB.STOCK_ID
                         and GRANT_NBR  = AXB.GRANT_NBR
                         and VEST_EFFDT = AXB.VEST_EFFDT ))
  and AXA.STOCK_ID   = $StockID
End-Select

End-Procedure Select-Vesting-Info-002A

!-----------------------------------------------------------------------
! Section: Insert-Vesting-Info-002A
! Descr:   Inserts vesting info into a temp table as the first step in creating
!          the vesting schedule.  CurrentTime and Instance are used to 
!          eliminate the chance of data being accessed by two different runs
!          of the report at the same time.
!-----------------------------------------------------------------------
Begin-Procedure Insert-Vesting-Info-002A

 let $Procedure = 'Insert-Vesting-Temp'
 let $SQL-Statement = 'Procedure: ' || $Procedure

Begin-Sql                           on-error = SQL-Error
INSERT into PS_ST_STOK002A_TBL
  
(DATETIME_STAMP
,PROCESSINSTANCE
,EMPLID
,STOCK_ID
,STOCK_PLAN
,GRANT_NBR
,VEST_DT
,GRANT_PRICE
,SHARES_VESTED
,SHARES_EXERCISED
,EXPIRATN_DT
,TERM_EXPIRATN_DT
,VEST_SUSPEND_DT
,EXERCISE_HOLD_DT
,ST_CANCEL_REASON
,ST_CANCEL_DT)

VALUES
($CurrentTime
,#Instance
,&axa.emplid
,&axa.stock_id
,&axa.stock_plan
,&axa.grant_nbr
,&axb.vest_dt
,&axa.grant_price
,&axb.shares_vested
,0
,&axb.expiratn_dt,

! Workaround for TPRD T-MLEAN-Q54CT
#ifdef MICROSOFT
   $MSTermExpDt
  ,$MSVestSusDt
  ,$MSExerHldDt
  ,&axa.st_cancel_reason
  ,$MSCancelDt)
#else
   &axb.term_expiratn_dt
  ,&axa.vest_suspend_dt
  ,&axa.exercise_hold_dt
  ,&axa.st_cancel_reason
  ,&axa.st_cancel_dt)
#endif

End-Sql

End-Procedure Insert-Vesting-Info-002A

!-----------------------------------------------------------------------
! Section: Get-Shares-Exercised-002A
! Descr:   Sums all restricted exercises for a particular emplid, stock_id, 
!          grant_nbr and vest_dt. Report lumps the sum in a particular vesting 
!          date and then trickles the excess down to the next higher vesting 
!          date.
!-----------------------------------------------------------------------
Begin-Procedure Get-Shares-Exercised-002A

Begin-Select
AXC.EMPLID
AXC.STOCK_ID
AXC.GRANT_NBR
AXD.VEST_DT
SUM(AXC.SHARES_EXERCISED) &SumExer002A

  do Update-Shares-Exercised-002A

from PS_ST_GRANT_EXER    AXC,
     PS_ST_STOK002A_TBL  AXD
where AXC.EMPLID              = AXD.EMPLID
  and AXC.GRANT_NBR           = AXD.GRANT_NBR
  and AXC.STOCK_ID            = AXD.STOCK_ID
  and AXC.EXERCISE_STATUS     = 'A'
  and AXC.RESTRICTD_EXERCISE  = 'N'
  and AXC.EXERCISE_DT        <= $AsOfDate
  and AXC.STOCK_ID            = $StockID
  and AXD.DATETIME_STAMP      = $CurrentTime
  and AXD.PROCESSINSTANCE     = #Instance
  and AXD.VEST_DT             = (select MIN(VEST_DT)
                                 from  PS_ST_STOK002A_TBL
                                 where EMPLID              = AXC.EMPLID
                                   and GRANT_NBR           = AXC.GRANT_NBR
                                   and STOCK_ID            = AXC.STOCK_ID
                                   and STOCK_PLAN          = AXC.STOCK_PLAN
                                   and DATETIME_STAMP      = $CurrentTime
                                   and PROCESSINSTANCE     = #Instance
                                   and AXC.EXERCISE_DT     < EXPIRATN_DT
                                   and (AXC.EXERCISE_DT    < TERM_EXPIRATN_DT
                                    or TERM_EXPIRATN_DT   is null))
GROUP BY AXC.EMPLID,
         AXC.STOCK_ID,
         AXC.GRANT_NBR,
         AXD.VEST_DT
End-Select

End-Procedure Get-Shares-Exercised-002A

!-----------------------------------------------------------------------
! Section: Get-Shares-Released-002A
! Descr:   Sums all exercises for a particular emplid, stock_id, grant_nbr
!          and vest_dt. Report lumps the sum in a particular vesting date and
!          then trickles the excess down to the next higher vesting date.
!-----------------------------------------------------------------------
Begin-Procedure Get-Shares-Released-002A

Begin-Select
AZC.EMPLID
AZC.STOCK_ID
AZC.GRANT_NBR
AZD.VEST_DT
SUM(AZC.SHARES_RELEASED) &SumRel002A

 do Update-Shares-Released-002A

from PS_ST_EXER_RELEASE  AZC,
     PS_ST_STOK002A_TBL  AZD
where AZC.EMPLID           = AZD.EMPLID
  and AZC.GRANT_NBR        = AZD.GRANT_NBR
  and AZC.STOCK_ID         = AZD.STOCK_ID
  and AZC.RELEASE_STATUS   = 'A'
  and AZC.RELEASE_DT      <= $AsOfDate
  and AZC.STOCK_ID         = $StockID
  and AZD.DATETIME_STAMP   = $CurrentTime
  and AZD.PROCESSINSTANCE  = #Instance
  and AZD.VEST_DT          = (select MIN(VEST_DT)
                              from  PS_ST_STOK002A_TBL
                              where EMPLID              = AZC.EMPLID
                                and GRANT_NBR           = AZC.GRANT_NBR
                                and STOCK_ID            = AZC.STOCK_ID
                                and DATETIME_STAMP      = $CurrentTime
                                and PROCESSINSTANCE     = #Instance
                                and (AZC.RELEASE_DT     < EXPIRATN_DT
                                and (AZC.RELEASE_DT     < TERM_EXPIRATN_DT
                                or  TERM_EXPIRATN_DT   is null)))
GROUP BY AZC.EMPLID,
         AZC.STOCK_ID,
         AZC.GRANT_NBR,
         AZD.VEST_DT
End-Select

End-Procedure Get-Shares-Exercised-002A

!-----------------------------------------------------------------------
! Section: Update-Shares-Exercised-002A
! Descr:   Updates the temp table with the sum of shares_exercised for a given
!          emplid, stock_id, grant_nbr, and vest_dt.
!-----------------------------------------------------------------------
Begin-Procedure Update-Shares-Exercised-002A

 let $Procedure = 'Update-Shares-Exercised-002A'
 let $SQL-Statement = 'Procedure: ' || $Procedure

Begin-Sql                           on-error = SQL-Error
UPDATE PS_ST_STOK002A_TBL
  SET SHARES_EXERCISED = &SumExer002A

where EMPLID          = &axc.emplid
  and STOCK_ID        = &axc.stock_id
  and GRANT_NBR       = &axc.grant_nbr
  and VEST_DT         = &axd.vest_dt
  and DATETIME_STAMP  = $CurrentTime
  and PROCESSINSTANCE = #Instance
End-Sql

End-Procedure Update-Shares-Exercised-002A

!-----------------------------------------------------------------------
! Section: Update-Shares-Released-002A
! Descr:   Updates the temp table with the sum of shares_released for a given
!          emplid, stock_id, grant_nbr, and vest_dt.
!-----------------------------------------------------------------------
Begin-Procedure Update-Shares-Released-002A

 let $Procedure = 'Update-Shares-Released-002A'
 let $SQL-Statement = 'Procedure: ' || $Procedure

Begin-Sql                           on-error = SQL-Error
UPDATE PS_ST_STOK002A_TBL
  SET SHARES_EXERCISED = (SHARES_EXERCISED + &SumRel002A)

where EMPLID          = &azc.emplid
  and STOCK_ID        = &azc.stock_id
  and GRANT_NBR       = &azc.grant_nbr
  and VEST_DT         = &azd.vest_dt
  and DATETIME_STAMP  = $CurrentTime
  and PROCESSINSTANCE = #Instance
End-Sql

End-Procedure Update-Shares-Released-002A

!-----------------------------------------------------------------------
! Section: Process-Shares-Exercised-002A
! Descr:   For each emplid and grant_nbr put info into array and call
!          Update-Shares-ExercisedB.
!-----------------------------------------------------------------------
Begin-Procedure Process-Shares-Exercised-002A

 create-array name=Exer002A            -
                 size=500              -
                 field=VestDt:char     -
                 field=Vest:number     -
                 field=Exer:number
 let #x = 0

Begin-Select
AXE.EMPLID       () on-break print=never level=1 procedure=Update-Shares-Exercised-002B  save=$OldEmp
AXE.STOCK_ID     
AXE.STOCK_PLAN   
AXE.GRANT_NBR    () on-break print=never level=1 procedure=Update-Shares-Exercised-002B  save=$OldGrant
AXE.VEST_DT
AXE.SHARES_VESTED
AXE.SHARES_EXERCISED

  put &axe.vest_dt &axe.shares_vested &axe.shares_exercised into EXER002A(#x) VestDt Vest Exer
  add 1 to #x
  
from PS_ST_STOK002A_TBL AXE
where AXE.STOCK_ID        = $StockID
  and AXE.DATETIME_STAMP  = $CurrentTime
  and AXE.PROCESSINSTANCE = #Instance
order by 1,4,5
End-Select

 do Update-Shares-Exercised-002B    !to process last on-break

End-Procedure Process-Shares-Exercised-002A

!-----------------------------------------------------------------------
! Section: Update-Shares-Exercised-002B
! Descr:   For each row in the array, check if shares exercised are greater
!          than shares vested for a particular vest date. If so, trickle down
!          the excess to the next vesting date.
!-----------------------------------------------------------------------
Begin-Procedure Update-Shares-Exercised-002B

  let #TotalRow  = 0
  let #Remainder = 0
  
  while #totalRow <= #x   !to run thru all elements
    
    
    get $VestDtArray #ShrVestArray #ShrExerArray  -
         from EXER002A(#totalRow) VestDt Vest Exer

    let #ShareToExer = #ShrExerArray + #Remainder
    
    if #ShareToExer > #ShrVestArray
       let #UpdateExer  = #ShrVestArray
       let #Remainder   = #ShareToExer  - #ShrVestArray
       do  Update-Shares-Exercised-002C
    else
       if #Remainder > #ShrExerArray
          let #UpdateExer = #Remainder
          do  Update-Shares-Exercised-002C
          let #Remainder = 0
       end-if
    end-if

    add 1 to #totalRow
   
  end-while
  
  clear-array  name=EXER002A

  let #x = 0

End-Procedure Update-Shares-Exercised-002B

!-----------------------------------------------------------------------
! Section: Update-Shares-Exercised-002C
! Descr:   Updates the temp table.
!-----------------------------------------------------------------------
Begin-Procedure Update-Shares-Exercised-002C

 let $Procedure     = 'Update-Shares-Exercised-002C'
 let $SQL-Statement = 'Procedure: ' || $Procedure

Begin-Sql                           on-error = SQL-Error
UPDATE PS_ST_STOK002A_TBL
  SET SHARES_EXERCISED = #UpdateExer

where EMPLID          = $OldEmp
  and STOCK_ID        = $StockID
  and GRANT_NBR       = $OldGrant
  and VEST_DT         = $VestDtArray
  and DATETIME_STAMP  = $CurrentTime
  and PROCESSINSTANCE = #Instance
End-Sql

End-Procedure Update-Shares-Exercised-002C

!-----------------------------------------------------------------------
! Section: Get-Process-Groups
! Descr:   Retrieves employees and checks for any stock activity.
!-----------------------------------------------------------------------
Begin-Procedure Get-Process-Groups

  do Define-PrimJob-Clause('A',$AsOfDate, $PRIM_JOB_CLAUSE)     ! getprimj.sqc

Begin-Select

A.EMPLID
A.TAX_LOCATION_CD
A.COMPANY
A.PAYGROUP
B.PROCESS_GROUP

  let #LastPageCount = #page-count
  let $NewEmp        = 'Y'
  let $Print         = 'N'
  let $Emplid        = rtrim(&a.emplid, ' ')
  let $TaxCode       = rtrim(&a.tax_location_cd, ' ')
  let $Company       = rtrim(&a.company, ' ')
  let $Paygroup      = rtrim(&a.paygroup, ' ')
  let $PrcsGrp       = rtrim(&b.process_group, ' ')

 !------------------------------------------------------------
 !Specified at run time to retrieve options and/or ESPP info
 !------------------------------------------------------------
  if $RC_Options = 'Y'
    do Get-Grants
    do Process-CancelExpire
    do Process-ReleaseRepurch
  end-if

  if $RC_ESPP = 'Y'
    do Get-ESPP-Purchases
  end-if

from PS_JOB            A,
     PS_R_PRCS_GRP_DTL B
where A.EFFDT      = (select MAX(EFFDT) from PS_JOB
                       where EMPLID    = A.EMPLID
                         and EMPL_RCD  = A.EMPL_RCD
                         and EFFDT    <= $AsOfDate)
  and A.EMPL_RCD   = [$PRIM_JOB_CLAUSE]
  and A.EFFSEQ     = (select MAX(EFFSEQ) from PS_JOB
                       where EMPLID    = A.EMPLID
                         and EMPL_RCD  = A.EMPL_RCD
                         and EFFDT     = A.EFFDT)
  and B.COMPANY    = A.COMPANY
  and B.PAYGROUP   = A.PAYGROUP
  and B.REPORT_ID  = $ReportID
  [$WherePrcsGrp]
order by A.EMPLID

End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Insiders
! Descr:   Retrieves insiders only and checks for any stock activity.
!-----------------------------------------------------------------------
Begin-Procedure Get-Insiders

 do Define-PrimJob-Clause('AA',$AsOfDate, $PRIM_JOB_CLAUSE)     ! getprimj.sqc

Begin-Select

AA.EMPLID
AA.TAX_LOCATION_CD
AA.COMPANY
AA.PAYGROUP

  let #LastPageCount = #page-count
  let $NewEmp        = 'Y'
  let $Print         = 'N'
  let $Emplid        = rtrim(&aa.emplid, ' ')
  let $TaxCode       = rtrim(&aa.tax_location_cd, ' ')
  let $Company       = rtrim(&aa.company, ' ')
  let $Paygroup      = rtrim(&aa.paygroup, ' ')
  let $PrcsGrp       = ''

  if $RC_Options = 'Y'
    do Get-Grants
    do Process-CancelExpire
    do Process-ReleaseRepurch
  end-if

  if $RC_ESPP = 'Y'
    do Get-ESPP-Purchases
  end-if

from PS_JOB            AA,
     PS_ST_INSIDER_TBL BB
where AA.EFFDT     = (select MAX(EFFDT) from PS_JOB
                       where EMPLID   = AA.EMPLID
                         and EMPL_RCD = AA.EMPL_RCD
                         and EFFDT   <= $AsOfDate)
  and AA.EMPL_RCD  = [$PRIM_JOB_CLAUSE]
  and AA.EFFSEQ    = (select MAX(EFFSEQ) from PS_JOB
                       where EMPLID   = AA.EMPLID
                         and EMPL_RCD = AA.EMPL_RCD
                         and EFFDT    = AA.EFFDT)
  and BB.EMPLID    = AA.EMPLID
  and BB.STOCK_ID  = $StockID
  and BB.EFFDT     = (select MAX(EFFDT) from PS_ST_INSIDER_TBL
                       where EMPLID   = BB.EMPLID
                         and STOCK_ID = BB.STOCK_ID
                         and EFFDT   <= $AsOfDate)
  [$WhereInsider]
order by AA.EMPLID

End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Employees
! Descr:   Retrieves employees only and checks for any stock activity.
!-----------------------------------------------------------------------
Begin-Procedure Get-Employees

 do Define-PrimJob-Clause('AAA',$AsOfDate, $PRIM_JOB_CLAUSE)

Begin-Select

AAA.EMPLID
AAA.TAX_LOCATION_CD
AAA.COMPANY
AAA.PAYGROUP

  let #LastPageCount = #page-count
  let $NewEmp        = 'Y'
  let $Print         = 'N'
  let $Emplid        = rtrim(&aaa.emplid, ' ')
  let $TaxCode       = rtrim(&aaa.tax_location_cd, ' ')
  let $Company       = rtrim(&aaa.company, ' ')
  let $Paygroup      = rtrim(&aaa.paygroup, ' ')
  let $PrcsGrp       = ''

  if $RC_Options = 'Y'
    do Get-Grants
    do Process-CancelExpire
    do Process-ReleaseRepurch
  end-if
  if $RC_ESPP = 'Y'
    do Get-ESPP-Purchases
  end-if

from PS_JOB AAA
where AAA.EFFDT    = (select MAX(EFFDT)
                        from PS_JOB
                       where EMPLID   = AAA.EMPLID
                         and EMPL_RCD = AAA.EMPL_RCD
                         and EFFDT   <= $AsOfDate)
  and AAA.EMPL_RCD = [$PRIM_JOB_CLAUSE]
  and AAA.EFFSEQ   = (select MAX(EFFSEQ)
                        from PS_JOB
                       where EMPLID   = AAA.EMPLID
                         and EMPL_RCD = AAA.EMPL_RCD
                         and EFFDT    = AAA.EFFDT)
  [$WhereEmplid]
order by AAA.EMPLID

End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Grants
! Descr:   Retrieves any grant information for an employee and date range.
!-----------------------------------------------------------------------
Begin-Procedure Get-Grants

  let $Header      = 'N'
  let #Unvest      = 0
  let #TotGrant    = 0
  let #TotVest     = 0
  let #TotUnVest   = 0
  let #TotExer     = 0
  let #TotExerable = 0
  let #Row         = 0

Begin-Select
C.GRANT_DT
C.GRANT_NBR
C.SHARES_GRANTED
C.GRANT_PRICE
C.ST_OPTION_TYPE
C.EXER_BFR_VEST
C.EXER_SUSPND_BGN_DT
C.EXER_SUSPND_END_DT
C.ST_CANCEL_REASON
C.ST_CANCEL_DT

  let $GrantNbr    = rtrim(&c.grant_nbr,' ')
  let $ExerBfrVest = rtrim(&c.exer_bfr_vest, ' ')
  let $FieldName   = 'ST_OPTION_TYPE'
  let $FieldValue  = rtrim(&c.st_option_type, ' ')
  do Read-Translate-Table
  let $OptionType  = $XlatShortName
  do Format-DateTime (&c.exer_suspnd_bgn_dt, $BgnDtCmp,  {DEFCMP}, '', '')
  do Format-DateTime (&c.exer_suspnd_end_dt, $EndDtCmp,  {DEFCMP}, '', '')
  do Format-DateTime (&c.grant_dt, $GrantDt, {DEFDATE}, '', '')

  if $Header = 'N'
    let $Print = 'Y'

    do new-page            !separate page for each employee
    print $OptSumLbl                                       (+3,001,020) bold
    print ':'                                              (  ,   ,001) bold
    print $GrantLbl                                        (+1,017,05)
    print $OptLbl                                          (  ,037,010)
    print $GrantDtLbl                                      (+1,001,010) underline
    print $NbrLbl                                          (  ,016,006) underline
    print $GrntPriceLbl                                    (  ,024,011) underline
    print $TypeLbl                                         (  ,037,010) underline
    print $ShrGrntLbl                                      (  ,057,014) underline
    print $VestLbl                                         (  ,082,013) underline
    print $UnvestLbl                                       (  ,104,015) underline
    print $ShrExerLbl                                      (  ,127,016) underline
    print $ExerableLbl                                     (  ,149,019) underline
 end-if

  do Get-Exercised
  do Get-Vested
  do Get-Unvested

  if $ExerBfrVest = 'Y'
    do Get-Repurch2
  end-if

  if $AsOfCmp < $BgnDtCmp
    or $AsOfCmp > $EndDtCmp
    if $ExerBfrVest = 'Y'
      do Get-Exerciseable1
      do Get-Exerciseable2
      if #Exerable1 < #Exerable2
        let #Exerable = #Exerable1
      else
        let #Exerable = #Exerable2
      end-if
    else
      do Get-Exerciseable2
      do Get-Exerciseable3
      if #Exerable2 < #Exerable3
        let #Exerable = #Exerable2
      else
        let #Exerable = #Exerable3
      end-if
    end-if
    if #Exerable < 0
      let #Exerable  = 0
    end-if
  else
    let #Exerable  = 0
    let #Exerable1 = 0
    let #Exerable2 = 0
    let #Exerable3 = 0
  end-if

  print $GrantDt                                           (+1,001,010)
  print $GrantNbr                                          (  ,012,010)
  print &c.grant_price                                     (  ,024,011) edit 9999.999999
  print $OptionType                                        (  ,037,010)
  print &c.shares_granted                                  (  ,049,022) edit 999,999,999,999.999999
  print #Vested                                            (  ,073,022) edit 999,999,999,999.999999
  print #Unvested                                          (  ,097,022) edit 999,999,999,999.999999
  print #Exer                                              (  ,121,022) edit 999,999,999,999.999999
  print #Exerable                                          (  ,145,022) edit 999,999,999,999.999999
  add &c.shares_granted to #TotGrant
  add #Vested           to #TotVest
  add #Unvested         to #TotUnvest
  add #Exer             to #TotExer 
  add #Exerable         to #TotExerable

  let $Header    = 'Y'
  add 1 to #Row

from PS_ST_GRANT C
where C.GRANT_STATUS = 'A'
  and C.EMPLID       = $Emplid
  and C.GRANT_DT    <= $AsOfDate
  and C.STOCK_ID     = $StockId
order by C.GRANT_DT, C.GRANT_NBR
End-Select

 !--------------------------------------------------
 ! Prints totals if there is more than 1 detail row
 !--------------------------------------------------
  if #Row > 1
    print '_'                                              (+1,049,022) fill
    print '_'                                              (  ,073,022) fill
    print '_'                                              (  ,097,022) fill
    print '_'                                              (  ,121,022) fill
    print '_'                                              (  ,145,022) fill
    print $TotalLbl                                        (+1,001,010)
    print #TotGrant                                        (  ,049,022) edit 999,999,999,999.999999
    print #TotVest                                         (  ,073,022) edit 999,999,999,999.999999
    print #TotUnvest                                       (  ,097,022) edit 999,999,999,999.999999
    print #TotExer                                         (  ,121,022) edit 999,999,999,999.999999
    print #TotExerable                                     (  ,145,022) edit 999,999,999,999.999999
  end-if

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Vested
! Descr:   Retrieves all vested shares for a particular grant number.
!-----------------------------------------------------------------------
Begin-Procedure Get-Vested

  let #Vested = 0

Begin-Select
SUM(D.SHARES_VESTED) &Vested

  do Get-VestCancellations
  do Get-VestExpirations
  let #Vested = &Vested - #VestCancelled - #VestExpired

from PS_ST_STOK002_TBL D, PS_ST_GRANT D1
where D.DATETIME_STAMP   = $CurrentTime
  and D.PROCESSINSTANCE  = #Instance
  and D.STOCK_ID         = $StockID
  and D.EMPLID           = $Emplid
  and D.GRANT_NBR        = $GrantNbr
  and D.STOCK_ID         = D1.STOCK_ID
  and D.EMPLID           = D1.EMPLID
  and D.GRANT_NBR        = D1.GRANT_NBR
  and (D.VEST_DT        <= D.VEST_SUSPEND_DT
   or D.VEST_SUSPEND_DT is null)
  AND (D.VEST_DT        <= $AsOfDate 
  AND (D1.EXER_BFR_VEST  = 'N' 
  OR (D1.EXER_BFR_VEST   = 'Y' 
  AND EXISTS (SELECT 'X' FROM PS_ST_GRANT_EXER F1
  WHERE F1.EMPLID        = D.EMPLID
  AND F1.STOCK_ID        = D.STOCK_ID
  AND F1.GRANT_NBR       = D.GRANT_NBR )))
  OR (D.VEST_DT IS NOT NULL 
  AND (D1.EXER_BFR_VEST  = 'Y' 
  AND NOT EXISTS (SELECT 'X' FROM PS_ST_GRANT_EXER F2
  WHERE F2.EMPLID        = D.EMPLID
  AND F2.STOCK_ID        = D.STOCK_ID
  AND F2.GRANT_NBR       = D.GRANT_NBR ))))
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-UnVested
! Descr:   Retrieves all unvested shares for a particular grant number.
!-----------------------------------------------------------------------
Begin-Procedure Get-UnVested

  let #UnVested = 0

Begin-Select
SUM(DD.SHARES_VESTED) &Unvested

  do Get-UnvestCancellations
  let #UnVested = &Unvested - #UnvestCancelled

  if  #Unvested < 0
      let #Unvested = 0
  end-if

from PS_ST_STOK002_TBL DD, PS_ST_GRANT ED
where DD.DATETIME_STAMP  = $CurrentTime
  and DD.PROCESSINSTANCE = #Instance
  and DD.STOCK_ID        = $StockID
  and DD.EMPLID          = $Emplid
  and DD.GRANT_NBR       = $GrantNbr
  and DD.STOCK_ID        = ED.STOCK_ID
  and DD.EMPLID          = ED.EMPLID
  and DD.GRANT_NBR       = ED.GRANT_NBR
  AND ((DD.VEST_DT       > $AsOfDate 
  AND (ED.EXER_BFR_VEST  = 'N' 
  OR (ED.EXER_BFR_VEST   = 'Y' 
  AND EXISTS (SELECT 'X' FROM PS_ST_GRANT_EXER FD
  WHERE ED.EMPLID        = FD.EMPLID
  AND ED.STOCK_ID        = FD.STOCK_ID
  AND ED.GRANT_NBR       = FD.GRANT_NBR ))))
  or (DD.VEST_DT        <= $AsOfDate
  and DD.VEST_DT         > DD.VEST_SUSPEND_DT))
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-VestCancellations
! Descr:   Retrieves any cancelled shares for an employee, given a date range.
!          Union is used to retrieve b/c there is different criteria for cancel
!          due to reprice or not reprice.  For computing vested shares.
!-----------------------------------------------------------------------
Begin-Procedure Get-VestCancellations

  let #VestCancelled = 0

Begin-Select
SUM(G2.SHARES_VESTED - G2.SHARES_EXERCISED) &VestCancel

  let #VestCancelled = &VestCancel + #VestCancelled

from PS_ST_STOK002_TBL  G2
where G2.DATETIME_STAMP     = $CurrentTime
  and G2.PROCESSINSTANCE    = #Instance
  and G2.STOCK_ID           = $StockID
  and G2.ST_CANCEL_REASON   = 'TER'
  and G2.ST_CANCEL_DT      <= G2.VEST_DT
  and G2.GRANT_NBR          = $GrantNbr
  and G2.EMPLID             = $Emplid
  and G2.ST_CANCEL_DT      <= $AsOfDate
  and G2.VEST_DT           <= $AsOfDate
  and (G2.VEST_DT          <= G2.VEST_SUSPEND_DT
   or G2.VEST_SUSPEND_DT is null)

UNION

select
  SUM(G2.SHARES_VESTED - G2.SHARES_EXERCISED)
from PS_ST_STOK002_TBL  G2
where G2.DATETIME_STAMP     = $CurrentTime
  and G2.PROCESSINSTANCE    = #Instance
  and G2.STOCK_ID           = $StockID
  and (G2.ST_CANCEL_REASON  = 'RPRC'
   or G2.ST_CANCEL_REASON   = 'RESC')
  and G2.ST_CANCEL_DT       < G2.EXPIRATN_DT
  and (G2.ST_CANCEL_DT      < G2.TERM_EXPIRATN_DT
   or G2.TERM_EXPIRATN_DT  is null)
  and G2.GRANT_NBR          = $GrantNbr
  and G2.EMPLID             = $Emplid
  and G2.ST_CANCEL_DT      <= $AsOfDate
  and G2.VEST_DT           <= $AsOfDate
  and (G2.VEST_DT          <= G2.VEST_SUSPEND_DT
   or G2.VEST_SUSPEND_DT is null)

End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-UnvestCancellations
! Descr:   Retrieves any cancelled shares for an employee, given a date range.
!          Union is used to retrieve b/c there is different criteria for cancel
!          due to reprice or not reprice. Used to compute unvested shares.
!-----------------------------------------------------------------------
Begin-Procedure Get-UnvestCancellations

  let #UnvestCancelled = 0

Begin-Select
SUM(G3.SHARES_VESTED - G3.SHARES_EXERCISED) &UnvestCancel

  let #UnvestCancelled = &UnvestCancel + #UnvestCancelled

from PS_ST_STOK002_TBL  G3
where G3.DATETIME_STAMP     = $CurrentTime
  and G3.PROCESSINSTANCE    = #Instance
  and G3.STOCK_ID           = $StockID
  and G3.ST_CANCEL_REASON   = 'TER'
  and G3.ST_CANCEL_DT      <= G3.VEST_DT
  and G3.GRANT_NBR          = $GrantNbr
  and G3.EMPLID             = $Emplid
  and G3.ST_CANCEL_DT      <= $AsOfDate
  and (G3.VEST_DT           > $AsOfDate
   or (G3.VEST_DT          <= $AsOfDate
  and G3.VEST_DT            > G3.VEST_SUSPEND_DT))

UNION
select
SUM(G3.SHARES_VESTED - G3.SHARES_EXERCISED)
from PS_ST_STOK002_TBL  G3
where G3.DATETIME_STAMP     = $CurrentTime
  and G3.PROCESSINSTANCE    = #Instance
  and G3.STOCK_ID           = $StockID
  and (G3.ST_CANCEL_REASON  = 'RPRC'
   or G3.ST_CANCEL_REASON   = 'RESC')
  and G3.ST_CANCEL_DT       < G3.EXPIRATN_DT
  and (G3.ST_CANCEL_DT      < G3.TERM_EXPIRATN_DT
   or G3.TERM_EXPIRATN_DT  is null)
  and G3.GRANT_NBR          = $GrantNbr
  and G3.EMPLID             = $Emplid
  and G3.ST_CANCEL_DT      <= $AsOfDate
  and (G3.VEST_DT           > $AsOfDate
   or (G3.VEST_DT          <= $AsOfDate
  and G3.VEST_DT            > G3.VEST_SUSPEND_DT))
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-VestExpirations
! Descr:   Retrieves any expired shares for an employee, given a date range.
!          Union is used to retrieve b/c there is different criteria for cancel
!          due to reprice or not reprice.
!-----------------------------------------------------------------------
Begin-Procedure Get-VestExpirations

  let #VestExpired = 0

Begin-Select
SUM(H2.SHARES_VESTED - H2.SHARES_EXERCISED) &VestExpire

  let #VestExpired = &VestExpire + #VestExpired

 from PS_ST_STOK002_TBL  H2
where H2.DATETIME_STAMP     = $CurrentTime
  and H2.PROCESSINSTANCE    = #Instance
  and H2.STOCK_ID           = $StockID
  and (H2.ST_CANCEL_REASON  = 'TER'
  or H2.ST_CANCEL_REASON    = ' ' )
  and (H2.ST_CANCEL_DT      > H2.VEST_DT
   or H2.ST_CANCEL_DT      is null)
  and H2.EXPIRATN_DT       >= H2.VEST_DT
  and (H2.TERM_EXPIRATN_DT >= H2.VEST_DT
   or H2.TERM_EXPIRATN_DT  is null)
  and H2.GRANT_NBR          = $GrantNbr
  and H2.EMPLID             = $Emplid
  and ((H2.EXPIRATN_DT     <= $AsOfDate 
   and (H2.EXPIRATN_DT      < H2.TERM_EXPIRATN_DT 
   or H2.TERM_EXPIRATN_DT  IS NULL))
  or ( H2.TERM_EXPIRATN_DT <= $AsOfDate 
   and H2.TERM_EXPIRATN_DT  < H2.EXPIRATN_DT))
  and (H2.VEST_DT          <= H2.VEST_SUSPEND_DT
   or H2.VEST_SUSPEND_DT   is null)

 UNION
 select
  SUM(H2.SHARES_VESTED - H2.SHARES_EXERCISED)

 from PS_ST_STOK002_TBL  H2
where H2.DATETIME_STAMP     = $CurrentTime
  and H2.PROCESSINSTANCE    = #Instance
  and H2.STOCK_ID           = $StockID
  and (H2.ST_CANCEL_REASON  = 'RPRC'
   or H2.ST_CANCEL_REASON   = 'RESC')
  and (H2.ST_CANCEL_DT     >= H2.EXPIRATN_DT
   or H2.ST_CANCEL_DT      >= H2.TERM_EXPIRATN_DT)
  and H2.GRANT_NBR          = $GrantNbr
  and H2.EMPLID             = $Emplid
   and ((H2.EXPIRATN_DT    <= $AsOfDate 
   and (H2.EXPIRATN_DT      < H2.TERM_EXPIRATN_DT 
   or H2.TERM_EXPIRATN_DT  IS NULL))
  or ( H2.TERM_EXPIRATN_DT <= $AsOfDate 
   and H2.TERM_EXPIRATN_DT  < H2.EXPIRATN_DT))
  and (H2.VEST_DT          <= H2.VEST_SUSPEND_DT
   or H2.VEST_SUSPEND_DT   is null)

End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Repurch2
! Descr:   Retrieves any repurchases for an employee, as of a given date.
!-----------------------------------------------------------------------
Begin-Procedure Get-Repurch2

Begin-Select
K2.SHARES_REPURCHASED &repurch2
K2.REPURCHASE_DT

  do Get-RepurchVest

  if &repurchvest  <= #Vested
     let #Unvested  = #Unvested + (&repurch2 - &repurchvest)
     
      if  #Unvested < 0
        let #Unvested = 0
      end-if

     let #Vested    = &repurchvest
  end-if

from PS_ST_GRNT_REPURCH  K2
where K2.EMPLID             = $Emplid
  and K2.STOCK_ID           = $StockID
  and K2.REPURCHASE_DT     <= $AsOfDate
  and K2.REPURCHASE_STATUS  = 'A'
  and K2.GRANT_NBR          = $GrantNbr
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-RepurchVest
! Descr:   Retrieves all vested shares for a particular grant number as of a
!          repurchase date.
!-----------------------------------------------------------------------
Begin-Procedure Get-RepurchVest

Begin-Select
SUM(D.SHARES_VESTED) &RepurchVest

from PS_ST_STOK002_TBL D
where D.DATETIME_STAMP   = $CurrentTime
  and D.PROCESSINSTANCE  = #Instance
  and D.STOCK_ID         = $StockID
  and D.EMPLID           = $Emplid
  and D.GRANT_NBR        = $GrantNbr
  and D.VEST_DT         <= &k2.repurchase_dt
  and (D.VEST_DT        <= D.VEST_SUSPEND_DT
   or D.VEST_SUSPEND_DT is null)
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Exercised
! Descr:   Retrieves all shares exercised for a particular grant number.
!-----------------------------------------------------------------------
Begin-Procedure Get-Exercised

 let #Exer = 0
 
Begin-Select
SUM(E.SHARES_EXERCISED) &exer

 let #Exer = &exer
  
from PS_ST_GRANT_EXER E
where E.EMPLID           = $Emplid
  and E.STOCK_ID         = $StockID
  and E.EXERCISE_DT     <= $AsOfDate
  and E.GRANT_NBR        = $GrantNbr
  and E.EXERCISE_STATUS  = 'A'
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Exerciseable1
! Descr:   Retrieves all shares exercised for a particular grant number.
!-----------------------------------------------------------------------
Begin-Procedure Get-Exerciseable1

 let #Exerable1 = 0
 
Begin-Select
SUM(E1.SHARES_VESTED - E1.SHARES_EXERCISED) &exerable1

  let #Exerable1 = &exerable1

from PS_ST_STOK002A_TBL E1
where E1.DATETIME_STAMP       = $CurrentTime
  and E1.PROCESSINSTANCE      = #Instance
  and E1.STOCK_ID             = $StockID
  and E1.GRANT_NBR            = $GrantNbr
  and E1.EMPLID               = $Emplid
  and (((E1.ST_CANCEL_DT      > $RC_AsOfDate
  and E1.VEST_DT              < E1.ST_CANCEL_DT)
   or E1.ST_CANCEL_DT        is null)
   or (E1.ST_CANCEL_DT       <= $RC_AsOfDate
  and E1.VEST_DT              < E1.ST_CANCEL_DT
  and E1.TERM_EXPIRATN_DT     >  $RC_AsOfDate))
  and (E1.EXPIRATN_DT         >  $RC_AsOfDate
  and ((E1.TERM_EXPIRATN_DT   >  $RC_AsOfDate
  and E1.VEST_DT              <  E1.TERM_EXPIRATN_DT)
   or E1.TERM_EXPIRATN_DT    is null))
  and (E1.VEST_DT             < E1.VEST_SUSPEND_DT
   or E1.VEST_SUSPEND_DT     is null)
  and (E1.EXERCISE_HOLD_DT    < $AsOfDate
   or E1.EXERCISE_HOLD_DT    is null)
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Exerciseable2
! Descr:   Retrieves all shares exercised for a particular grant number.
!-----------------------------------------------------------------------
Begin-Procedure Get-Exerciseable2

  let #Exerable2 = 0

Begin-Select
SUM(E2.SHARES_VESTED - E2.SHARES_EXERCISED) &exerable2

  let #Exerable2 = &exerable2

from PS_ST_STOK002_TBL E2
where E2.DATETIME_STAMP       = $CurrentTime
  and E2.PROCESSINSTANCE      = #Instance
  and E2.STOCK_ID             = $StockID
  and E2.GRANT_NBR            = $GrantNbr
  and E2.EMPLID               = $Emplid
  and (((E2.ST_CANCEL_DT      > $RC_AsOfDate
  and E2.VEST_DT              < E2.ST_CANCEL_DT)
   or E2.ST_CANCEL_DT        is null)
   or (E2.ST_CANCEL_DT       <= $RC_AsOfDate
  and E2.VEST_DT              < E2.ST_CANCEL_DT
  and E2.TERM_EXPIRATN_DT     >  $RC_AsOfDate))
  and (E2.EXPIRATN_DT         >  $RC_AsOfDate
  and ((E2.TERM_EXPIRATN_DT   >  $RC_AsOfDate
  and E2.VEST_DT              <  E2.TERM_EXPIRATN_DT)
   or E2.TERM_EXPIRATN_DT    is null))
  and (E2.VEST_DT             < E2.VEST_SUSPEND_DT
   or E2.VEST_SUSPEND_DT     is null)
  and (E2.EXERCISE_HOLD_DT    < $AsOfDate
   or E2.EXERCISE_HOLD_DT    is null)
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Exerciseable3
! Descr:   Retrieves all shares exercised for a particular grant number.
!-----------------------------------------------------------------------
Begin-Procedure Get-Exerciseable3

  let #Exerable3 = 0

Begin-Select
SUM(E3.SHARES_VESTED - E3.SHARES_EXERCISED) &exerable3

  let #Exerable3 = &exerable3

from PS_ST_STOK002A_TBL E3
where E3.DATETIME_STAMP       = $CurrentTime
  and E3.PROCESSINSTANCE      = #Instance
  and E3.STOCK_ID             = $StockID
  and E3.GRANT_NBR            = $GrantNbr
  and E3.EMPLID               = $Emplid
  and E3.VEST_DT              < E3.EXPIRATN_DT
  and (E3.VEST_DT             < E3.TERM_EXPIRATN_DT
   or E3.TERM_EXPIRATN_DT    is null)
  and E3.EXPIRATN_DT          > $AsOfDate
  and (E3.TERM_EXPIRATN_DT    > $AsOfDate
   or E3.TERM_EXPIRATN_DT    is null)
  and E3.VEST_DT             <= $AsOfDate
  and (E3.VEST_DT             < E3.VEST_SUSPEND_DT
   or E3.VEST_SUSPEND_DT     is null)
  and (E3.EXERCISE_HOLD_DT    < $AsOfDate
   or E3.EXERCISE_HOLD_DT    is null)
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Process-CancelExpire
! Descr:   Section to process shares cancelled and expires.
!-----------------------------------------------------------------------
Begin-Procedure Process-CancelExpire

 let $Header        = 'N'
 let #LastPageCount = #page-count
 let #Row           = 0
 let #TotCncl       = 0
 let #TotExpr       = 0

Begin-Select
F.GRANT_DT
F.GRANT_NBR
F.ST_CANCEL_DT
F.ST_CANCEL_REASON
 
 let $FieldName  = 'ST_CANCEL_REASON'
 let $FieldValue = &f.st_cancel_reason
 do Read-Translate-Table
 let $Reason = $XlatShortName

 do Get-Cancellations
 do Get-Expirations

 !-----------------------------------------------------------
 ! if cancel or expire row is returned, print output
 !-----------------------------------------------------------
  if #Cancelled <> 0 or #Expired <> 0
    if $Header = 'N'
       let $Print = 'Y'
       next-listing need=4
       print $OptCnclLbl                           (+2,001,038) bold
       print ':'                                   (  ,   ,001) bold
       print $GrantLbl                             (+1,017,005)
       print $CancelLbl                            (  ,024,010)
       print $CancelLbl                            (  ,036,010)
       print $GrantDtLbl                           (+1,001,010) underline
       print $NbrLbl                               (  ,016,006) underline
       print $DateLbl                              (  ,024,010) underline
       print $ReasonLbl                            (  ,036,010) underline
       print $ShrCnclLbl                           (  ,054,016) underline
       print $ShrExprLbl                           (  ,080,014) underline
       if #LastPageCount <> #page-count
          let #LastPageCount = #page-count
       end-if
       let $Header = 'Y'
    end-if
    do Format-DateTime (&f.grant_dt, $GrantDt, {DEFDATE}, '', '')
    print $GrantDt                                 (+1,001,010)
    let $GrantNbr = rtrim(&f.grant_nbr,' ')
    let $GrantNbr = lpad($GrantNbr,10,' ')
    print $GrantNbr                                (  ,012,010)
    do Format-DateTime (&f.st_cancel_dt, $CancelDt, {DEFDATE}, '', '')
    print $CancelDt                                (  ,024,010)
    print $Reason                                  (  ,036,010)
    print #Cancelled                               (  ,048,022) edit 999,999,999,999.999999
    print #Expired                                 (  ,072,022) edit 999,999,999,999.999999
    add #Cancelled to #TotCncl
    add #Expired   to #TotExpr
    add 1 to #Row
  end-if

from PS_ST_GRANT F
where F.GRANT_STATUS  = 'A'
  and F.EMPLID        = $Emplid
  and F.GRANT_DT     <= $AsOfDate
  and F.STOCK_ID      = $StockId
  order by 1,2
End-Select

 !--------------------------------------------------
 ! Prints totals if there is more than 1 detail row
 !--------------------------------------------------
 if #Row > 1
    print '_'                                      (+1,048,022) fill
    print '_'                                      (  ,072,022) fill
    print $TotalLbl                                (+1,001,010)
    print #TotCncl                                 (  ,048,022) edit 999,999,999,999.999999
    print #TotExpr                                 (  ,072,022) edit 999,999,999,999.999999
 end-if

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Cancellations
! Descr:   Retrieves any cancelled shares for an employee, given a date range.
!          Union is used to retrieve b/c there is differnt criteria for cancel
!          due to reprice or not reprice.
!-----------------------------------------------------------------------
Begin-Procedure Get-Cancellations

 let #Cancelled = 0

Begin-Select
SUM(G.SHARES_VESTED - G.SHARES_EXERCISED) &Cancel
  
 let #Cancelled = &Cancel + #Cancelled

 from PS_ST_STOK002_TBL  G
where G.DATETIME_STAMP     = $CurrentTime
  and G.PROCESSINSTANCE    = #Instance
  and G.STOCK_ID           = $StockID
  and G.ST_CANCEL_REASON   = 'TER'
  and G.ST_CANCEL_DT      <= G.VEST_DT
  and G.GRANT_NBR          = &f.grant_nbr
  and G.EMPLID             = $Emplid
  and G.ST_CANCEL_DT      <= $AsOfDate

 UNION
 select
  SUM(G.SHARES_VESTED - G.SHARES_EXERCISED)

 from PS_ST_STOK002_TBL  G
where G.DATETIME_STAMP     = $CurrentTime
  and G.PROCESSINSTANCE    = #Instance
  and G.STOCK_ID           = $StockID
  and (G.ST_CANCEL_REASON  = 'RPRC'
   or G.ST_CANCEL_REASON   = 'RESC')
  and G.ST_CANCEL_DT       < G.EXPIRATN_DT
  and (G.ST_CANCEL_DT      < G.TERM_EXPIRATN_DT
   or G.TERM_EXPIRATN_DT  is null)
  and G.GRANT_NBR          = &f.grant_nbr
  and G.EMPLID             = $Emplid
  and G.ST_CANCEL_DT      <= $AsOfDate
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Expirations
! Descr:   Retrieves any expired shares for an employee, given a date range.
!          Union is used to retrieve b/c there is differnt criteria for cancel
!          due to reprice or not reprice.
!-----------------------------------------------------------------------
Begin-Procedure Get-Expirations

 let #Expired = 0

Begin-Select
SUM(H.SHARES_VESTED - H.SHARES_EXERCISED) &Expire

  let #Expired = &Expire + #Expired

 from PS_ST_STOK002_TBL  H
where H.DATETIME_STAMP     = $CurrentTime
  and H.PROCESSINSTANCE    = #Instance
  and H.STOCK_ID           = $StockID
  and (H.ST_CANCEL_REASON  = 'TER'
   or H.ST_CANCEL_REASON   = ' ' )
  and (H.ST_CANCEL_DT      > H.VEST_DT
   or H.ST_CANCEL_DT      is null)
  and H.EXPIRATN_DT       >= H.VEST_DT
  and (H.TERM_EXPIRATN_DT >= H.VEST_DT
   or H.TERM_EXPIRATN_DT  is null)
  and H.GRANT_NBR          = &f.grant_nbr
  and H.EMPLID             = $Emplid
   and ((H.EXPIRATN_DT    <= $AsOfDate 
   and (H.EXPIRATN_DT      < H.TERM_EXPIRATN_DT 
   or H.TERM_EXPIRATN_DT  IS NULL))
  or ( H.TERM_EXPIRATN_DT <= $AsOfDate 
   and H.TERM_EXPIRATN_DT  < H.EXPIRATN_DT))

 UNION
 select
  SUM(H.SHARES_VESTED - H.SHARES_EXERCISED)


 from PS_ST_STOK002_TBL  H
where H.DATETIME_STAMP     = $CurrentTime
  and H.PROCESSINSTANCE    = #Instance
  and H.STOCK_ID           = $StockID
  and (H.ST_CANCEL_REASON  = 'RPRC'
   or H.ST_CANCEL_REASON   = 'RESC')
  and (H.ST_CANCEL_DT     >= H.EXPIRATN_DT
   or H.ST_CANCEL_DT      >= H.TERM_EXPIRATN_DT)
  and H.GRANT_NBR          = &f.grant_nbr
  and H.EMPLID             = $Emplid
  and ((H.EXPIRATN_DT     <= $AsOfDate 
   and (H.EXPIRATN_DT      < H.TERM_EXPIRATN_DT 
   or H.TERM_EXPIRATN_DT  IS NULL))
  or ( H.TERM_EXPIRATN_DT <= $AsOfDate 
   and H.TERM_EXPIRATN_DT  < H.EXPIRATN_DT))
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Process-ReleaseRepurch
! Descr:   Section to process shares released and repurchased.
!-----------------------------------------------------------------------
Begin-Procedure Process-ReleaseRepurch

  let $Header         = 'N'
  let #LastPageCount  = #page-count
  let #Row            = 0
  let #TotRelease     = 0
  let #TotRelable     = 0
  let #TotRepurch     = 0
  let #TotRepurchable = 0
  let #Relable        = 0
  let #Relable1       = 0
  let #Relable2       = 0

Begin-Select
I.GRANT_DT
I.GRANT_NBR
I.GRANT_PRICE
I.ST_OPTION_TYPE
I.EXER_BFR_VEST

  let $FieldName  = 'ST_OPTION_TYPE'
  let $FieldValue = &i.st_option_type
  do Read-Translate-Table
  let $OptType = $XlatShortName

  do Get-Released
  do Get-Repurchased
  do Get-Repurchable
  do Get-Releaseable

 !-----------------------------------------------------------
 ! if data exists, print output
 !-----------------------------------------------------------
  if #Release <> 0 or #Relable <> 0 or #Repurch <> 0 or #Repurchable <> 0
    if $Header = 'N'
      let $Print = 'Y'
      next-listing need=4
      print $OptRelLbl                                     (+2,001,043) bold
      print ':'                                            (  ,   ,001) bold
      print $GrantLbl                                      (+1,017,005)
      print $OptLbl                                        (  ,037,010)
      print $GrantDtLbl                                    (+1,001,010) underline
      print $NbrLbl                                        (  ,016,006) underline
      print $GrntPriceLbl                                  (  ,024,011) underline
      print $TypeLbl                                       (  ,037,010) underline
      print $RelableLbl                                    (  ,054,017) underline
      print $ReldLbl                                       (  ,080,015) underline
      print $RepableLbl                                    (  ,099,020) underline
      print $RepdLbl                                       (  ,125,018) underline
       if #LastPageCount <> #page-count
         let #LastPageCount = #page-count
       end-if
       let $Header = 'Y'
    end-if
    do Format-DateTime (&i.grant_dt, $GrantDt, {DEFDATE}, '', '')
    print $GrantDt                                         (+1,001,010)
    let $GrantNbr = rtrim(&i.grant_nbr,' ')
    let $GrantNbr = lpad($GrantNbr,10,' ')
    print $GrantNbr                                        (  ,012,010)
    print &i.grant_price                                   (  ,024,011) edit 9999.999999
    print $OptType                                         (  ,037,010)
    let #Relable2 = (#RestrictdExer - #Release)
    if #Relable1 < #Relable2
       let #Relable = #Relable1
    else
       let #Relable = #Relable2
    end-if
    if #Relable < 0 
       let #Relable = 0
    end-if

    let #Relable_Temp = #Relable - #Repurch
    
    if #Relable_Temp < 0 
       let #Relable_Temp = 0
    end-if
    
    print #Relable_Temp                                    (  ,049,022) edit 999,999,999,999.999999
    print #Release                                         (  ,073,022) edit 999,999,999,999.999999
    let #Repurchable = (#RestrictdExer - #Release - #Repurch)
    if #Repurchable < 0 
       let #Repurchable = 0
    end-if
    print #Repurchable                                     (  ,097,022) edit 999,999,999,999.999999
    print #Repurch                                         (  ,121,022) edit 999,999,999,999.999999
    add #Relable_Temp to #TotRelable
    add #Release      to #TotRelease
    add #Repurchable  to #TotRepurchable
    add #Repurch      to #TotRepurch
    add 1 to #Row
  end-if

from PS_ST_GRANT I
where I.GRANT_STATUS   = 'A'
  and I.EMPLID         = $Emplid
  and I.GRANT_DT      <= $AsOfDate
  and I.STOCK_ID       = $StockId
  and I.EXER_BFR_VEST  = 'Y'
  order by 1,2
End-Select

 !--------------------------------------------------
 ! Prints totals if there is more than 1 detail row
 !--------------------------------------------------
  if #Row > 1
    print '_'                                              (+1,049,022) fill
    print '_'                                              (  ,073,022) fill
    print '_'                                              (  ,097,022) fill
    print '_'                                              (  ,121,022) fill
    print $TotalLbl                                        (+1,001,10)
    print #TotRelable                                      (  ,049,022) edit 999,999,999,999.999999
    print #TotRelease                                      (  ,073,022) edit 999,999,999,999.999999
    print #TotRepurchable                                  (  ,097,022) edit 999,999,999,999.999999
    print #TotRepurch                                      (  ,121,022) edit 999,999,999,999.999999
  end-if

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Released
! Descr:   Retrieves any releases for an employee, as of a given date.
!-----------------------------------------------------------------------
Begin-Procedure Get-Released

 let #Release = 0

Begin-Select
SUM(J.SHARES_RELEASED) &rel

 let #Release = &rel

from PS_ST_EXER_RELEASE  J
where J.EMPLID          = $Emplid
  and J.STOCK_ID        = $StockID
  and J.RELEASE_DT     <= $AsOfDate
  and J.RELEASE_STATUS  = 'A'
  and J.GRANT_NBR       = &i.grant_nbr
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Repurchased
! Descr:   Retrieves any repurchases for an employee, as of a given date.
!-----------------------------------------------------------------------
Begin-Procedure Get-Repurchased

  let #Repurch = 0

Begin-Select
SUM(K.SHARES_REPURCHASED) &repurch

  let #Repurch = &repurch

from PS_ST_GRNT_REPURCH  K
where K.EMPLID             = $Emplid
  and K.STOCK_ID           = $StockID
  and K.REPURCHASE_DT     <= $AsOfDate
  and K.REPURCHASE_STATUS  = 'A'
  and K.GRANT_NBR          = &i.grant_nbr
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Repurchable
! Descr:   Retrieves restricted exercises, which are used to compute 
!          repurchaseable shares.
!-----------------------------------------------------------------------
Begin-Procedure Get-Repurchable

  let #RestrictdExer = 0

Begin-Select
SUM(L.SHARES_EXERCISED) &restrictd

  let #RestrictdExer = &restrictd

from PS_ST_GRANT_EXER L
where L.EMPLID              = $Emplid
  and L.STOCK_ID            = $StockID
  and L.EXERCISE_DT        <= $AsOfDate
  and L.EXERCISE_STATUS     = 'A'
  and L.RESTRICTD_EXERCISE  = 'Y'
  and L.GRANT_NBR           = &i.grant_nbr
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Releaseable
! Descr:   Retrieves all shares exercised for a particular grant number.
!-----------------------------------------------------------------------
Begin-Procedure Get-Releaseable

  let #Relable1 = 0

Begin-Select
SUM(M.SHARES_VESTED - M.SHARES_EXERCISED) &relable1

  let #Relable1 = &relable1

from PS_ST_STOK002A_TBL M
where M.DATETIME_STAMP      = $CurrentTime
  and M.PROCESSINSTANCE     = #Instance
  and M.STOCK_ID            = $StockID
  and M.GRANT_NBR           = &i.grant_nbr
  and M.EMPLID              = $Emplid
  and (M.ST_CANCEL_DT       > M.VEST_DT
   or M.ST_CANCEL_DT       is null)
  and M.VEST_DT             < M.EXPIRATN_DT
  and (M.VEST_DT            < M.TERM_EXPIRATN_DT
   or M.TERM_EXPIRATN_DT   is null)
  and M.EXPIRATN_DT         > $AsOfDate
  and (M.TERM_EXPIRATN_DT   > $AsOfDate
   or M.TERM_EXPIRATN_DT   is null)
  and (M.VEST_DT            < M.VEST_SUSPEND_DT
   or M.VEST_SUSPEND_DT    is null)
  and M.VEST_DT            <= $AsOfDate
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-ESPP-Purchases
! Descr:   Retrieves ESPP purchase for an employee
!-----------------------------------------------------------------------
Begin-Procedure Get-ESPP-Purchases

 let $Header        = 'N'
 let #LastPageCount = #page-count
 let #Row           = 0
 let #TotPurch      = 0
 let #TotESPPDisp   = 0
 let #TotHold       = 0
 let #Holding       = 0

Begin-Select
T.GRANT_DT
T1.PERIOD_BEGIN_DT
T.PERIOD_END_DT
T.GRANT_FMV
T.PURCHASE_FMV
T.PURCHASE_PRICE
T.SHARES_PURCHASED
T.STOCK_PLAN_TYPE
T.STOCK_PLAN
T.OFFERING_ID
T.PROCESS_GROUP
T.EMPLID
T.STOCK_ID

 !--------------------------------------------------------------------
 ! Only print the column heading info at the beginning of the section
 !--------------------------------------------------------------------
  if $Header = 'N'
    let $Print = 'Y'
    next-listing need=4
    print $ESPPPurchLbl                                    (+2,001,015) bold
    print ':'                                              (  ,   ,001) bold
    print $GrantDtLbl                                      (+1,001,010) underline
    print $GrantFmvLbl                                     (  ,014,009) underline
    print $StPlanLbl                                       (  ,024,010) underline
    print $PurchPerLbl                                     (  ,036,021) underline
    print $PurchPriceLbl                                   (  ,059,014) underline
    print $PurchFmvLbl                                     (  ,075,022) underline
    print $ShrPurchLbl                                     (  ,095,016) underline
    print $ShrDispLbl                                      (  ,121,015) underline
    print $ShrHoldLbl                                      (  ,145,014) underline
    if #LastPageCount <> #page-count
      let #LastPageCount = #page-count
    end-if
    let $Header = 'Y'
  end-if

  do Get-ESPP-Dispositions

  do Format-DateTime (&t.grant_dt, $out, {DEFDATE}, '', '')
  print $out                                               (+1,001,010)
  print &t.grant_fmv                                       (  ,012,011) edit 9999.999999
  print &t.stock_plan                                      (  ,024,010)
  do Format-DateTime (&t1.period_begin_dt, $beginout, {DEFDATE}, '', '')
  do Format-DateTime (&t.period_end_dt, $endout, {DEFDATE}, '', '')
  let $out = $beginout||'-'||$endout
  print $out                                               (  ,036,021)
  print &t.purchase_price                                  (  ,062,011) edit 9999.999999
  print &t.purchase_fmv                                    (  ,076,011) edit 9999.999999
  print &t.shares_purchased                                (  ,089,022) edit 999,999,999,999.999999
  print &u.shares_disposed                                 (  ,113,022) edit 999,999,999,999.999999
  let #Holding = (&t.shares_purchased - &u.shares_disposed)
  print #Holding                                           (  ,137,022) edit 999,999,999,999.999999
  add &t.shares_purchased to #TotPurch
  add &u.shares_disposed  to #TotESPPDisp
  add #Holding            to #TotHold
  add 1 to #Row

from PS_ST_ESPP_PURCH  T,
     PS_ST_PURCHASE_PD T1
where T.EMPLID           = $Emplid
  and T.STOCK_ID         = $StockID
  and T.PERIOD_END_DT   <= $AsOfDate
  and T.CONFIRMED        = 'Y'
  and T.STOCK_ID         = T1.STOCK_ID
  and T.STOCK_PLAN_TYPE  = T1.STOCK_PLAN_TYPE
  and T.STOCK_PLAN       = T1.STOCK_PLAN
  and T.OFFERING_ID      = T1.OFFERING_ID
  and T.PERIOD_END_DT    = T1.PERIOD_END_DT
  order by 1,2,3
End-Select

 !--------------------------------------------------
 ! Prints totals if there is more than 1 detail row
 !--------------------------------------------------
 if #Row > 1
    print '_'                                              (+1,089,022) fill
    print '_'                                              (  ,113,022) fill
    print '_'                                              (  ,137,022) fill
    print $TotalLbl                                        (+1,001,10)
    print #TotPurch                                        (  ,089,022) edit 999,999,999,999.999999
    print #TotESPPDisp                                     (  ,113,022) edit 999,999,999,999.999999
    print #TotHold                                         (  ,137,022) edit 999,999,999,999.999999
 end-if

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-ESPP-Dispositions
! Descr:   Retrieves ESPP dispositions for an employee, given a date range.
!-----------------------------------------------------------------------
Begin-Procedure Get-ESPP-Dispositions
 
Begin-Select
U.SHARES_DISPOSED

from PS_ST_ESPP_DISPOSN U
where U.DISPOSITION_DT     <= $AsOfDate
  and U.DISPOSITION_STATUS  = 'C'
  and U.EMPLID              = &T.EMPLID
  and U.STOCK_ID            = &T.STOCK_ID
  and U.STOCK_PLAN_TYPE     = &T.STOCK_PLAN_TYPE
  and U.STOCK_PLAN          = &T.STOCK_PLAN
  and U.OFFERING_ID         = &T.OFFERING_ID
  and U.PERIOD_END_DT       = &T.PERIOD_END_DT
  and U.PROCESS_GROUP       = &T.PROCESS_GROUP
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Personal-Data
! Descr:   Retrieves personal data for an employee - used in the heading 
!          section.
!-----------------------------------------------------------------------
Begin-Procedure Get-Personal-Data

  let $Name       = ''
  let $NID        = ''
  let $TaxCountry = ''

Begin-Select

ZC.NAME
ZD.NATIONAL_ID
ZE.COUNTRY

  let $Name       = rtrim(&zc.name,' ')
  let $NID        = rtrim(&zd.national_id,' ')
  let $TaxCountry = rtrim(&ze.country,' ')

  do Rotate-Name

  let $AddressType = 'MAIL'
  do Get-Empl-Address
  if $AddressFound = 'N'
    let $AddressType = 'HOME'
    do Get-Empl-Address
  end-if

from PS_PERSON          ZA,
     PS_PERS_DATA_EFFDT ZB,
     PS_PERSON_NAME     ZC,
     PS_PERS_NID        ZD,
     PS_TAX_LOCATION1   ZE
where ZA.EMPLID           = $Emplid
  and ZA.EMPLID           = ZB.EMPLID
  and ZB.EFFDT            = (select max(EFFDT)
                               from PS_PERS_DATA_EFFDT
                              where EMPLID = ZB.EMPLID
                                and EFFDT <= $AsOfToday)
  and ZA.EMPLID           = ZC.EMPLID
  and ZA.EMPLID           = ZD.EMPLID
  and ZD.COUNTRY          = ZE.COUNTRY
  and ZD.NATIONAL_ID_TYPE = 'PR'
  and ZE.TAX_LOCATION_CD  = $TaxCode

End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Empl-Address
! Descr:   Retrieves the Employee's Address
!-----------------------------------------------------------------------
Begin-Procedure Get-Empl-Address

  let $AddressFound = 'N'

Begin-Select

PERSON_ADDRESS.ADDRESS1
PERSON_ADDRESS.ADDRESS2
PERSON_ADDRESS.ADDRESS3
PERSON_ADDRESS.CITY
PERSON_ADDRESS.STATE
PERSON_ADDRESS.POSTAL
PERSON_ADDRESS.COUNTRY

  let $AddressFound = 'Y'
  let $EAddress1    = rtrim(&person_address.address1, ' ')
  let $EAddress2    = rtrim(&person_address.address2, ' ')
  let $EAddress3    = rtrim(&person_address.address3, ' ')
  let $ECity        = rtrim(&person_address.city, ' ')
  let $EState       = rtrim(&person_address.state, ' ')
  let $EPostal      = rtrim(&person_address.postal, ' ')
  let $ECountry     = rtrim(&person_address.country, ' ')

from PS_PERSON_ADDRESS PERSON_ADDRESS
where PERSON_ADDRESS.EMPLID       = $Emplid
  and PERSON_ADDRESS.ADDRESS_TYPE = $AddressType

End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Get-Insider-Info
! Descr:   Retrieves insider info for an employee, if any. Used in the heading.
!-----------------------------------------------------------------------
Begin-Procedure Get-Insider-Info

 let $Prev    = 'N'
 let $Insider = ''

Begin-Select

W.REPORTING_PERSON
W.ST_OFFICER
W.ST_DIRECTOR
W.COMPANY_INSIDER
W.ST_BEN_OWNER
W.PROXY_REPORT

  let $ReportingPerson = rtrim(&w.reporting_person, ' ')
  let $Officer         = rtrim(&w.st_officer, ' ')
  let $Director        = rtrim(&w.st_director, ' ')
  let $CompanyInsider  = rtrim(&w.company_insider, ' ')
  let $BenOwner        = rtrim(&w.st_ben_owner, ' ')
  let $ProxyReport     = rtrim(&w.proxy_report, ' ')

  if $ReportingPerson = 'Y'
    let $Insider = $InsiderR
    let $Prev = 'Y'
  end-if

  if $Officer = 'Y'
    if $Prev = 'Y'
      let $Insider = $Insider ||', '||$InsiderO
    else
      let $Insider = $InsiderO
    end-if
    let $Prev = 'Y'
  end-if

  if $Director = 'Y'
    if $Prev = 'Y'
      let $Insider = $Insider ||', '||$InsiderD
    else
      let $Insider = $InsiderD
    end-if
    let $Prev = 'Y'
  end-if

  if $CompanyInsider = 'Y'
    if $Prev = 'Y'
      let $Insider = $Insider ||', '||$InsiderC
    else
      let $Insider = $InsiderC
    end-if
    let $Prev = 'Y'
  end-if

  if $BenOwner = 'Y'
    if $Prev = 'Y'
      let $Insider = $Insider ||', '||$InsiderB
    else
      let $Insider = $InsiderB
    end-if
    let $Prev = 'Y'
  end-if

  if $ProxyReport = 'Y'
    if $Prev = 'Y'
      let $Insider = $Insider ||', '||$InsiderP
    else
      let $Insider = $InsiderP
    end-if
    let $Prev = 'Y'
  end-if

from PS_ST_INSIDER_TBL W
where W.EMPLID   = $Emplid
  and W.STOCK_ID = $StockID
  and W.EFFDT    = (select MAX(EFFDT) from PS_ST_INSIDER_TBL
                     where EMPLID    = W.EMPLID
                       and STOCK_ID  = W.STOCK_ID
                       and EFFDT    <= $AsOfToday)
End-Select

End-Procedure

!-----------------------------------------------------------------------
! Section: Delete-Temp
! Descr:   Delete all the info that we inserted into the temp table.
!-----------------------------------------------------------------------
Begin-Procedure Delete-Temp

 let $Procedure = 'Delete-Temp'
 let $SQL-Statement = 'Procedure: ' || $Procedure

Begin-Sql                           on-error = SQL-Error
DELETE from PS_ST_STOK002_TBL
where DATETIME_STAMP  = $CurrentTime
  and PROCESSINSTANCE = #Instance
End-Sql

Begin-Sql                           on-error = SQL-Error
DELETE from PS_ST_STOK002A_TBL
where DATETIME_STAMP  = $CurrentTime
  and PROCESSINSTANCE = #Instance
End-Sql

End-Procedure

!-----------------------------------------------------------------------
! SQC Includes
!-----------------------------------------------------------------------
#include 'curdttim.sqc'                !Procedures: Get-Current-DateTime
#include 'eoj.sqc'                     !End of Report Format
#include 'number.sqc'                  !Procedures: Init-Number
#include 'datetime.sqc'                !Procedures: Init-Datetime
#include 'prcsapi.sqc'                 !Process Scheduler API
#include 'prcsdef.sqc'                 !Update Process Open_Trans variable declaration
#include 'reset.sqc'                   !Reset printer procedure
#include 'strunctl.sqc'                !Stock Admin's Run Control Record
#include 'askaod.sqc'                  !Prompts for date range
#include 'getrplng.sqc'                !Gets the report language
#include 'sqlerr.sqc'                  !SQL error processing
#include 'sqrtrans.sqc'
#include 'datemath.sqc'
#include 'getprimj.sqc'                !Get primary job
#include 'stprcgrp.sqc'                !Creates temp table with all combos for process groups
#include 'readxlat.sqc'
#include 'rotname1.sqc'                !First Name, Last Nam

