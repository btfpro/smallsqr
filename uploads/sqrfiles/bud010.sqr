!***********************************************************************
!  BUD010.SQR:  Budget Export - Send Current FY to Budgets             *
!***********************************************************************
!***********************************************************************
!                                                                      *
!               Confidentiality Information:                           *
!                                                                      *
!                                                                      *
! This module contains confidential and proprietary information        *
! of Oracle; it is not to be copied, reproduced, or transmitted        *
! in any form, by any means, in whole or in part, nor is it to         *
! be used for any purpose other than that for which it is              *
! expressly provided under the applicable license agreement.           *
!                                                                      *
! Copyright (C) 2006 Oracle. All Rights Reserved.                      *
!                                                                      *
!***********************************************************************
! data to build a work file which will become part of budget data sent *
! to the Budgets product in Financials for Education and Government.   *
!                                                                      *
!                                                                      *
!***********************************************************************
!                                                                      *
!          $Date:  2006/07/19:11:24:21                                 !
!       $Release:  HR9                                                 !
!      $Revision:  101                                                 !
!                                                                      *
!  $Last Modified Apr 8 2002 4 Additional Chartfields for HRMS         *
!                 May 13 2002 Std hours named Std_hrs_default on instal*
!***********************************************************************
! This program is specific to HRMS for Public Sector.                  *
!***********************************************************************

#include 'setenv.sqc'
#include 'setup32.sqc'

!***********************************************************************

Begin-REPORT

   do INITIALIZE
   do MAINLINE
   do MAINLINE-JOBCODES
   do WRAPUP

End-REPORT

begin-heading 07

   #include 'stdhdg01.sqc'

   print 'Setid'                 (+1,1,5)
   print 'GL BU'                 (,+2,5)
   print 'HR BU'                 (,+2,5)
   print 'HR Dept'               (,+2,10)
   print 'HR Posn #'             (,+2,9)
   print 'Employee Id'           (,+2,11)
   print 'Rcd#'                  (,+2,4)
   print 'Description'           (,+2,)


   print '-'                     (+1,1,5) FILL
   print '-'                     (,+2,5)  FILL
   print '-'                     (,+2,5)  FILL
   print '-'                     (,+2,10) FILL
   print '-'                     (,+2,9)  FILL
   print '-'                     (,+2,11) FILL
   print '-'                     (,+2,4)  FILL
   print '-'                     (,+2,30) FILL

end-heading

!***********************************************************************
! Procedure: PRINT-WARNING-ROW                                         *
! Descr:     Inserts one row in the Warning-Log report for such items  *
!            as defaults being used in the output, etc.                *
!                                                                      *
! Called from throughout program                                       *
!***********************************************************************
begin-procedure PRINT-WARNING-ROW

   print $Gbl_SetID_Dept       (+1,1,5) !Setid
   print $Gbl_Bus_Unit_GL      (,+2,5)  !GL Business Unit
   print $Gbl_Bus_Unit         (,+2,5)  !HR Business Unit
   print $Gbl_DeptId           (,+2,10) !HR Department
   print $Gbl_Position_Nbr     (,+2,9)  !HR Position Number
   print $Gbl_EmplID           (,+2,11) !Employee ID
   print #Gbl_Empl_Rcd         (,+2,4)  !Empl_Rcd
   print '** Warning **'       (,+2,14)
   print $WarningMessage       (,+2,)   !Warning Message

end-procedure !PRINT-WARNING-ROW

!***********************************************************************
! Procedure: PRINT-ERROR-ROW                                           *
! Descr:     Inserts one row in the Error-Log report for serious data  *
!            errors.                                                   *
!                                                                      *
! Called from throughout program                                       *
!***********************************************************************
begin-procedure PRINT-ERROR-ROW

   print $Gbl_SetID_Dept       (+1,1,5) !Setid
   print $Gbl_Bus_Unit_GL      (,+2,5)  !GL Business Unit
   print $Gbl_Bus_Unit         (,+2,5)  !HR Business Unit
   print $Gbl_DeptId           (,+2,10) !HR Department
   print $Gbl_Position_Nbr     (,+2,9)  !HR Position Number
   print $Gbl_EmplID           (,+2,11) !Employee ID
   print #Gbl_Empl_Rcd         (,+2,4)  !Empl_Rcd
   print '**  Error  **'       (,+2,14)
   print $ErrorMessage         (,+2,)   !Error Message

end-procedure !PRINT-ERROR-ROW

!***********************************************************************
! Procedure: INITIALIZE                                                *
! Descr:     Performs the application initializations.  Formats var-   *
!            iables for use.  Calls the procedures to get input parms. *
!                                                                      *
! Called by: BEGIN-REPORT                                              *
!***********************************************************************
Begin-Procedure INITIALIZE

   do INIT-DATETIME
   do INIT-NUMBER
   do GET-CURRENT-DATETIME

   move 'BUD010.SQR' to $ReportID
   move 'Build Budget Export to G/L: Data Exceptions' to $ReportTitle
   show $ReportTitle ' ' $PRM_EFFDT

!Initializing variables

   let #Commit_Cnt = 0
   let $PrevPosTmpKey = ''
   let $BD_POSITION_NBR = '0'      !Starting Budgets Position Number
   let $PrevBuPosEmplKey = ' '
   let $New_BD_Position_Nbr = 'N'

   do STDAPI-INIT

   if $prcs_process_instance = ''
      show 'PeopleSoft does not support the execution of SQR programs other than'
      show 'with the use of the PeopleSoft Process Scheduler.  This and all'
      show 'PeopleSoft SQR programs should not be initiated directly from SQRW.'
      !NOTE -- PeopleSoft does not support execution of SQR programs
      !     directly from SQRW.  The call to "Ask-Parameters" is provided
      !     only to assist in debugging or program modification
      !Uncomment Prompts for SQRW development/testing ONLY!!
      ! do ASK-PARAMETERS
   else
      do SELECT-PARAMETERS
   end-if

!Following fields are Budget fields on the Budget position tables.
!None of these values exist in HR. Initialize to default values.

   let #Out_Spreadtype = 1
   let $Out_Existing_Posn_Flg = 'Y'
   let $Out_BD_Update_Flag = ' '
   let #Out_HeadCount = 1
   let $Out_Spread_Template = ' '
   let $Out_Ledger = $Prm_Ledger

   do SELECT-INSTALLATION

   do CLEAR-POSITION-TABLES

   !**   Check the result returned in the #filestat variable.  Stop program on error.
   if #SQL_Status <> 0
      stop       ! Halt program
   end-if

End-Procedure INITIALIZE
!***********************************************************************
! Procedure: ASK-PARAMETERS                                            *
! Descr:     Gets run-time parameters from the user where the program  *
!            is not executed through the process scheduler interface   *
!                                                                      *
! Called by: INITIALIZE                                                *
!***********************************************************************
Begin-Procedure ASK-PARAMETERS


   input $prcs_oprid maxlen=5 'Enter 5 character OPRID' type=char
   let $prcs_oprid = Upper($prcs_oprid)

   input $prcs_run_cntl_id maxlen=30 'Enter 30 character RUN CONTROL ID' type=char
   let $prcs_run_cntl_id = Upper($prcs_run_cntl_id)

   input $Prm_Effdt 'Enter EFFDT ({Prompt-Date})' type=date

   input $Fiscal_Year maxlen=4 'Enter 4-digit FISCAL YEAR' type=integer
   let #Prm_Fiscal_Year = $Fiscal_Year

   input $Business_Unit maxlen=5 'Enter 5 character BUSINESS UNIT' type=char
   let $Prm_Business_Unit = Upper($Business_Unit)

   input $Ledger maxlen=10 'Enter 10 character LEDGER' type=char
   let $Prm_Ledger = Upper($Ledger)

   input $Acct_CD maxlen=25 'Enter Combination Code (Max 25 char)' type=char
   let $Prm_Acct_Cd = Upper($Acct_Cd)

   if $Prm_Effdt = '' or #Prm_Fiscal_Year = 0
      display ' '
      display 'Program aborted at user'' request'
      stop quiet
   end-if

! Convert dates to dtu format for date calculation as well as
! cmp format for comparison

   let $Year4 = '1'
   do Format-DateTime ($Prm_Effdt,$Prm_Effdt,{DEFMDY},'','native')
   do Convert-To-DTU-Date($Prm_Effdt, $Prm_Effdt_Dtu)
   do Format-DateTime ($Prm_Effdt, $Prm_Effdt_Cmp, {DEFCMP},'','')
   do DTU-ADD-YEARS($Prm_Effdt_Dtu, 1, $Prm_YearDate_Dtu)
   do CONVERT-FROM-DTU-DATE($Prm_YearDate_Dtu, $Prm_YearDate)

End-Procedure ASK-PARAMETERS
!***********************************************************************
! Procedure: GET-VALUES                                                *
! Descr:     Loads and formats the variables obtained through the      *
!            process scheduler interface.                              *
!                                                                      *
! Called by: INITIALIZE                                                *
!***********************************************************************
Begin-Procedure GET-VALUES

   do Get-From-Thru-Date
   do Get-FiscalYear
   do Get-Business-Unit
   do Get-Ledger
   do Get-Acct-Cd

! Convert dates to dtu format for date calculation as well as
! cmp format for comparison

   do Convert-To-DTU-Date($ThruDate, $Prm_Effdt_Dtu)
   do Format-DateTime ($ThruDate, $Prm_Effdt_Cmp,{DEFCMP},'','')
   do DTU-ADD-YEARS($Prm_Effdt_Dtu, 1, $Prm_YearDate_Dtu)
   do CONVERT-FROM-DTU-DATE($Prm_YearDate_Dtu, $Prm_YearDate)

   move $Thrudate       to $Prm_Effdt
   move #FiscalYear     to #Prm_Fiscal_Year
   move $Business_Unit  to $Prm_Business_Unit
   move $Runctl_Ledger  to $Prm_Ledger
   move $Runctl_Acct_Cd to $Prm_Acct_Cd

End-Procedure GET-VALUES
!***********************************************************************
! Procedure: SELECT-INSTALLATION                                       *
! Descr:     Selects necessary parameters from the installation table  *
!                                                                      *
! Called by: INITIALIZE                                                *
!***********************************************************************
Begin-Procedure SELECT-INSTALLATION

   let $err-statement1 = 'BUD010, SELECT, PS_INSTALLATION, SELECT-INSTALLATION'
   let $err-statement2 = '    '

Begin-SELECT on-error=Error-Display
IN1.COUNTRY
IN1.PUBLIC_SECTOR
IN1.POSITION_MGMT
IN1.COMMIT_AFTER
IN1.STD_HRS_DEFAULT

   move &IN1.COUNTRY          to $Gbl_Country
   move &IN1.PUBLIC_SECTOR    to $Gbl_Public_Sector
   move &IN1.POSITION_MGMT    to $Gbl_Position_Mgmt
   move &IN1.COMMIT_AFTER     to #Gbl_Commit_After
   move &IN1.STD_HRS_DEFAULT  to #Gbl_Std_Hours

FROM PS_INSTALLATION IN1
End-SELECT

End-Procedure SELECT-INSTALLATION
!***********************************************************************
! Procedure: CLEAR-POSITION-TABLES                                     *
! Descr:     deletes all data from the HRMS copy of Budget Position    *
!            tables.
!                                                                      *
! Called by: INITIALIZE                                                *
!***********************************************************************
begin-procedure CLEAR-POSITION-TABLES

   let $err-statement1 = 'BUD010, DELETE, BD_POSITION_TBL, CLEAR-POSITION-TABLES'
   let $err-statement2 = 'Error on delete of BD_POSITION_TBL.  ' ||
                         'Program Execution aborted.'
Begin-SQL ON-ERROR=SQL-Error
DELETE FROM PS_BD_POSITION_TBL
End-SQL

   show ' '
   show 'Table BD_POSITION_TBL was successfully cleared.'

   let $err-statement1 = 'BUD010, DELETE, BD_JOB_TBL, CLEAR-POSITION-TABLES'
   let $err-statement2 = 'Error on delete of BD_JOB_TBL.  ' ||
                         'Program Execution aborted.'
begin-sql ON-ERROR=SQL-Error
Delete from PS_BD_JOB_TBL
end-sql

   show ' '
   show 'Table BD_JOB_TBL was successfully cleared.'

   let $err-statement1 = 'BUD010, DELETE, BD_DISTR_TBL, CLEAR-POSITION-TABLES'
   let $err-statement2 = 'Error on delete of BD_DISTR_TBL.  ' ||
                         'Program Execution aborted.'
begin-sql ON-ERROR=SQL-Error
Delete from PS_BD_DISTR_TBL
end-sql

   show ' '
   show 'Table BD_DISTR_TBL was successfully cleared.'

   let $err-statement1 = 'BUD010, DELETE, ZBD_JOBCODE_TBL, CLEAR-POSITION-TABLES'
   let $err-statement2 = 'Error on delete of ZBD_JOBCODE_TBL.  ' ||
                         'Program Execution aborted.'
begin-sql ON-ERROR=SQL-Error
Delete from PS_ZBD_JOBCODE_TBL
end-sql

   show ' '
   show 'Table ZBD_JOBCODE_TBL was successfully cleared.'

End-Procedure CLEAR-POSITION-TABLES

!***********************************************************************
! Procedure: MAINLINE                                                  *
! Descr:     Drive paragraph for this program.  Selects all current    *
!            JOB records by employee status.  For each job record, a   *
!            funding source entry is found and written to the temp.    *
!            table.  Open positions are the read from the POSITION_    *
!            DATA table and their funding sources identified.          *
!                                                                      *
! Called by: BEGIN-REPORT                                              *
!***********************************************************************
Begin-Procedure MAINLINE

   !** Select all position records.

   if $Gbl_Position_Mgmt = 'F'
   or $Gbl_Position_Mgmt = 'P'
      show ' '
      show 'Position Management setting is ' $Gbl_Position_Mgmt
      show 'Unfilled positions will be reported'
   else
      show ' '
      show 'Position Management setting is ' $Gbl_Position_Mgmt
      show 'Unfilled positions will not be reported'
   end-if

   do SELECT-POSN-RECORDS

   !** Select Job Records (status = 'A','P','Q','U')

   do SELECT-JOB-NO-POSN

End-Procedure MAINLINE

!***********************************************************************
! Procedure: SELECT-POSN-RECORDS                                       *
! Descr:     Select all vacant position records.  For each position    *
!            found, step through the heirarchy of sources to identify  *
!            the funding source for the position.  Primary table is    *
!            POSITION_DATA                                             *
!                                                                      *
! Called by: MAINLINE                                                  *
!***********************************************************************
Begin-Procedure SELECT-POSN-RECORDS

!  Read each vacant position record.  Check POSITION_DATA and DEPT_BUDGET
!  series of tables for funding sources.

   let $err-statement1 = 'BUD010, SELECT, PS_POSITION_DATA, SELECT-POSN-RECORDS'
   let $err-statement2 = 'Params: EFFDT=<' || $Prm_Effdt || '>'

Begin-SELECT on-error=Error-Display
POSA.BUSINESS_UNIT
POSA.POSITION_NBR
POSA.EFFDT
POSA.DESCR
POSA.ACTION
POSA.ACTION_REASON
POSA.POSN_STATUS
POSA.DEPTID
POSA.JOBCODE
POSA.STD_HOURS
BUNA.BUSINESS_UNIT_GL
POSA.MAX_HEAD_COUNT
POSA.LOCATION
POSA.REG_TEMP
POSA.FULL_PART_TIME
POSA.FTE
POSA.POSITION_POOL_ID
DPTA.BUDGET_DEPTID

   !**  Identify the source of the data we are using

   move 'P' to $Gbl_Data_Source
   move 'Y' to $New_BD_Position_Nbr

   let $Gbl_Position_Nbr    = &POSA.POSITION_NBR
   let $Gbl_EmplID          = ' '
   let #Gbl_Empl_Rcd        = 0
   let $Gbl_Effdt           = &POSA.EFFDT
   let #Gbl_Effseq          = 0
   let $Gbl_DeptID          = &DPTA.BUDGET_DEPTID
   let #Gbl_Head_Count      = &POSA.MAX_HEAD_COUNT
   let $Gbl_Jobcode         = &POSA.JOBCODE
   let $Gbl_Bus_Unit        = &POSA.BUSINESS_UNIT
   let $Gbl_Bus_Unit_GL     = &BUNA.BUSINESS_UNIT_GL
   let $Gbl_Pool_ID         = &POSA.POSITION_POOL_ID

   do SELECT-INCUMBENTS

   !** Select Position Records for vacant positions only if Position
   !**   Management is set to full or partial.

   if #Incumbents_Found < #Gbl_Head_Count

      if $Gbl_Position_Mgmt = 'F' or $Gbl_Position_Mgmt = 'P'

         let #Gbl_Empl_Rcd       = 0

         while #Incumbents_Found < #Gbl_Head_Count

            move 'P' to $Gbl_Data_Source

            let $Gbl_EmplID   = ' '
            let $Gbl_Effdt    = &POSA.EFFDT
            let #Gbl_Effseq   = 0
            let $Gbl_DeptID   = &DPTA.BUDGET_DEPTID
            let $Gbl_Jobcode  = &POSA.JOBCODE

            do GET-SETID-CONTROL
            do GET-SALARY-GRADE
            do LOAD-OUTPUT-VARS
            do FIND-FUNDING-SOURCE

            add 1 to #Incumbents_Found
            add 1 to #Gbl_Empl_Rcd

         end-while

      else
         let $WarningMessage = 'Unfilled headcount not reported.'
         do PRINT-WARNING-ROW
      end-if
   end-if

   let #Incumbents_Found = 0

FROM PS_POSITION_DATA POSA
   , PS_SET_CNTRL_REC SCTA
   , PS_BUS_UNIT_TBL_HR BUNA
   , PS_DEPT_TBL DPTA
WHERE POSA.EFF_STATUS =  'A'
  AND BUNA.BUSINESS_UNIT = POSA.BUSINESS_UNIT
  AND ((POSA.EFFDT  = (SELECT MAX(POS1.EFFDT)
                         FROM PS_POSITION_DATA POS1
                        WHERE POS1.POSITION_NBR = POSA.POSITION_NBR
                          AND POS1.EFFDT <= $Prm_Effdt))
   OR  (POSA.EFFDT >= (SELECT MAX(POS2.EFFDT)
                         FROM PS_POSITION_DATA POS2
                        WHERE POS2.POSITION_NBR = POSA.POSITION_NBR
                          AND POS2.EFFDT <= $Prm_Effdt)
    AND POSA.EFFDT <= $Prm_YearDate
    AND POSA.ACTION IN ('DEM','PAY','POS','PRO')))

  AND SCTA.SETCNTRLVALUE = POSA.BUSINESS_UNIT
  AND SCTA.REC_GROUP_ID = 'HR_01'
  AND SCTA.RECNAME = 'DEPT_TBL'
  AND DPTA.SETID = SCTA.SETID
  AND DPTA.DEPTID = POSA.DEPTID
  AND DPTA.EFFDT = (SELECT MAX(DPTA1.EFFDT)
                      FROM PS_DEPT_TBL DPTA1
                     WHERE DPTA1.SETID = DPTA.SETID
                       AND DPTA1.DEPTID = DPTA.DEPTID
                       AND DPTA1.EFFDT <= $Prm_Effdt)
ORDER BY POSA.BUSINESS_UNIT, POSA.POSITION_NBR
End-SELECT

End-Procedure SELECT-POSN-RECORDS

!***********************************************************************
! Procedure: SELECT-INCUMBENTS                                         *
! Descr:     Select all "active" job records for the position number   *
!            being processed.  When found, step through the heirarchy  *
!            of funding source for the position.  Primary table is     *
!            PS_JOB                                                    *
!                                                                      *
! Called by: SELECT-POSN-RECORDS                                       *
!***********************************************************************
Begin-Procedure SELECT-INCUMBENTS

   let #Incumbents_Found = 0

!  Read the JOB table for all job records in statuses 'A','P','Q', and 'U'

   let $err-statement1 = 'BUD010, SELECT, PS_JOB, SELECT-INCUMBENTS'
   let $err-statement2 = 'Params: EFFDT=<' || $Prm_Effdt || '>'

Begin-SELECT on-error=Error-Display
JOBA.BUSINESS_UNIT
JOBA.POSITION_NBR
JOBA.EMPLID
JOBA.EMPL_RCD
JOBA.EFFDT
JOBA.EFFSEQ
JOBA.ACTION
JOBA.ACTION_REASON
JOBA.SETID_DEPT
JOBA.DEPTID
JOBA.SETID_JOBCODE
JOBA.JOBCODE
JOBA.ANNUAL_RT
JOBA.STD_HOURS
JOBA.ACCT_CD
JOBA.EMPL_STATUS
JOBA.CURRENCY_CD
JOBA.LOCATION
JOBA.SAL_ADMIN_PLAN
JOBA.GRADE
JOBA.STEP
JOBA.REG_TEMP
JOBA.FULL_PART_TIME
JOBA.EARNS_DIST_TYPE
JOBA.FTE
DPTC.BUDGET_DEPTID

   !**  Identify the source of the data we are using

   add 1 to #Incumbents_Found
   move 'J' to $Gbl_Data_Source
   move 'Y' to $New_BD_Position_Nbr

   !**  If Position Management is Full, Select only job records where position
   !**    number is populated.  If Position Management is partial or none,
   !**    select all job records.

   let $Gbl_EmplID         = &JOBA.EMPLID
   let #Gbl_Empl_Rcd       = &JOBA.EMPL_RCD

   let #Gbl_Effseq         = &JOBA.EFFSEQ
   let $Gbl_SetID_Dept     = &JOBA.SETID_DEPT
   let $Gbl_DeptID         = &DPTC.BUDGET_DEPTID
   let $Gbl_SetID_Jobcode  = &JOBA.SETID_JOBCODE
   let $Gbl_Jobcode        = &JOBA.JOBCODE
   let $Gbl_Dist_Type      = &JOBA.EARNS_DIST_TYPE

   let $Job_Acct_Cd        = rtrim(&JOBA.ACCT_CD,' ')
   let #Job_Std_Hours      = &JOBA.STD_HOURS

   do GET-EMPLOYEE-NAME

   do LOAD-OUTPUT-VARS

   do FIND-FUNDING-SOURCE

FROM PS_JOB JOBA
   , PS_DEPT_TBL DPTC
WHERE JOBA.EMPL_STATUS  IN ('A','P','Q','U')
  AND JOBA.POSITION_NBR = $Gbl_Position_Nbr
  AND JOBA.EFFDT = (SELECT MAX(JOBA1.EFFDT)
                        FROM PS_JOB JOBA1
                       WHERE JOBA1.EMPLID = JOBA.EMPLID
                         AND JOBA1.EMPL_RCD = JOBA.EMPL_RCD
                         AND JOBA1.EFFDT <= $Prm_Effdt)
   AND JOBA.EFFSEQ = (SELECT MAX(JOBA2.EFFSEQ)
                        FROM PS_JOB JOBA2
                       WHERE JOBA2.EMPLID = JOBA.EMPLID
                         AND JOBA2.EMPL_RCD = JOBA.EMPL_RCD
                         AND JOBA2.EFFDT = JOBA.EFFDT)
  AND DPTC.SETID = JOBA.SETID_DEPT
  AND DPTC.DEPTID = JOBA.DEPTID
  AND DPTC.EFFDT = (SELECT MAX(DPTC1.EFFDT)
                      FROM PS_DEPT_TBL DPTC1
                     WHERE DPTC1.SETID = DPTC.SETID
                       AND DPTC1.DEPTID = DPTC.DEPTID
                       AND DPTC1.EFFDT <= $Prm_Effdt)

end-SELECT

end-procedure SELECT-INCUMBENTS

!***********************************************************************
! Procedure: SELECT-JOB-NO-POSN                                        *
! Descr:     Select all "active" job records.  For each job record     *
!            found, step through the heirarchy of sources to identify  *
!            the funding source for the position.  Primary table is    *
!            JOB                                                       *
!                                                                      *
! Called by: MAINLINE                                                  *
!***********************************************************************
Begin-Procedure SELECT-JOB-NO-POSN

   let #Job_No_Posn = 1

!  Read the JOB table for all job records in statuses 'A','P','Q', and 'U'

   let $err-statement1 = 'BUD010, SELECT, PS_JOB, SELECT-JOB-RECORDS'
   let $err-statement2 = 'Params: EFFDT=<' || $Prm_Effdt || '>'

Begin-SELECT on-error=Error-Display
JOBB.BUSINESS_UNIT
JOBB.POSITION_NBR
JOBB.EMPLID
JOBB.EMPL_RCD
JOBB.EFFDT
JOBB.EFFSEQ
JOBB.ACTION
JOBB.ACTION_REASON
JOBB.SETID_DEPT
JOBB.DEPTID
JOBB.SETID_JOBCODE
JOBB.JOBCODE
JOBB.ANNUAL_RT
JOBB.STD_HOURS
BUNB.BUSINESS_UNIT_GL
JOBB.ACCT_CD
JOBB.EMPL_STATUS
JOBB.CURRENCY_CD
JOBB.LOCATION
JOBB.SAL_ADMIN_PLAN
JOBB.GRADE
JOBB.STEP
JOBB.REG_TEMP
JOBB.FULL_PART_TIME
JOBB.EARNS_DIST_TYPE
JOBB.FTE
DPTB.BUDGET_DEPTID

   !**  Identify the source of the data we are using

   move 'J' to $Gbl_Data_Source
   move 'Y' to $New_BD_Position_Nbr

   !**  If Position Management is Full, Select only job records where position
   !**    number is populated.  If Position Management is partial or none,
   !**    select all job records.

   let $Gbl_Position_Nbr   = &JOBB.POSITION_NBR
   let $Gbl_EmplID         = &JOBB.EMPLID

   let #Gbl_Empl_Rcd       = &JOBB.EMPL_RCD
   let $Gbl_Effdt          = &JOBB.EFFDT
   let #Gbl_Effseq         = &JOBB.EFFSEQ
   let $Gbl_SetID_Dept     = &JOBB.SETID_DEPT
   let $Gbl_DeptID         = &DPTB.BUDGET_DEPTID
   let $Gbl_SetID_Jobcode  = &JOBB.SETID_JOBCODE
   let $Gbl_Jobcode        = &JOBB.JOBCODE
   let $Gbl_Dist_Type      = &JOBB.EARNS_DIST_TYPE
   let $Gbl_Bus_Unit       = &JOBB.BUSINESS_UNIT
   let $Gbl_Bus_Unit_GL    = &BUNB.BUSINESS_UNIT_GL
   let #Job_Std_Hours      = &JOBB.STD_HOURS

   let $Job_Acct_Cd        = rtrim(&JOBB.ACCT_CD,' ')

   If ($Gbl_Position_Mgmt = 'F' and $Gbl_Position_Nbr <> '')
   or ($Gbl_Position_Mgmt = 'P')
   or ($Gbl_Position_Mgmt = 'N')

      do GET-EMPLOYEE-NAME

      do LOAD-OUTPUT-VARS

      let #Wrk_Head_Count = 1

      do FIND-FUNDING-SOURCE

   end-if

FROM PS_JOB JOBB
   , PS_BUS_UNIT_TBL_HR BUNB
   , PS_DEPT_TBL DPTB
WHERE JOBB.EMPL_STATUS  IN ('A','P','Q','U')
  AND (JOBB.POSITION_NBR = ' ' or JOBB.POSITION_NBR = '')
  AND BUNB.BUSINESS_UNIT = JOBB.BUSINESS_UNIT
  AND ((JOBB.EFFDT = (SELECT MAX(JOBB1.EFFDT)
                        FROM PS_JOB JOBB1
                       WHERE JOBB1.EMPLID = JOBB.EMPLID
                         AND JOBB1.EMPL_RCD = JOBB.EMPL_RCD
                         AND JOBB1.EFFDT <= $Prm_Effdt)
   AND JOBB.EFFSEQ = (SELECT MAX(JOBB2.EFFSEQ)
                        FROM PS_JOB JOBB2
                       WHERE JOBB2.EMPLID = JOBB.EMPLID
                         AND JOBB2.EMPL_RCD = JOBB.EMPL_RCD
                         AND JOBB2.EFFDT = JOBB.EFFDT))
   OR (JOBB.EFFDT  > (SELECT MAX(JOBB3.EFFDT)
                        FROM PS_JOB JOBB3
                       WHERE JOBB3.EMPLID = JOBB.EMPLID
                         AND JOBB3.EMPL_RCD = JOBB.EMPL_RCD
                         AND JOBB3.EFFDT <= $Prm_Effdt)
   AND JOBB.EFFDT <= $Prm_YearDate
   AND JOBB.ACTION IN ('DEM','PAY','POS','PRO')))
  AND DPTB.SETID = JOBB.SETID_DEPT
  AND DPTB.DEPTID = JOBB.DEPTID
  AND DPTB.EFFDT = (SELECT MAX(DPTB1.EFFDT)
                      FROM PS_DEPT_TBL DPTB1
                     WHERE DPTB1.SETID = DPTB.SETID
                       AND DPTB1.DEPTID = DPTB.DEPTID
                       AND DPTB1.EFFDT <= $Prm_Effdt)
end-SELECT

   let #Job_No_Posn = 0

end-procedure SELECT-JOB-NO-POSN

!***********************************************************************
! Procedure: GET-EMPLOYEE-NAME                                         *
! Descr:     Selects employee name from PS_PERSON_NAME.                *
!                                                                      *
! Called by: LOAD-OUTPUT-VARS                                          *
!***********************************************************************
begin-procedure GET-EMPLOYEE-NAME

begin-SELECT
PSD.NAME

   let $Job_Name = rtrim(&PSD.NAME,' ')
   let $Job_Name = nvl($Job_Name,' ')

FROM  PS_PERSON_NAME PSD
WHERE PSD.EMPLID = $Gbl_EmplID
end-SELECT

end-procedure

!***********************************************************************
! Procedure: GET-SETID-CONTROL                                         *
! Descr:     Find the SETID's for use with DEPTID and JOBCODE when     *
!            starting with POSITION_DATA.                              *
!                                                                      *
! Called by: SELECT-POSN-RECORDS                                       *
!***********************************************************************
Begin-Procedure GET-SETID-CONTROL

   let $err-statement1 = 'BUD010, SELECT, PS_SET_CNTRL_REC, GET-SETID-CONTROL'
   let $err-statement2 = 'Params: SETCNTRLVALUE=<' || $Gbl_Bus_Unit      || '>'

Begin-SELECT on-error=Error-Display
CTLA.SETID

   let $Gbl_SetID_Dept = &CTLA.SETID

FROM PS_SET_CNTRL_REC CTLA
WHERE CTLA.SETCNTRLVALUE = $Gbl_Bus_Unit
  AND CTLA.REC_GROUP_ID  = 'HR_01'
  AND CTLA.RECNAME       = 'DEPT_TBL'
End-SELECT

Begin-SELECT on-error=Error-Display
CTLB.SETID

   let $Gbl_SetID_Jobcode = &CTLB.SETID

FROM PS_SET_CNTRL_REC CTLB
WHERE CTLB.SETCNTRLVALUE = $Gbl_Bus_Unit
  AND CTLB.REC_GROUP_ID  = 'HR_02'
  AND CTLB.RECNAME       = 'JOBCODE_TBL'
End-SELECT

End-Procedure GET-SETID-CONTROL

!***********************************************************************
! Procedure: GET-SALARY-GRADE                                          *
! Descr:     Common module.  The position salary is obtained from the  *
!            midpoint of the salary grade assigned to the jobcode for  *
!            the position.                                             *
!                                                                      *
! Called by: SELECT-POSN-RECORDS                                       *
!***********************************************************************
Begin-Procedure GET-SALARY-GRADE

   let #Pos_Annual_Rt = 0.0

   let $err-statement1 = 'BUD010, SELECT, PS_POSITION_DATA, GET-SALARY-GRADE'
   let $err-statement2 = 'Params: SETID=<' || $Gbl_SetID_Jobcode ||
                         '>, JOBCODE=<' || $Gbl_Jobcode ||
                         '>, EFFDT=<' || &POSA.EFFDT || '>'

begin-SELECT on-error=Error-Display
SGTA.SAL_ADMIN_PLAN
SGTA.GRADE
SGTA.MID_RT_ANNUAL

   let $Pos_Sal_Plan  = &SGTA.SAL_ADMIN_PLAN
   let $Pos_Sal_Grade = &SGTA.GRADE
   let #Pos_Annual_Rt = &SGTA.MID_RT_ANNUAL

FROM PS_JOBCODE_TBL JCDA
   , PS_SAL_GRADE_TBL SGTA
WHERE JCDA.SETID = $Gbl_SetID_Jobcode
  AND JCDA.JOBCODE = $Gbl_Jobcode
  AND JCDA.EFFDT = (SELECT MAX(JCD1.EFFDT)
                     FROM PS_JOBCODE_TBL JCD1
                    WHERE JCD1.SETID = JCDA.SETID
                      AND JCD1.JOBCODE = JCDA.JOBCODE
                      AND JCD1.EFFDT <= &POSA.EFFDT)
  AND JCDA.EFF_STATUS = 'A'
  AND SGTA.SETID = JCDA.SETID_SALARY
  AND SGTA.SAL_ADMIN_PLAN = JCDA.SAL_ADMIN_PLAN
  AND SGTA.GRADE = JCDA.GRADE
  AND SGTA.EFFDT = (SELECT MAX(SGT1.EFFDT)
                     FROM PS_SAL_GRADE_TBL SGT1
                    WHERE SGT1.SETID = SGTA.SETID
                      AND SGT1.SAL_ADMIN_PLAN = SGTA.SAL_ADMIN_PLAN
                      AND SGT1.GRADE = SGTA.GRADE
                      AND SGT1.EFFDT <= &POSA.EFFDT)
  AND SGTA.EFF_STATUS = 'A'
End-Select

End-Procedure GET-SALARY-GRADE

!***********************************************************************
! Procedure: LOAD-OUTPUT-VARS                                          *
! Descr:     For either JOB or POSITION_DATA records, loads selected   *
!            table data into the output variables for output to the    *
!            ZBD_POS_FND_WRK table.                                    *
!                                                                      *
! Called by: SELECT-JOB-RECORDS                                        *
!            SELECT-POSN-RECORDS                                       *
!***********************************************************************
Begin-Procedure LOAD-OUTPUT-VARS

   if $Gbl_Data_Source = 'J'
      if #Job_No_Posn
         move &JOBB.BUSINESS_UNIT      to $Out_Business_Unit
         move &JOBB.POSITION_NBR       to $Out_Position_Nbr
         move &JOBB.EMPLID             to $Out_Emplid
         move &JOBB.EMPL_RCD           to #Out_Empl_Rcd
         move &JOBB.EFFDT              to $Out_Effdt
         move &JOBB.EFFSEQ             to #Out_Effseq
         move &JOBB.ACTION             to $Out_Action
         move &JOBB.ACTION_REASON      to $Out_Action_Reason
         move $Job_Name                to $Out_Name
         move &JOBB.EMPL_STATUS        to $Out_Empl_Status
         move 1                        to #Out_Max_Head_Count
         move &JOBB.ANNUAL_RT          to #Out_Annual_Rt
         move &JOBB.FTE                to #Out_FTE
         move ' '                      to $Out_Descr
         move 'A'                      to $Out_Posn_Status
         move &JOBB.CURRENCY_CD        to $Out_Currency_Cd
         move &BUNB.BUSINESS_UNIT_GL   to $Out_Business_Unit_GL
         move &JOBB.SETID_JOBCODE      to $Out_Setid_Jobcode
         move &JOBB.JOBCODE            to $Out_Jobcode
         move &JOBB.LOCATION           to $Out_Location
         move &JOBB.STD_HOURS          to #Out_Std_Hours
         move &JOBB.REG_TEMP           to $Out_Reg_Temp
         move &JOBB.FULL_PART_TIME     to $Out_Full_Part_Time
         move &JOBB.SAL_ADMIN_PLAN     to $Out_Sal_Admin_Plan
         move &JOBB.GRADE              to $Out_Grade
         move &JOBB.STEP               to #Out_Step
         move &JOBB.ACCT_CD            to $Out_Acct_Cd
         move &JOBB.SETID_DEPT         to $Out_Setid_Dept
    !    move &JOBB.DEPTID             to $Out_DeptID_From
         move $Gbl_DeptID              to $Out_DeptID_From
      else
         move &POSA.BUSINESS_UNIT      to $Out_Business_Unit
         move &POSA.POSITION_NBR       to $Out_Position_Nbr
         move &JOBA.EMPLID             to $Out_Emplid
         move &JOBA.EMPL_RCD           to #Out_Empl_Rcd
         move &JOBA.EFFDT              to $Out_Effdt
         move &JOBA.EFFSEQ             to #Out_Effseq
         move &JOBA.ACTION             to $Out_Action
         move &JOBA.ACTION_REASON      to $Out_Action_Reason
         move $Job_Name                to $Out_Name
         move &JOBA.EMPL_STATUS        to $Out_Empl_Status
         move &POSA.MAX_HEAD_COUNT     to #Out_Max_Head_Count
         move &JOBA.ANNUAL_RT          to #Out_Annual_Rt
         move &JOBA.FTE                to #Out_FTE
         move &POSA.DESCR              to $Out_Descr
         move &POSA.POSN_STATUS        to $Out_Posn_Status
         move &JOBA.CURRENCY_CD        to $Out_Currency_Cd
         move &BUNA.BUSINESS_UNIT_GL   to $Out_Business_Unit_GL
         move &JOBA.SETID_JOBCODE      to $Out_Setid_Jobcode
         move &JOBA.JOBCODE            to $Out_Jobcode
         move &JOBA.LOCATION           to $Out_Location
         move &JOBA.STD_HOURS          to #Out_Std_Hours
         move &JOBA.REG_TEMP           to $Out_Reg_Temp
         move &JOBA.FULL_PART_TIME     to $Out_Full_Part_Time
         move &JOBA.SAL_ADMIN_PLAN     to $Out_Sal_Admin_Plan
         move &JOBA.GRADE              to $Out_Grade
         move &JOBA.STEP               to #Out_Step
         move &JOBA.ACCT_CD            to $Out_Acct_Cd
         move &JOBA.SETID_DEPT         to $Out_Setid_Dept
    !    move &JOBA.DEPTID             to $Out_DeptID_From
         move $Gbl_DeptID              to $Out_DeptID_From
      end-if
   end-if

   if $Gbl_Data_Source = 'P'
      move &POSA.BUSINESS_UNIT      to $Out_Business_Unit
      move &POSA.POSITION_NBR       to $Out_Position_Nbr
      move ' '                      to $Out_Emplid
      move #Gbl_Empl_Rcd            to #Out_Empl_Rcd
!*      move 0                        to #Out_Empl_Rcd
      move &POSA.EFFDT              to $Out_Effdt
      move 0                        to #Out_Effseq
      move &POSA.ACTION             to $Out_Action
      move &POSA.ACTION_REASON      to $Out_Action_Reason
      move ' '                      to $Out_Name
      move ' '                      to $Out_Empl_Status
      move &POSA.MAX_HEAD_COUNT     to #Out_Max_Head_Count
      move #Pos_Annual_Rt           to #Out_Annual_Rt
      move &POSA.FTE                to #Out_FTE
      move &POSA.DESCR              to $Out_Descr
      move &POSA.POSN_STATUS        to $Out_Posn_Status
      move ' '                      to $Out_Currency_Cd
      move &BUNA.BUSINESS_UNIT_GL   to $Out_Business_Unit_GL
      move $Gbl_SetID_Jobcode       to $Out_Setid_Jobcode
      move &POSA.JOBCODE            to $Out_Jobcode
      move &POSA.LOCATION           to $Out_Location
      move &POSA.STD_HOURS          to #Out_Std_Hours
      move &POSA.REG_TEMP           to $Out_Reg_Temp
      move &POSA.FULL_PART_TIME     to $Out_Full_Part_Time
      move $Pos_Sal_Plan            to $Out_Sal_Admin_Plan
      move $Pos_Sal_Grade           to $Out_Grade
      move 0                        to #Out_Step
      move ' '                      to $Out_Acct_Cd
      move $Gbl_SetID_Dept          to $Out_Setid_Dept
      move $Gbl_DeptID              to $Out_DeptID_From
   end-if

end-procedure LOAD-OUTPUT-VARS

!***********************************************************************
! Procedure: FIND-FUNDING-SOURCE                                       *
! Descr:     For a JOB or POSITION_DATA record, step through the       *
!            appropriate steps of the "funding heirarchy" until a non- *
!            blank account code (valid funding source) is found.       *
!                                                                      *
! Called by: SELECT-JOB-RECORDS                                        *
!            SELECT-POSN-RECORDS                                       *
!***********************************************************************
Begin-Procedure FIND-FUNDING-SOURCE


   let #Gbl_Funding_Found = 0

   !** Look at each level of funding in the following heirarchical order:
   !**
   !**    1. JOB_EARNS_DIST rows declared at the employee level
   !**    2. An overall ACCT_CD specified on the JOB Record
   !**    3. Appointment level funding in the DEPT_BUDGET tables
   !**    4. Position level funding in the DEPT_BUDGET tables
   !**    5. Jobcode level funding in the DEPT_BUDGET tables
   !**    6. Position Pool level funding in the DEPT_BUDGET tables
   !**    7. Department level funding in the DEPT_BUDGET tables
   !**
   !** Note that for vacant positions only funding checks at levels 4, 5, 6,
   !**   and 7 will apply, as no JOB or Appointment data is present.


   if not #Gbl_Funding_Found
      if $Gbl_Data_Source = 'J'
         if $Gbl_Dist_Type <> 'N'
            do JOB-EARNS-DIST-FUNDING
         end-if
      end-if
   end-if


   if not #Gbl_Funding_Found
      if $Gbl_Data_Source = 'J'
         do JOB-ACCT-CODE-FUNDING
      end-if
   end-if


   if not #Gbl_Funding_Found
      if $Gbl_Data_Source = 'J'
         do BDGT-APPT-FUNDING
      end-if
   end-if

   if not #Gbl_Funding_Found
      if $Gbl_Position_Nbr <> '' and $Gbl_Position_Nbr <> ' '
         do BDGT-POSN-FUNDING
      end-if
   end-if


   if not #Gbl_Funding_Found
      if $Gbl_Jobcode <> '' and $Gbl_Jobcode <> ' '
         do BDGT-JOBCODE-FUNDING
      end-if
   end-if


   if not #Gbl_Funding_Found
      if $Gbl_Pool_ID <> '' and $Gbl_Pool_ID <> ' '
         do BDGT-POOL-FUNDING
      end-if
   end-if

   if not #Gbl_Funding_Found
      do BDGT-DEPT-FUNDING
   end-if

   if not #Gbl_Funding_Found
      let #Out_Budget_Amt = #Out_Annual_Rt
      let #Out_Budget_Dist = 100.00
      let $Out_Acct_Cd = rtrim($Prm_Acct_Cd,' ')
      let #Out_Budget_Seq = 1
      let $Out_Erncd = '   '
      let $WarningMessage = 'No Funding Source Found. Default acct. code used.'
      do PRINT-WARNING-ROW

      do OUTPUT-POSN-TABLES
      move 1 to #Gbl_Funding_Found
   end-if

End-Procedure FIND-FUNDING-SOURCE

!***********************************************************************
! Procedure: JOB-EARNS-DIST-FUNDING                                    *
! Descr:     Selects data from the JOB_EARNS_DIST table for the        *
!            employee in force at the specified effective date.  If    *
!            funding exists, writes output and sets found flag.        *
!                                                                      *
! Called by: FIND-FUNDING-SOURCE                                       *
!***********************************************************************
Begin-Procedure JOB-EARNS-DIST-FUNDING

   let #Total_JED_Amt = 0.00
   let #Total_JED_Pct = 0.00

   let $Dis_Empl_Rcd   = edit(#Gbl_Empl_Rcd,'99')
   let $Dis_EffSeq     = edit(#Gbl_Effseq,'99')

   let $err-statement1 = 'BUD010, SELECT, PS_JOB_EARNS_DIST, JOB-EARNS-DIST-TOTALS'
   let $err-statement2 = 'Params: EMPLID=<' || $Gbl_Emplid ||
                         '>, EMPL_RCD=<' || $Dis_Empl_Rcd ||
                         '>, EFFDT=<' || $Gbl_Effdt ||
                         '>, EFFSEQ=<' || $Dis_EffSeq || '>'

begin-SELECT on-error=Error-Display
JET.ACCT_CD
JET.COMPRATE
JET.DIST_PCT
JET.STD_HOURS

   let $JD_Acct_Cd = rtrim(&JET.ACCT_CD,' ')
   let #JED_Std_Hours = &JET.Std_Hours

   if #Job_Std_Hours = 0.0         !Work around potential division by zero.
      let #Job_Std_Hours = 1.0
      let #JED_Std_Hours = 0.0
   end-if

   if $JD_Acct_Cd <> ''
      evaluate $Gbl_Dist_Type
         when = 'A'
            let #Total_JED_Amt = #Total_JED_Amt + &JET.Comprate
            if &JET.Comprate <> 0.00
               let #Total_JED_Pct = #Total_JED_Pct
                            + (&JET.Comprate / #Out_Annual_Rt * 100.00)
            end-if
            break
         when = 'H'
            let #Total_JED_Pct = #Total_JED_Pct + #JED_Std_Hours * 100.00 / #Job_Std_Hours
            if #JED_Std_Hours <> 0.00
               let #Total_JED_Amt = #Total_JED_Amt
                            + (#JED_Std_Hours / #Job_Std_Hours * #Out_Annual_Rt)
            end-if
            break
         when = 'P'
            let #Total_JED_Pct = #Total_JED_Pct + &JET.DIST_PCT
            if &JET.DIST_PCT <> 0.00
               let #Total_JED_Amt = #Total_JED_Amt
                            + (&JET.DIST_PCT * #Out_Annual_Rt / 100)
            end-if
            break
      end-evaluate
   end-if

FROM PS_JOB_EARNS_DIST JET
WHERE JET.EMPLID    = $Gbl_Emplid
  AND JET.EMPL_RCD  = #Gbl_Empl_Rcd
  AND JET.EFFDT     = $Gbl_Effdt
  AND JET.EFFSEQ    = #Gbl_Effseq
end-SELECT

   if #Total_JED_Pct = 0
      let #Total_JED_Pct = 100
      let #Pct_Adjust_Factor = 1.0
   else
      if #Total_JED_Pct <> 100
         let #Pct_Adjust_Factor = 100 / #Total_JED_Pct
      else
         let #Pct_Adjust_Factor = 1.0
      end-if
   end-if

   if #Total_JED_Amt = 0
      let #Total_JED_Amt = #Out_Annual_Rt
      let #Amt_Adjust_Factor = 1.0
   else
      if #Total_JED_Amt <> #Out_Annual_Rt
         let #Amt_Adjust_Factor = #Out_Annual_Rt / #Total_JED_Amt
      else
         let #Amt_Adjust_Factor = 1.00
      end-if
   end-if

   let $err-statement1 = 'BUD010, SELECT, PS_JOB_EARNS_DIST, JOB-EARNS-DIST-FUNDING'

begin-SELECT on-error=Error-Display
JED.ACCT_CD
Sum(JED.COMPRATE) &JED.COMPRATE
Sum(JED.DIST_PCT) &JED.DIST_PCT
Sum(JED.STD_HOURS) &JED.STD_HOURS

   let $JD_Acct_Cd = rtrim(&JED.ACCT_CD,' ')
   let #JED_Std_Hours = &JED.Std_Hours

   if #Job_Std_Hours = 0.0         !Work around potential division by zero.
      let #Job_Std_Hours = 1.0
      let #JED_Std_Hours = 0.0
   end-if

   if $JD_Acct_Cd <> ''
      evaluate $Gbl_Dist_Type
         when = 'A'
            let #Out_Budget_Amt = &JED.Comprate
            let #Out_Budget_Dist = 0.0
            let $Out_Acct_Cd = rtrim(&JED.ACCT_CD,' ')
            let #Out_Budget_Seq = 1
            let $Out_Erncd = '   '
            break
         when = 'H'
            let #Out_Budget_Amt = 0
            let #Out_Budget_Dist = #JED_Std_Hours * 100.00 / #Job_Std_Hours
            let $Out_Acct_Cd = rtrim(&JED.ACCT_CD,' ')
            let #Out_Budget_Seq = 1
            let $Out_Erncd = '   '
            break
         when = 'P'
            let #Out_Budget_Amt = 0
            let #Out_Budget_Dist = &JED.DIST_PCT
            let $Out_Acct_Cd = rtrim(&JED.ACCT_CD,' ')
            let #Out_Budget_Seq = 1
            let $Out_Erncd = '   '
            break
      end-evaluate

      if #Out_Budget_Dist = 0.00 and #Out_Budget_Amt <> 0.00
         let #Out_Budget_Dist = #Out_Budget_Amt / #Out_Annual_Rt * 100.00
      end-if
      if (#Out_Budget_Dist <> 0.00 and #Out_Budget_Amt = 0.00)
         let #Out_Budget_Amt = #Out_Budget_Dist * #Out_Annual_Rt / 100.00
      end-if

      let #Out_Budget_Dist = #Out_Budget_Dist * #Pct_Adjust_Factor
      let #Out_Budget_Amt = #Out_Budget_Amt * #Amt_Adjust_Factor

      do OUTPUT-POSN-TABLES
      move 1 to #Gbl_Funding_Found

   end-if

FROM PS_JOB_EARNS_DIST JED
WHERE JED.EMPLID    = $Gbl_Emplid
  AND JED.EMPL_RCD  = #Gbl_Empl_Rcd
  AND JED.EFFDT     = $Gbl_Effdt
  AND JED.EFFSEQ    = #Gbl_Effseq
GROUP BY JED.ACCT_CD
end-SELECT

End-Procedure JOB-EARNS-DIST-FUNDING

!***********************************************************************
! Procedure: JOB-ACCT-CODE-FUNDING                                     *
! Descr:     Uses the Account Code specified on the JOB record, if     *
!            non-blank, as the funding source for this appointment.    *
!                                                                      *
! Called by: FIND-FUNDING-SOURCE                                       *
!***********************************************************************
Begin-Procedure JOB-ACCT-CODE-FUNDING

   if $Job_Acct_Cd <> ''
      let #Out_Budget_Amt = #Out_Annual_Rt
      let #Out_Budget_Dist = 100.0
      let $Out_Acct_Cd = $Job_Acct_Cd
      let #Out_Budget_Seq = 1
      let $Out_Erncd = '   '

      do OUTPUT-POSN-TABLES
      move 1 to #Gbl_Funding_Found

   end-if

End-Procedure JOB-ACCT-CODE-FUNDING

!***********************************************************************
! Procedure: BDGT-APPT-FUNDING                                         *
! Descr:     Searches the Department Budget tables for an appointment  *
!            level budget for this employee.                           *
!                                                                      *
! Called by: FIND-FUNDING-SOURCE                                       *
!***********************************************************************
Begin-Procedure BDGT-APPT-FUNDING

   let $Slct_Pool_ID       = ' '
   let $Slct_SetID_Jobcode = ' '
   let $Slct_Jobcode       = ' '
   let $Slct_Position_Nbr  = ' '
   let $Slct_Emplid        = $Gbl_EmplID
   let #Slct_Empl_Rcd      = #Gbl_Empl_Rcd

   move 'A' to $Process_Level_Indc

   do DEPT-BDGT-TOTALS

   do DEPT-BDGT-FUNDING

End-Procedure BDGT-APPT-FUNDING

!***********************************************************************
! Procedure: BDGT-POSN-FUNDING                                         *
! Descr:     Searches the Department Budget tables for an position     *
!            level budget for the position the employee is in.         *
!                                                                      *
! Called by: FIND-FUNDING-SOURCE                                       *
!***********************************************************************
Begin-Procedure BDGT-POSN-FUNDING

   let $Slct_Pool_ID       = ' '
   let $Slct_SetID_Jobcode = ' '
   let $Slct_Jobcode       = ' '
   let $Slct_Position_Nbr  = $Gbl_Position_Nbr
   let $Slct_Emplid        = ' '
   let #Slct_Empl_Rcd      = 0

   move 'P' to $Process_Level_Indc

   do DEPT-BDGT-TOTALS

   do DEPT-BDGT-FUNDING

End-Procedure BDGT-POSN-FUNDING

!***********************************************************************
! Procedure: BDGT-JOBCODE-FUNDING                                      *
! Descr:     Searches the Department Budget tables for an jobcode      *
!            level budget for this employee's position                 *
!                                                                      *
! Called by: FIND-FUNDING-SOURCE                                       *
!***********************************************************************
Begin-Procedure BDGT-JOBCODE-FUNDING

   let $Slct_Pool_ID       = ' '
   let $Slct_SetID_Jobcode = $Gbl_SetID_Jobcode
   let $Slct_Jobcode       = $Gbl_Jobcode
   let $Slct_Position_Nbr  = ' '
   let $Slct_Emplid        = ' '
   let #Slct_Empl_Rcd      = 0

   move 'J' to $Process_Level_Indc

   do DEPT-BDGT-TOTALS

   do DEPT-BDGT-FUNDING

End-Procedure BDGT-JOBCODE-FUNDING

!***********************************************************************
! Procedure: BDGT-POOL-FUNDING                                         *
! Descr:     Searches the Department Budget tables for an position     *
!            pool level budget for this employee's position            *
!                                                                      *
! Called by: FIND-FUNDING-SOURCE                                       *
!***********************************************************************
Begin-Procedure BDGT-POOL-FUNDING

   let $Slct_Pool_ID       = $Gbl_Pool_ID
   let $Slct_SetID_Jobcode = ' '
   let $Slct_Jobcode       = ' '
   let $Slct_Position_Nbr  = ' '
   let $Slct_Emplid        = ' '
   let #Slct_Empl_Rcd      = 0
   let $Dis_Fiscal_Year  = edit(#Prm_Fiscal_Year,'9999')

   move 'O' to $Process_Level_Indc

   do DEPT-BDGT-TOTALS

   do DEPT-BDGT-FUNDING

End-Procedure BDGT-POOL-FUNDING

!***********************************************************************
! Procedure: BDGT-DEPT-FUNDING                                         *
! Descr:     Searches the Department Budget tables for an overall      *
!            department level budget for the department in which this  *
!            employee works.                                           *
!                                                                      *
! Called by: FIND-FUNDING-SOURCE                                       *
!***********************************************************************
Begin-Procedure BDGT-DEPT-FUNDING

   let $Slct_Pool_ID       = ' '
   let $Slct_SetID_Jobcode = ' '
   let $Slct_Jobcode       = ' '
   let $Slct_Position_Nbr  = ' '
   let $Slct_Emplid        = ' '
   let #Slct_Empl_Rcd      = 0

   move 'D' to $Process_Level_Indc

   do DEPT-BDGT-TOTALS

   do DEPT-BDGT-FUNDING

End-Procedure BDGT-DEPT-FUNDING

!***********************************************************************
! Procedure: DEPT-BDGT-TOTALS                                          *
! Descr:     Searches the Department Budget tables and selects the     *
!            total of budget amounts and budget percentages for all    *
!            department budgets at the selected level with blank ERNCD *
!                                                                      *
! Called by: BDGT-APPT-FUNDING                                         *
!            BDGT-POSN-FUNDING                                         *
!            BDGT-JOBCODE-FUNDING                                      *
!            BDGT-POOL-FUNDING                                         *
!            BDGT-DEPT-FUNDING                                         *
!***********************************************************************
Begin-Procedure DEPT-BDGT-TOTALS

   let #Total_Budget_Amt = 0.0
   let #Total_Budget_Pct = 0.0
   let #Deflt_Budget_Pct = 0.0
   let #First_Dept_Budget = 1

   let $Dis_Empl_Rcd     = edit(#Slct_Empl_Rcd,'99')
   let $Dis_Fiscal_Year  = edit(#Prm_Fiscal_Year,'9999')

   let $err-statement1 = 'BUD010, SELECT, PS_DEPT_BUDGET_ERN, DEPT-BDGT-TOTALS'
   let $err-statement2 = 'Params: SETID=<' || $Gbl_SetID_Dept ||
                              '>, DEPTID=<' || $Gbl_DeptID ||
                              '>, FISCAL_YEAR=<' || $Dis_Fiscal_Year ||
                              '>, POOL_ID=<' || $Slct_Pool_ID ||
                              '>, SETID_JOBCODE=<' || $Slct_SetID_Jobcode ||
                              '>, JOBCODE=<' || $Slct_Jobcode ||
                              '>, POSITION_NBR=<' || $Slct_Position_Nbr ||
                              '>, EMPLID=<' || $Slct_Emplid ||
                              '>, EMPL_RCD=<' || $Dis_Empl_Rcd ||
                              '>, EFFDT=<' || $Prm_Effdt || '>'

Begin-SELECT on-error=Error-Display
DBGA.BUDGET_AMT
DBGA.DIST_PCT

   if #First_Dept_Budget
      do DERIVE-WORK-HEADCOUNT
      move 0 to #First_Dept_Budget
   end-if

   if &DBGA.DIST_PCT <> 0.00
      let #Total_Budget_Amt = #Total_Budget_Amt
                               + (&DBGA.DIST_PCT * #Out_Annual_Rt / 100)
      let #Total_Budget_Pct = #Total_Budget_Pct + &DBGA.DIST_PCT
   else
      let #Total_Budget_Amt = #Total_Budget_Amt + (&DBGA.BUDGET_AMT / #Wrk_Head_Count)
      if #Out_Annual_Rt
         let #Total_Budget_Pct = #Total_Budget_Pct + (&DBGA.BUDGET_AMT * 100.0
                               / #Wrk_Head_Count / #Out_Annual_Rt)
      end-if
   end-if

FROM PS_DEPT_BUDGET_ERN DBGA
   , PS_DEPT_BUDGET DBUD
WHERE DBGA.SETID = $Gbl_SetID_Dept
  AND DBUD.SETID = DBGA.SETID
  AND DBGA.DEPTID = $Gbl_DeptID
  AND DBUD.DEPTID = DBGA.DEPTID
  AND DBGA.FISCAL_YEAR = #Prm_Fiscal_Year
  AND DBUD.FISCAL_YEAR = DBGA.FISCAL_YEAR
  AND DBGA.POSITION_POOL_ID = $Slct_Pool_ID
  AND DBUD.POSITION_POOL_ID = DBGA.POSITION_POOL_ID
  AND DBGA.SETID_JOBCODE = $Slct_SetID_Jobcode
  AND DBUD.SETID_JOBCODE = DBGA.SETID_JOBCODE
  AND DBGA.JOBCODE   = $Slct_Jobcode
  AND DBUD.JOBCODE   = DBGA.JOBCODE
  AND DBGA.POSITION_NBR = $Slct_Position_Nbr
  AND DBUD.POSITION_NBR = DBGA.POSITION_NBR
  AND DBGA.EMPLID = $Slct_EmplID
  AND DBUD.EMPLID = DBGA.EMPLID
  AND DBGA.EMPL_RCD = #Slct_Empl_Rcd
  AND DBUD.EMPL_RCD = DBGA.EMPL_RCD
  AND DBUD.EFF_STATUS = 'A'
  AND DBUD.EFFDT = (SELECT MAX(DBUD1.EFFDT)
                      FROM PS_DEPT_BUDGET DBUD1
                      WHERE DBUD1.SETID = DBGA.SETID
                       AND DBUD1.DEPTID = DBGA.DEPTID
                       AND DBUD1.FISCAL_YEAR = DBGA.FISCAL_YEAR
                       AND DBUD1.POSITION_POOL_ID = DBGA.POSITION_POOL_ID
                       AND DBUD1.SETID_JOBCODE = DBGA.SETID_JOBCODE
                       AND DBUD1.JOBCODE   = DBGA.JOBCODE
                       AND DBUD1.POSITION_NBR = DBGA.POSITION_NBR
                       AND DBUD1.EMPLID = DBGA.EMPLID
                       AND DBUD1.EMPL_RCD = DBGA.EMPL_RCD
                       AND DBUD1.EFFDT <= $Prm_Effdt)
  AND DBUD.EFFSEQ = (SELECT MAX(DBUD2.EFFSEQ)                       !hpret
                      FROM PS_DEPT_BUDGET DBUD2                     !hpret
                      WHERE DBUD2.SETID = DBUD.SETID                !hpret
                       AND DBUD2.DEPTID = DBUD.DEPTID               !hpret
                       AND DBUD2.FISCAL_YEAR = DBUD.FISCAL_YEAR           !hpret
                       AND DBUD2.POSITION_POOL_ID = DBUD.POSITION_POOL_ID   !hpret
                       AND DBUD2.SETID_JOBCODE = DBUD.SETID_JOBCODE       !hpret
                       AND DBUD2.JOBCODE   = DBUD.JOBCODE           !hpret
                       AND DBUD2.POSITION_NBR = DBUD.POSITION_NBR   !hpret
                       AND DBUD2.EMPLID = DBUD.EMPLID               !hpret
                       AND DBUD2.EMPL_RCD = DBUD.EMPL_RCD           !hpret
                       AND DBUD2.EFFDT = DBUD.EFFDT)                !hpret
  AND DBGA.ERNCD = ' '
  AND DBGA.EFFDT = (SELECT MAX(DBG1.EFFDT)
                      FROM PS_DEPT_BUDGET_ERN DBG1
                     WHERE DBG1.SETID = DBGA.SETID
                       AND DBG1.DEPTID = DBGA.DEPTID
                       AND DBG1.FISCAL_YEAR = DBGA.FISCAL_YEAR
                       AND DBG1.POSITION_POOL_ID = DBGA.POSITION_POOL_ID
                       AND DBG1.SETID_JOBCODE = DBGA.SETID_JOBCODE
                       AND DBG1.JOBCODE   = DBGA.JOBCODE
                       AND DBG1.POSITION_NBR = DBGA.POSITION_NBR
                       AND DBG1.EMPLID = DBGA.EMPLID
                       AND DBG1.EMPL_RCD = DBGA.EMPL_RCD
                       AND DBG1.ERNCD = DBGA.ERNCD
                       AND DBG1.EFFDT <= $Prm_Effdt)
  AND DBGA.EFFSEQ = (SELECT MAX(DBG2.EFFSEQ)                        !hpret
                      FROM PS_DEPT_BUDGET_ERN DBG2                  !hpret
                     WHERE DBG2.SETID = DBGA.SETID                  !hpret
                       AND DBG2.DEPTID = DBGA.DEPTID                !hpret
                       AND DBG2.FISCAL_YEAR = DBGA.FISCAL_YEAR           !hpret
                       AND DBG2.POSITION_POOL_ID = DBGA.POSITION_POOL_ID    !hpret
                       AND DBG2.SETID_JOBCODE = DBGA.SETID_JOBCODE       !hpret
                       AND DBG2.JOBCODE   = DBGA.JOBCODE            !hpret
                       AND DBG2.POSITION_NBR = DBGA.POSITION_NBR    !hpret
                       AND DBG2.EMPLID = DBGA.EMPLID                !hpret
                       AND DBG2.EMPL_RCD = DBGA.EMPL_RCD            !hpret
                       AND DBG2.ERNCD = DBGA.ERNCD                  !hpret
                       AND DBG2.EFFDT = DBGA.EFFDT)                 !hpret
ORDER BY DBGA.BUDGET_AMT DESC, DBGA.DIST_PCT
end-SELECT

End-Procedure DEPT-BDGT-TOTALS

!***********************************************************************
! Procedure: DEPT-BDGT-FUNDING                                         *
! Descr:     Searches the Department Budget tables for an department   *
!            budget records at the selected level with blank ERNCD's   *
!            (i.e. "default" earnings budgets).                        *
!                                                                      *
! Called by: BDGT-APPT-FUNDING                                         *
!            BDGT-POSN-FUNDING                                         *
!            BDGT-JOBCODE-FUNDING                                      *
!            BDGT-POOL-FUNDING                                         *
!            BDGT-DEPT-FUNDING                                         *
!***********************************************************************
Begin-Procedure DEPT-BDGT-FUNDING

   if #Total_Budget_Pct = 0
      let #Total_Budget_Pct = 100
      let #Pct_Adjust_Factor = 1.0
   else
      if #Total_Budget_Pct <> 100
         let #Pct_Adjust_Factor = 100 / #Total_Budget_Pct
      else
         let #Pct_Adjust_Factor = 1.0
      end-if
   end-if

   if #Total_Budget_Amt = 0.00
      let #Total_Budget_Amt = #Out_Annual_Rt
      let #Amt_Adjust_Factor = 1.00
   else
      if #Total_Budget_Amt <> #Out_Annual_Rt
         let #Amt_Adjust_Factor = #Out_Annual_Rt / #Total_Budget_Amt
      else
         let #Amt_Adjust_Factor = 1.00
      end-if
   end-if

   let #Tally_Budget_Amt = #Out_Annual_Rt
   let #Tally_Budget_Pct = 100.00

   let $Dis_Empl_Rcd     = edit(#Slct_Empl_Rcd,'99')
   let $Dis_Fiscal_Year  = edit(#Prm_Fiscal_Year,'9999')

   let $err-statement1 = 'BUD010, SELECT, PS_DEPT_BUDGET_ERN, DEPT-BDGT-FUNDING'
   let $err-statement2 = 'Params: SETID=<' || $Gbl_SetID_Dept ||
                              '>, DEPTID=<' || $Gbl_DeptID ||
                              '>, FISCAL_YEAR=<' || $Dis_Fiscal_Year ||
                              '>, POOL_ID=<' || $Slct_Pool_ID ||
                              '>, SETID_JOBCODE=<' || $Slct_SetID_Jobcode ||
                              '>, JOBCODE=<' || $Slct_Jobcode ||
                              '>, POSITION_NBR=<' || $Slct_Position_Nbr ||
                              '>, EMPLID=<' || $Slct_Emplid ||
                              '>, EMPL_RCD=<' || $Dis_Empl_Rcd ||
                              '>, EFFDT=<' || $Prm_Effdt || '>'

Begin-SELECT on-error=Error-Display
DBGB.BUDGET_SEQ
DBGB.ACCT_CD
DBGB.BUDGET_AMT
DBGB.DIST_PCT

      let #Out_Budget_Seq = &DBGB.BUDGET_SEQ
      let $Out_Acct_Cd = &DBGB.ACCT_CD

      if &DBGB.DIST_PCT <> 0.00
         if &DBGB.DIST_PCT <> 100.00
            let #Out_Budget_Amt = &DBGB.DIST_PCT / 100
                                * #Out_Annual_Rt * #Pct_Adjust_Factor
            let #Out_Budget_Dist = &DBGB.DIST_PCT * #Pct_Adjust_Factor
         else
            let #Out_Budget_Amt = #Tally_Budget_Amt
            let #Out_Budget_Dist = #Tally_Budget_Pct
         end-if
      else
         let #Out_Budget_Amt = &DBGB.BUDGET_AMT * #Amt_Adjust_Factor / #Wrk_Head_Count
         if #Out_Annual_Rt
            let #Out_Budget_Dist = #Out_Budget_Amt / #Out_Annual_Rt * 100.00
         else
            let #Out_Budget_Dist = 0.00
         end-if
      end-if

      let #Tally_Budget_Amt = #Tally_Budget_Amt - #Out_Budget_Amt
      let #Tally_Budget_Pct = #Tally_Budget_Pct - #Out_Budget_Dist

      do OUTPUT-POSN-TABLES

      move 1 to #Gbl_Funding_Found

FROM PS_DEPT_BUDGET_ERN DBGB
   , PS_DEPT_BUDGET DBUDB
WHERE DBGB.SETID = $Gbl_SetID_Dept
  AND DBUDB.SETID = DBGB.SETID
  AND DBGB.DEPTID = $Gbl_DeptID
  AND DBUDB.DEPTID = DBGB.DEPTID
  AND DBGB.FISCAL_YEAR = #Prm_Fiscal_Year
  AND DBUDB.FISCAL_YEAR = DBGB.FISCAL_YEAR
  AND DBGB.POSITION_POOL_ID = $Slct_Pool_ID
  AND DBUDB.POSITION_POOL_ID = DBGB.POSITION_POOL_ID
  AND DBGB.SETID_JOBCODE = $Slct_SetID_Jobcode
  AND DBUDB.SETID_JOBCODE = DBGB.SETID_JOBCODE
  AND DBGB.JOBCODE   = $Slct_Jobcode
  AND DBUDB.JOBCODE   = DBGB.JOBCODE
  AND DBGB.POSITION_NBR = $Slct_Position_Nbr
  AND DBUDB.POSITION_NBR = DBGB.POSITION_NBR
  AND DBGB.EMPLID = $Slct_EmplID
  AND DBUDB.EMPLID = DBGB.EMPLID
  AND DBGB.EMPL_RCD = #Slct_Empl_Rcd
  AND DBUDB.EMPL_RCD = DBGB.EMPL_RCD
  AND DBUDB.EFF_STATUS = 'A'
  AND DBUDB.EFFDT = (SELECT MAX(DBUDB1.EFFDT)
                      FROM PS_DEPT_BUDGET DBUDB1
                      WHERE DBUDB1.SETID = DBGB.SETID
                       AND DBUDB1.DEPTID = DBGB.DEPTID
                       AND DBUDB1.FISCAL_YEAR = DBGB.FISCAL_YEAR
                       AND DBUDB1.POSITION_POOL_ID = DBGB.POSITION_POOL_ID
                       AND DBUDB1.SETID_JOBCODE = DBGB.SETID_JOBCODE
                       AND DBUDB1.JOBCODE   = DBGB.JOBCODE
                       AND DBUDB1.POSITION_NBR = DBGB.POSITION_NBR
                       AND DBUDB1.EMPLID = DBGB.EMPLID
                       AND DBUDB1.EMPL_RCD = DBGB.EMPL_RCD
                       AND DBUDB1.EFFDT <= $Prm_Effdt)
  AND DBUDB.EFFSEQ = (SELECT MAX(DBUDB2.EFFSEQ)                        !hpret
                      FROM PS_DEPT_BUDGET DBUDB2                       !hpret
                      WHERE DBUDB2.SETID = DBUDB.SETID                 !hpret
                       AND DBUDB2.DEPTID = DBUDB.DEPTID                !hpret
                       AND DBUDB2.FISCAL_YEAR = DBUDB.FISCAL_YEAR          !hpret
                       AND DBUDB2.POSITION_POOL_ID = DBUDB.POSITION_POOL_ID      !hpret
                       AND DBUDB2.SETID_JOBCODE = DBUDB.SETID_JOBCODE      !hpret
                       AND DBUDB2.JOBCODE   = DBUDB.JOBCODE            !hpret
                       AND DBUDB2.POSITION_NBR = DBUDB.POSITION_NBR    !hpret
                       AND DBUDB2.EMPLID = DBUDB.EMPLID                !hpret
                       AND DBUDB2.EMPL_RCD = DBUDB.EMPL_RCD            !hpret
                       AND DBUDB2.EFFDT <= DBUDB.EFFDT)                !hpret
  AND DBGB.ERNCD = ' '
  AND DBGB.EFFDT = (SELECT MAX(DBG2.EFFDT)
                      FROM PS_DEPT_BUDGET_ERN DBG2
                     WHERE DBG2.SETID = DBGB.SETID
                       AND DBG2.DEPTID = DBGB.DEPTID
                       AND DBG2.FISCAL_YEAR = DBGB.FISCAL_YEAR
                       AND DBG2.POSITION_POOL_ID = DBGB.POSITION_POOL_ID
                       AND DBG2.SETID_JOBCODE = DBGB.SETID_JOBCODE
                       AND DBG2.JOBCODE   = DBGB.JOBCODE
                       AND DBG2.POSITION_NBR = DBGB.POSITION_NBR
                       AND DBG2.EMPLID = DBGB.EMPLID
                       AND DBG2.EMPL_RCD = DBGB.EMPL_RCD
                       AND DBG2.ERNCD = DBGB.ERNCD
                       AND DBG2.EFFDT <= $Prm_Effdt)
  AND DBGB.EFFSEQ = (SELECT MAX(DBG3.EFFSEQ)                           !hpret
                     FROM PS_DEPT_BUDGET_ERN DBG3                      !hpret
                     WHERE DBG3.SETID = DBGB.SETID                     !hpret
                       AND DBG3.DEPTID = DBGB.DEPTID                   !hpret
                       AND DBG3.FISCAL_YEAR = DBGB.FISCAL_YEAR         !hpret
                       AND DBG3.POSITION_POOL_ID = DBGB.POSITION_POOL_ID     !hpret
                       AND DBG3.SETID_JOBCODE = DBGB.SETID_JOBCODE     !hpret
                       AND DBG3.JOBCODE   = DBGB.JOBCODE               !hpret
                       AND DBG3.POSITION_NBR = DBGB.POSITION_NBR       !hpret
                       AND DBG3.EMPLID = DBGB.EMPLID                   !hpret
                       AND DBG3.EMPL_RCD = DBGB.EMPL_RCD               !hpret
                       AND DBG3.ERNCD = DBGB.ERNCD                     !hpret
                       AND DBG3.EFFDT = DBGB.EFFDT)                    !hpret

ORDER BY DBGB.BUDGET_AMT DESC, DBGB.DIST_PCT
end-SELECT

End-Procedure DEPT-BDGT-FUNDING

!***********************************************************************
! Procedure: DERIVE-WORK-HEADCOUNT                                     *
! Descr:     Searches the Department Budget tables and selects the     *
!            total of budget amounts and budget percentages for all    *
!            department budgets at the selected level with blank ERNCD *
!                                                                      *
! Called by: DEPT-BDGT-TOTALS                                          *
!***********************************************************************
Begin-Procedure DERIVE-WORK-HEADCOUNT

   move 0 to #Excluded_Incumbents
   move 0 to #Wrk_Head_Count

   !  Check the value of $Process_Level_Indc.  This will establish which
   !  of the subordinate procedures will be called to accumulate salary
   !  amounts.

   evaluate $Process_Level_Indc
      when = 'A'
         do DERIVE-APPT-HEADCOUNT
         break
      when = 'P'
         do DERIVE-POSN-HEADCOUNT
         break
      when = 'O'
         do DERIVE-POOL-HEADCOUNT
         break
      when = 'J'
         do DERIVE-JOBCODE-HEADCOUNT
         break
      when = 'D'
         do DERIVE-DEPT-HEADCOUNT
         break
      when-other
         move 1 to #Wrk_Head_Count
         break
   end-evaluate

   if #Wrk_Head_Count = 0.00
      move 1 to #Wrk_Head_Count
   end-if

End-Procedure DERIVE-WORK-HEADCOUNT

!***********************************************************************
! Procedure: DERIVE-APPT-HEADCOUNT                                     *
! Descr:     Common module.  This procedure may be called individually *
!            for a single appointment, or within a loop for jobcode    *
!            or department total salaries.  The appointment salary is  *
!            obtained from the employee's most current job record.     *
!                                                                      *
! Called by: DERIVE-WORK-HEADCOUNT                                     *
!***********************************************************************
Begin-Procedure DERIVE-APPT-HEADCOUNT

   move 1 to #Wrk_Head_Count

End-Procedure DERIVE-APPT-HEADCOUNT

!***********************************************************************
! Procedure: DERIVE-POSN-HEADCOUNT                                     *
! Descr:     Common module.  This procedure may be called individually *
!            for a single position, or within a loop for department    *
!            or position pool total salaries.  The position salary     *
!            is set at the midpoint of the salary grade assigned to    *
!            the jobcode for the position.  This position salary is    *
!            multiplied by the headcount for the position, less any    *
!            filled headcount in jobcode or department budget calcs.   *
!                                                                      *
! Called by: DERIVE-WORK-HEADCOUNT                                     *
!***********************************************************************
Begin-Procedure DERIVE-POSN-HEADCOUNT

   move #Out_Max_Head_Count to #Wrk_Head_Count

End-Procedure DERIVE-POSN-HEADCOUNT

!***********************************************************************
! Procedure: DERIVE-POOL-HEADCOUNT                                     *
! Descr:     Common module.  This procedure is called individually for *
!            a single position pool.  It will loop through all the     *
!            positions in the pool, calling the SELECT-POSN-SALARY     *
!            module to fetch each salary grade midpoint in turn.       *
!                                                                      *
! Called by: DERIVE-WORK-HEADCOUNT                                     *
!***********************************************************************
Begin-Procedure DERIVE-POOL-HEADCOUNT

   let $err-statement1 = 'BUD010, SELECT, PS_POSITION_DATA, DERIVE-POOL-HEADCOUNT'
   let $err-statement2 = 'Params:EMPLID=<' || $Slct_DEPT ||
                         '>, EFFDT=<' || $Prm_Effdt || '>'

begin-SELECT on-error=Error-Display
POSC.POSITION_NBR

   move &POSC.POSITION_NBR to $Pool_Position_Nbr
   move 0 to #Excluded_Incumbents

   do SELECT-POSN-SALARY

FROM PS_POSITION_DATA POSC
WHERE POSC.POSITION_POOL_ID = $Slct_Position_Pool_ID
  AND POSC.EFFDT = (SELECT MAX(POS4.EFFDT)
                     FROM PS_POSITION_DATA POS4
                    WHERE POS4.POSITION_NBR = POSC.POSITION_NBR
                      AND POS4.EFFDT <= $Prm_Effdt)
  AND POSC.EFF_STATUS = 'A'
End-Select

End-Procedure DERIVE-POOL-HEADCOUNT

!***********************************************************************
! Procedure: SELECT-POSN-SALARY                                        *
! Descr:     Common module.  This procedure may be called individually *
!            for a single position, or within a loop for department    *
!            or position pool total salaries.  The position salary     *
!            is set at the midpoint of the salary grade assigned to    *
!            the jobcode for the position.  This position salary is    *
!            multiplied by the headcount for the position, less any    *
!            filled headcount in jobcode or department budget calcs.   *
!                                                                      *
! Called by: DERIVE-POOL-HEADCOUNT                                     *
!            DERIVE-JOBCODE-HEADCOUNT                                  *
!            DERIVE-DEPT-HEADCOUNT                                     *
!***********************************************************************
Begin-Procedure SELECT-POSN-SALARY

   let $err-statement1 = 'BUD010, SELECT, PS_POSITION_DATA, SELECT-POSN-SALARY'
   let $err-statement2 = 'Params:POSITION_NBR=<' || $Wrk_Position_Nbr ||
                         '>, EFFDT=<' || $Prm_Effdt || '>'

begin-SELECT on-error=Error-Display
POSD.MAX_HEAD_COUNT

   let #Computed_Head_Count = &POSD.MAX_HEAD_COUNT - #Excluded_Incumbents
   add #Computed_Head_Count to #Wrk_Head_Count

FROM PS_POSITION_DATA POSD
WHERE POSD.POSITION_NBR = $Wrk_Position_Nbr
  AND POSD.EFFDT = (SELECT MAX(POS5.EFFDT)
                     FROM PS_POSITION_DATA POS5
                    WHERE POS5.POSITION_NBR = POSD.POSITION_NBR
                      AND POS5.EFFDT <= $Prm_Effdt)
  AND POSD.EFF_STATUS = 'A'
End-Select

End-Procedure SELECT-POSN-SALARY

!***********************************************************************
! Procedure: DERIVE-JOBCODE-HEADCOUNT                                  *
! Descr:     Called module.  This procedure is called individually for *
!            a single jobcode.  It will loop first through all the     *
!            positions in the jobcode, calling the SELECT-POSN-SALARY  *
!            module to fetch each salary grade midpoint in turn, but   *
!            including only unfilled headcount. Then, it will loop     *
!            through all the PS_JOB records which are assigned to the  *
!            jobcode and compute the salary using DERIVE_APPT_SALARY.  *
!                                                                      *
! Called by: DERIVE-WORK-HEADCOUNT                                     *
!***********************************************************************
Begin-Procedure DERIVE-JOBCODE-HEADCOUNT

   let $err-statement1 = 'BUD010, SELECT, PS_POSITION_DATA, DERIVE-JOBCODE-HEADCOUNT'
   let $err-statement2 = 'Params:EMPLID=<' || $Slct_Jobcode ||
                         '>, EFFDT=<' || $Prm_Effdt || '>'

begin-SELECT on-error=Error-Display
POSE.POSITION_NBR

   move &POSE.POSITION_NBR to $Wrk_Position_Nbr

   do SELECT-FILLED-HEADCOUNT

   do SELECT-POSN-SALARY

FROM PS_POSITION_DATA POSE
WHERE POSE.JOBCODE = $Slct_Jobcode
  AND POSE.EFFDT = (SELECT MAX(POS6.EFFDT)
                     FROM PS_POSITION_DATA POS6
                    WHERE POS6.POSITION_NBR = POSE.POSITION_NBR
                      AND POS6.EFFDT <= $Prm_Effdt)
  AND POSE.EFF_STATUS = 'A'
End-SELECT

   let $err-statement1 = 'BUD010, SELECT, PS_JOB, DERIVE-JOBCODE-HEADCOUNT'
   let $err-statement2 = 'Params:JOBCODE=<' || $Slct_Jobcode ||
                         '>, EFFDT=<' || $Prm_Effdt || '>'

begin-SELECT on-error=Error-Display
JOBC.ANNUAL_RT

   add 1 to #Wrk_Head_Count

FROM PS_JOB JOBC
WHERE JOBC.JOBCODE   = $Slct_JOBCode
  AND JOBC.DEPTID    = $Gbl_DeptID
  AND JOBC.EMPL_STATUS IN ('A','P','L','S')
  AND JOBC.EFFDT     = (SELECT MAX(JOBC1.EFFDT)
                         FROM PS_JOB JOBC1
                        WHERE JOBC1.EMPLID    = JOBC.EMPLID
                          AND JOBC1.EMPL_RCD  = JOBC.EMPL_RCD
                          AND JOBC1.EFFDT    <= $Prm_Effdt)
  AND JOBC.EFFSEQ    = (SELECT MAX(JOBC2.EFFSEQ)
                         FROM PS_JOB JOBC2
                        WHERE JOBC2.EMPLID    = JOBC.EMPLID
                          AND JOBC2.EMPL_RCD  = JOBC.EMPL_RCD
                          AND JOBC2.EFFDT     = JOBC.EFFDT)
End-SELECT

End-Procedure DERIVE-JOBCODE-HEADCOUNT

!***********************************************************************
! Procedure: DERIVE-DEPT-HEADCOUNT                                     *
! Descr:     Called module.  This procedure is called individually for *
!            a single department  It will loop through all positions   *
!            in the department, calling the SELECT-POSN-SALARY module  *
!            to fetch each salary grade midpoint in turn, but          *
!            including only unfilled headcount. Then, it will loop     *
!            through all the PS_JOB records which are assigned to the  *
!            department and compute salary using DERIVE_APPT_SALARY.   *
!                                                                      *
! Called by: DERIVE-WORK-HEADCOUNT                                     *
!***********************************************************************
Begin-Procedure DERIVE-DEPT-HEADCOUNT

   let $err-statement1 = 'BUD010, SELECT, PS_POSITION_DATA, DERIVE-DEPT-HEADCOUNT'
   let $err-statement2 = 'Params:DEPTID=<' || $Gbl_DeptID ||
                         '>, EFFDT=<' || $Prm_Effdt || '>'

begin-SELECT on-error=Error-Display
POSF.POSITION_NBR

   move &POSF.POSITION_NBR to $Wrk_Position_Nbr

   do SELECT-FILLED-HEADCOUNT

   do SELECT-POSN-SALARY

FROM PS_POSITION_DATA POSF
WHERE POSF.DEPTID = $Gbl_DeptID
  AND POSF.EFFDT = (SELECT MAX(POS7.EFFDT)
                     FROM PS_POSITION_DATA POS7
                    WHERE POS7.POSITION_NBR = POSF.POSITION_NBR
                      AND POS7.EFFDT <= $Prm_Effdt)
  AND POSF.EFF_STATUS = 'A'
End-SELECT

   let $err-statement1 = 'BUD010, SELECT, PS_JOB, DERIVE-DEPT-HEADCOUNT'
   let $err-statement2 = 'Params:DEPTID=<' || $Gbl_DeptID ||
                         '>, EFFDT=<' || $Prm_Effdt || '>'

begin-SELECT on-error=Error-Display
JOBD.ANNUAL_RT

   add 1 to #Wrk_Head_Count

FROM PS_JOB JOBD
WHERE JOBD.DEPTID    = $Gbl_DeptID
  AND JOBD.EMPL_STATUS IN ('A','P','L','S')
  AND JOBD.EFFDT     = (SELECT MAX(JOBD1.EFFDT)
                         FROM PS_JOB JOBD1
                        WHERE JOBD1.EMPLID    = JOBD.EMPLID
                          AND JOBD1.EMPL_RCD  = JOBD.EMPL_RCD
                          AND JOBD1.EFFDT    <= $Prm_Effdt)
  AND JOBD.EFFSEQ    = (SELECT MAX(JOBD2.EFFSEQ)
                         FROM PS_JOB JOBD2
                        WHERE JOBD2.EMPLID    = JOBD.EMPLID
                          AND JOBD2.EMPL_RCD  = JOBD.EMPL_RCD
                          AND JOBD2.EFFDT     = JOBD.EFFDT)
End-SELECT

End-Procedure DERIVE-DEPT-HEADCOUNT

!***********************************************************************
! Procedure: SELECT-FILLED-HEADCOUNT                                   *
! Descr:     Called module.  This procedure is called individually for *
!            a single position number.  It selects a count from the    *
!            PS_JOB table of all active employees assigned to that     *
!            position.  This is used to exclude filled positions for   *
!            JOBCode and department salary totals to avoid double-     *
!            counting position salary amounts                          *
!                                                                      *
! Called by: DERIVE-JOBCODE-HEADCOUNT                                  *
!            DERIVE-DEPT-HEADCOUNT                                     *
!***********************************************************************
Begin-Procedure SELECT-FILLED-HEADCOUNT

   move 0 to #Excluded_Incumbents

   let $err-statement1 = 'BUD010, SELECT, PS_JOB, SELECT-FILLED-HEADCOUNT'
   let $err-statement2 = 'Params:POSITION_NBR=<' || $Wrk_Position_Nbr ||
                         '>, EFFDT=<' || $Prm_Effdt || '>'

begin-SELECT on-error=Error-Display
JOBE.EMPLID

   add 1 to #Excluded_Incumbents

FROM PS_JOB JOBE
WHERE JOBE.EMPL_STATUS IN ('A','P','L','S')
  AND JOBE.POSITION_NBR = $Wrk_Position_Nbr
  AND JOBE.EFFDT = (SELECT MAX(JOBE1.EFFDT)
                      FROM PS_JOB JOBE1
                     WHERE JOBE1.EMPLID = JOBE.EMPLID
                       AND JOBE1.EMPL_RCD = JOBE.EMPL_RCD
                       AND JOBE1.EFFDT <= $Prm_Effdt)
  AND JOBE.EFFSEQ = (SELECT MAX(JOBE2.EFFSEQ)
                    FROM PS_JOB JOBE2
                   WHERE JOBE2.EMPLID = JOBE.EMPLID
                     AND JOBE2.EMPL_RCD = JOBE.EMPL_RCD
                     AND JOBE2.EFFDT = JOBE.EFFDT)
End-SELECT

End-Procedure SELECT-FILLED-HEADCOUNT

!***********************************************************************
! Procedure: OUTPUT-POSN-TABLES                                        *
! Descr:     Writes output data to a temporary table for sorting and   *
!            conversion to ASCII file.                                 *
!                                                                      *
! Called by: PROCESS-BUDGETS PROCEDURE.                                *
!***********************************************************************
begin-procedure OUTPUT-POSN-TABLES

   let #Valid_Output = 1

   let $Out_Acct_Cd  = nvl($Out_Acct_Cd,' ')
   let $Out_ErnCd    = nvl($Out_ErnCd,' ')

   do FETCH-CHART-FIELDS

   let $Out_Business_Unit_GL = rtrim($Out_Business_Unit_GL,' ')
   let $Out_Name             = rtrim($Out_Name,' ')
   let $Out_Descr            = rtrim($Out_Descr,' ')
   let $Out_SetID_Dept       = rtrim($Out_SetID_Dept,' ')
   let $Out_SetID_Jobcode    = rtrim($Out_SetID_Jobcode,' ')

   let $Out_Business_Unit_GL = nvl($Out_Business_Unit_GL,' ')
   let $Out_Name             = nvl($Out_Name,' ')
   let $Out_Descr            = nvl($Out_Descr,' ')
   let $Out_SetID_Dept       = nvl($Out_SetID_Dept,' ')
   let $Out_SetID_Jobcode    = nvl($Out_SetID_Jobcode,' ')

   let $Out_Statistics_Code  = ' '

!* Check if valid BU and if there are Position Budgeting
!* Options setup for the SETID the BU is mapped to as defined in TableSet Controls

   if #Valid_Output
      do VALIDATE-GL-BU
   end-if

!* If no Currency Code is given at all, default the output row Currency Code to the
!* Base Currency Value.

   if #Valid_Output and $Out_Currency_Cd = ' ' and #Currency_Cd_Found
      let $WarningMessage = 'Currency Code not found. Defaulted to Base Currency of '
                            || $Base_Currency_Cd
      do PRINT-WARNING-ROW
      let $Out_Currency_Cd = $Base_Currency_Cd
   end-if

!Each row can have different CurrencyCode even though they have same BU.
!Check to see if matches Base Currency for the BU.

   if #Valid_Output
      if $Out_Currency_Cd <> $Base_Currency_Cd
         let #Valid_Output = 0
!        move #EmplRcd to $EmplRcd 888
         let $ErrorMessage = 'Currency Code not equal to GL BU Base Curr.'
         do PRINT-ERROR-ROW
      end-if
   end-if

!Process this row if the following is valid

   if #Valid_Output
      do INIT-POSN-DATA-ROW
      do PROCESS-OUTPUT-DATA
   end-if

end-procedure OUTPUT-POSN-TABLES

!***********************************************************************
! Procedure: FETCH-CHART-FIELDS                                        *
! Descr:     Using the output Account ID, this procedure fetches the   *
!            most current set of corresponding chart fields.           *
!                                                                      *
! Called by: OUTPUT-POSN-TABLES                                        *
!***********************************************************************
Begin-Procedure FETCH-CHART-FIELDS

   move 0 to #Account_Cd_Found

   let $err-statement1 = 'BUD010, SELECT, PS_ACCT_CD_TBL, FETCH-CHART-FIELDS'
   let $err-statement2 = 'Params: ACCT_CD=<' || $Out_Acct_Cd ||
                              '>, EFFDT=<' || $Out_Effdt || '>'

Begin-SELECT on-error=Error-Display
ACT.ACCT_CD
ACT.ACCOUNT
ACT.DEPTID_CF
ACT.PROJECT_ID
ACT.PRODUCT
ACT.FUND_CODE
ACT.PROGRAM_CODE
ACT.CLASS_FLD
ACT.AFFILIATE
ACT.OPERATING_UNIT
ACT.ALTACCT
ACT.BUDGET_REF
ACT.CHARTFIELD1
ACT.CHARTFIELD2
ACT.CHARTFIELD3
ACT.AFFILIATE_INTRA1
ACT.AFFILIATE_INTRA2

   move 1 to #Account_Cd_Found

   move &ACT.ACCT_CD             to $Out_Acct_Cd
   move &ACT.ACCOUNT             to $Out_Account
   move &ACT.DEPTID_CF           to $Out_Deptid
   move &ACT.PROJECT_ID          to $Out_Project_ID
   move &ACT.PRODUCT             to $Out_Product
   move &ACT.FUND_CODE           to $Out_Fund_Code
   move &ACT.PROGRAM_CODE        to $Out_Program_Code
   move &ACT.CLASS_FLD           to $Out_Class_Fld
   move &ACT.AFFILIATE           to $Out_Affiliate
   move &ACT.OPERATING_UNIT      to $Out_Operating_Unit
   move &ACT.ALTACCT             to $Out_AltAcct
   move ' '                      to $Out_Budget_Ref
   move ' '                      to $Out_Chartfield1
   move ' '                      to $Out_Chartfield2
   move ' '                      to $Out_Chartfield3
   move ' '                      to $Out_Affiliate_intra1
   move ' '                      to $Out_Affiliate_intra2
   move ' '                      to $Out_GL_SetID

   move ' '                      to $Out_Business_Unit_PC
   move ' '                      to $Out_Activity_ID
   move ' '                      to $Out_Resource_Type
   move ' '                      to $Out_Budget_Period


FROM PS_ACCT_CD_TBL ACT
WHERE ACT.ACCT_CD = $Out_Acct_Cd
End-SELECT

   if not #Account_Cd_Found
      let #Valid_Output = 0
      let $ErrorMessage = 'Chart field Data not found for Acct Code '
                          || $Out_Acct_Cd
      do PRINT-ERROR-ROW
   end-if


End-Procedure FETCH-CHART-FIELDS

!***********************************************************************
! Procedure: VALIDATE-GL-BU                                            *
! Descr:     Validate the Output General Ledger BU against the HRMS    *
!            copy of BUS_UNIT_TBL_GL and fetch Currency Code if found  *
!                                                                      *
! Called by: OUTPUT-POSN-TABLES                                        *
!***********************************************************************
begin-procedure VALIDATE-GL-BU

   move 0 to #Currency_Cd_Found

   let $err-statement1 = 'BUD010, SELECT, PS_BUS_UNIT_TBL_GL, VALIDATE-GL-BU'
   let $err-statement2 = 'Params: BUSINESS_UNIT=<' || $Out_Business_Unit_GL ||
                              '>, EFFDT=<' || $Out_Effdt || '>'

Begin-SELECT on-error=Error-Display
VBU.BASE_CURRENCY

   move 1 to #Currency_Cd_Found
   let $Base_Currency_Cd = rtrim(&VBU.BASE_CURRENCY,' ')
   let $Base_Currency_Cd = nvl($Base_Currency_Cd,' ')

FROM PS_BUS_UNIT_TBL_GL VBU
WHERE VBU.BUSINESS_UNIT = $Out_Business_Unit_GL
AND VBU.AS_OF_DATE = (SELECT MAX (VBU1.AS_OF_DATE)
                        FROM PS_BUS_UNIT_TBL_GL VBU1
                       WHERE VBU1.BUSINESS_UNIT = VBU.BUSINESS_UNIT
                         AND VBU1.AS_OF_DATE <= $Out_Effdt)
End-SELECT

   if #Currency_Cd_Found
      if $Base_Currency_Cd = ' '
         let $WarningMessage = 'Base Currency for BU not found. Defaulted to USD.'
         do PRINT-WARNING-ROW
         move 'USD' to $Base_Currency_Cd
      end-if
   else
      let $ErrorMessage = 'GL Business Unit is invalid or missing.'
      do PRINT-ERROR-ROW
      let #Valid_Output = 0
   end-if

end-procedure !VALIDATE-GL-BU

!***********************************************************************
! Procedure: INIT-POSN-DATA-ROW                                        *
! Descr:     Checks output fields for null values.  If found, a single *
!            blank is inserted.  Also formats numeric fields in char.  *
!            format where they are required for concatenation.         *
!                                                                      *
! Called by: OUTPUT-POSN-TABLES                                        *
!***********************************************************************
begin-procedure INIT-POSN-DATA-ROW

   let $Out_Business_Unit     = nvl($Out_Business_Unit,' ')
   let $Out_Position_Nbr      = nvl($Out_Position_Nbr,' ')
   let $Out_EmplID            = nvl($Out_EmplID,' ')
   let $Out_Effdt             = nvl($Out_Effdt,' ')
   let $Out_Action            = nvl($Out_Action,' ')
   let $Out_Action_Reason     = nvl($Out_Action_Reason,' ')
   let $Out_Name              = nvl($Out_Name,' ')
   let $Out_Empl_Status       = nvl($Out_Empl_Status,' ')
   let $Out_Scenario          = nvl($Out_Scenario,' ')
   let $Out_Descr             = nvl($Out_Descr,' ')
   let $Out_Posn_Status       = nvl($Out_Posn_Status,' ')
   let $Out_Currency_Cd       = nvl($Out_Currency_Cd,' ')
   let $Out_Business_Unit_GL  = nvl($Out_Business_Unit_GL,' ')
   let $Out_Setid_Jobcode     = nvl($Out_Setid_Jobcode,' ')
   let $Out_Jobcode           = nvl($Out_Jobcode,' ')
   let $Out_Location          = nvl($Out_Location,' ')
   let $Out_Reg_Temp          = nvl($Out_Reg_Temp,' ')
   let $Out_Full_Part_Time    = nvl($Out_Full_Part_Time,' ')
   let $Out_Sal_Admin_Plan    = nvl($Out_Sal_Admin_Plan,' ')
   let $Out_Grade             = nvl($Out_Grade,' ')
   let $Out_Setid_Dept        = nvl($Out_Setid_Dept,' ')
   let $Out_DeptID_From       = nvl($Out_DeptID_From,' ')
   let $Out_Acct_Cd           = nvl($Out_Acct_Cd,' ')
   let $Out_Ledger            = nvl($Prm_Ledger,' ')
   let $Out_Account           = nvl($Out_Account,' ')
   let $Out_Altacct           = nvl($Out_Altacct,' ')
   let $Out_Operating_Unit    = nvl($Out_Operating_Unit,' ')
   let $Out_DeptID            = nvl($Out_DeptID,' ')
   let $Out_Product           = nvl($Out_Product,' ')
   let $Out_Business_Unit_PC  = nvl($Out_Business_Unit_PC,' ')
   let $Out_Project_ID        = nvl($Out_Project_ID,' ')
   let $Out_Affiliate         = nvl($Out_Affiliate,' ')
   let $Out_Activity_ID       = nvl($Out_Activity_ID,' ')
   let $Out_Resource_Type     = nvl($Out_Resource_Type,' ')
   let $Out_Fund_Code         = nvl($Out_Fund_Code,' ')
   let $Out_Program_Code      = nvl($Out_Program_Code,' ')
   let $Out_Class_Fld         = nvl($Out_Class_Fld,' ')
   let $Out_Budget_Period     = nvl($Out_Budget_Period,' ')


   let $Out_Empl_Rcd          = edit(#Out_Empl_Rcd,'999')
   let $Out_EffSeq            = edit(#Out_EffSeq,'999')

   if $New_BD_Position_Nbr = 'Y'
      let #BD_Position_Nbr    = (to_number($BD_Position_Nbr)) + 1
      let $BD_Position_Nbr    = edit(#BD_Position_Nbr,'00000000')
      move 'N' to $New_BD_Position_Nbr
   end-if

end-procedure !INIT-POSN-DATA-ROW

!***********************************************************************
! Procedure: PROCESS-OUTPUT-DATA                                       *
! Descr:     Checks values of incoming key fields.  Prepares and       *
!            inserts table data for all three output tables.           *
!                                                                      *
! Called by: OUTPUT-POSN-TABLES                                        *
!***********************************************************************
begin-procedure PROCESS-OUTPUT-DATA

   !** If BU or BD_Position_Nbr has changed, write all three records
   !**   and reset the key values.

   if $Prev_Business_Unit_GL <> $Out_Business_Unit_GL
   or $Prev_BD_Position_Nbr  <> $BD_Position_Nbr

      let #InsertOut_Effseq = 0
      let #Out_BD_Seq_Nbr = 1

      do INSERT-BD-POSITION
      do INSERT-BD-JOB
      do INSERT-BD-DISTR

   else
      !** Same BU & Position_Nbr.
      !**   Create a BD_JOB_TBL and associated BD_DISTR_TBL row(s)

      if $Prev_EmplID    <> $Out_EmplID
      or #Prev_Empl_Rcd  <> #Out_Empl_Rcd
      or $Prev_Effdt     <> $Out_Effdt
      or #Prev_Effseq    <> #Out_EffSeq

         !** If the Effective Seq. Nbr has changed, increment the Output
         !**   Effective Seq.  If not, then set Output Effective Seq to 0.

         if  $Prev_EmplID    = $Out_EmplID
         and #Prev_Empl_Rcd  = #Out_Empl_Rcd
         and $Prev_Effdt     = $Out_Effdt

            let #InsertOut_Effseq = #InsertOut_Effseq + 1
            let #Out_BD_Seq_Nbr = 1
         else

            let #InsertOut_Effseq = 0
            let #Out_BD_Seq_Nbr = 1
         end-if

         do INSERT-BD-JOB
         do INSERT-BD-DISTR

      else
         !** All Position and Job keys are identical.
         !**   Increment Budgets Key Seq field and write a BD_DISTR_TBL row.

         add 1 to #Out_BD_Seq_Nbr
         do INSERT-BD-DISTR

      end-if
   end-if

   let $Prev_Business_Unit_GL = $Out_Business_Unit_GL
   let $Prev_BD_Position_Nbr  = $BD_Position_Nbr
   let $Prev_EmplID           = $Out_EmplID
   let #Prev_Empl_Rcd         = #Out_Empl_Rcd
   let $Prev_Effdt            = $Out_Effdt
   let #Prev_Effseq           = #Out_EffSeq

end-procedure !PROCESS-OUTPUT-DATA

!***********************************************************************
! Procedure: INSERT-BD-POSITION                                        *
! Descr:     Inserts a row into BD_POSITION_TBL.                       *
!                                                                      *
! Called by: PROCESS-OUTPUT-DATA                                       *
!***********************************************************************
begin-procedure INSERT-BD-POSITION

   let $err-statement1 = 'BUD010, INSERT, PS_BD_POSITION_TBL, INSERT-BD-POSITION'
   let $err-statement2 = 'Params: BUSINESS_UNIT=<' || $Out_Business_Unit_GL ||
                              '>, POSITION_NBR=<' || $BD_POSITION_NBR ||
                              '>, EMPLID =<' || $Out_EmplID || '>'

begin-sql ON-ERROR=Error-Display
INSERT INTO PS_BD_POSITION_TBL (
  BUSINESS_UNIT
, POSITION_NBR
, DESCR
, POSN_STATUS
, HEADCOUNT
, BUSINESS_UNIT_HR
, POSITION_NBR_HR
, SPREADTYPE
, SPREAD_TEMPLATE
, EXISTING_POSN_FLG
, BD_UPDATE_FLAG )
VALUES(
  $Out_Business_Unit_GL
, $BD_POSITION_NBR
, $Out_Descr
, $Out_Posn_Status
, #Out_Max_Head_Count
, $Out_Business_Unit
, $Out_Position_Nbr
, #Out_Spreadtype
, $Out_Spread_Template
, $Out_Existing_Posn_Flg
, $Out_BD_Update_Flag )
end-sql

end-procedure !INSERT-BD-POSITION

!***********************************************************************
! Procedure: INSERT-BD-JOB                                             *
! Descr:     Inserts a row into BD_JOB_TBL.                            *
!                                                                      *
! Called by: PROCESS-OUTPUT-DATA                                       *
!***********************************************************************
begin-procedure INSERT-BD-JOB


   let $Dis_Empl_Rcd   = edit(#Out_Empl_Rcd,'99')
   let $Dis_EffSeq     = edit(#InsertOut_Effseq,'99')

   let $err-statement1 = 'BUD010, INSERT, PS_BD_JOB_TBL, INSERT-BD-JOB'
   let $err-statement2 = 'Params: BUSINESS_UNIT=<' || $Out_Business_Unit_GL ||
                              '>, POSITION_NBR=<' || $BD_POSITION_NBR ||
                              '>, EMPLID=<' || $Out_EmplID ||
                              '>, EMPL_RCD=<' || $Dis_Empl_Rcd ||
                              '>, EFFDT=<' || $Out_Effdt ||
                              '>, SEQ_NBR=<' || $Dis_EffSeq || '>'

begin-sql ON-ERROR=Error-Display
INSERT INTO PS_BD_JOB_TBL (
  BUSINESS_UNIT
, POSITION_NBR
, EMPLID
, EMPL_RCD
, EFFDT
, EFFSEQ
, EMPL_STATUS
, NAME
, ACTION
, JOBCODE
, REASON_CD
, LOCATION
, STD_HOURS
, FTE
, REG_TEMP
, FULL_PART_TIME
, ANNUAL_SALARY
, CURRENCY_CD
, SAL_ADMIN_PLAN
, GRADE
, STEP
, BD_UPDATE_FLAG )
VALUES(
  $Out_Business_Unit_GL
, $BD_POSITION_NBR
, $Out_EmplID
, #Out_Empl_Rcd
, $Out_Effdt
, #InsertOut_Effseq
, $Out_Empl_Status
, $Out_Name
, $Out_Action
, $Out_JobCode
, $Out_Action_Reason
, $Out_Location
, #Out_Std_Hours
, #Out_FTE
, $Out_Reg_Temp
, $Out_Full_Part_Time
, #Out_Annual_Rt
, $Out_Currency_Cd
, $Out_Sal_Admin_Plan
, $Out_Grade
, #Out_Step
, $Out_BD_Update_Flag  )
end-sql

end-procedure !INSERT-BD-JOB

!***********************************************************************
! Procedure: INSERT-BD-DISTR                                           *
! Descr:     Inserts a row into BD_DISTR_TBL.                          *
!                                                                      *
! Called by: PROCESS-OUTPUT-DATA                                       *
!***********************************************************************
begin-procedure INSERT-BD-DISTR

   let $Out_Ledger            = $Prm_Ledger
   let $Out_Compensation_Ind  = 'S'
   let $Out_Plan_Type         = ' '

   let $Dis_Empl_Rcd          = edit(#Out_Empl_Rcd,'999')
   let $Dis_EffSeq            = edit(#InsertOut_Effseq,'999')
   let $Dis_BD_Seq_Nbr        = edit(#Out_BD_Seq_Nbr,'999')

   let $err-statement1 = 'BUD010, INSERT, PS_BD_DISTR_TBL, INSERT-BD-DISTR'
   let $err-statement2 = 'Params: BUSINESS_UNIT=<' || $Out_Business_Unit_GL ||
                              '>, POSITION_NBR=<' || $BD_POSITION_NBR ||
                              '>, EMPLID=<' || $Out_EmplID ||
                              '>, EMPL_RCD=<' || $Dis_Empl_Rcd ||
                              '>, EFFDT=<' || $Out_Effdt ||
                              '>, SEQ_NBR=<' || $Dis_EffSeq ||
                              '>, COMPENSATION_IND=<' || $Out_Compensation_Ind ||
                              '>, BD_SEQ_NBR=<' || $Dis_BD_Seq_Nbr || '>'

begin-sql ON-ERROR=Error-Display
INSERT INTO PS_BD_DISTR_TBL (
  BUSINESS_UNIT
, POSITION_NBR
, EMPLID
, EMPL_RCD
, EFFDT
, EFFSEQ
, COMPENSATION_IND
, BD_SEQ_NBR
, ACCOUNT
, ALTACCT
, OPERATING_UNIT
, DEPTID
, PRODUCT
, BUSINESS_UNIT_PC
, PROJECT_ID
, AFFILIATE
, ACTIVITY_ID
, RESOURCE_TYPE
, FUND_CODE
, PROGRAM_CODE
, CLASS_FLD
, BUDGET_REF
, CHARTFIELD1
, CHARTFIELD2
, CHARTFIELD3
, AFFILIATE_INTRA1
, AFFILIATE_INTRA2
, BUDGET_PERIOD
, PERCENTAGE
, AMOUNT
, PLAN_TYPE
, CURRENCY_CD
, BD_UPDATE_FLAG )
VALUES (
  $Out_Business_Unit_GL
, $BD_POSITION_NBR
, $Out_EmplID
, #Out_Empl_Rcd
, $Out_Effdt
, #InsertOut_Effseq
, $Out_Compensation_Ind
, #Out_BD_Seq_Nbr
, $Out_Account
, $Out_Altacct
, $Out_Operating_Unit
, $Out_DeptID
, $Out_Product
, $Out_Business_Unit_PC      !**   Not on ACCT_CD_TBL
, $Out_Project_ID
, $Out_Affiliate
, $Out_Activity_ID           !**   Not on ACCT_CD_TBL
, $Out_Resource_Type         !**   Not on ACCT_CD_TBL
, $Out_Fund_Code
, $Out_Program_Code
, $Out_Class_Fld
, $Out_Budget_Ref
, $Out_Chartfield1
, $Out_Chartfield2
, $Out_Chartfield3
, $Out_Affiliate_intra1
, $Out_Affiliate_intra2
, $Out_Budget_Period
, #Out_Budget_Dist
, #Out_Budget_Amt
, $Out_Plan_Type
, $Out_Currency_Cd
, $Out_BD_Update_Flag )
end-sql

end-procedure !INSERT-BD-DISTR

!***********************************************************************
! Procedure: MAINLINE_JOBCODES                                         *
! Descr:     Loads data from the HRMS Jobcode table to the Budgets     *
!            interface jobcode table ZBD_JOBCODE_TBL                   *
!                                                                      *
! Called by: WRITE-REPORT                                              *
!***********************************************************************
begin-procedure MAINLINE-JOBCODES

   !** Establish default values for BD_JOBCODE_TBL fields which are not
   !**   carried on the HRMS Jobcodes table.

   let $Out_Dflt_Sal_Val    = ' '
   let $Out_Dflt_Override   = ' '
   let $Out_User_Overid_Flg = ' '
   let $Out_Pos_Bnft_Optn   = 'V'
   let $Out_Dflt_Bnft_Val   = ' '
   let $Out_Bnft_Mult       = ' '
   let $Out_Dflt_Bnft_Ovrd  = ' '
   let #Out_Dflt_Bnft_Amt   = 0
   let #Out_Dflt_Bnft_Pct   = 0
   let $Out_User_Bnft_Ovrd  = ' '

   let $err-statement1 = 'BUD010, SELECT, PS_JOBCODE_TBL, MAINLINE-JOBCODES'
   let $err-statement2 = 'Params:EFF_STATUS=<' || 'A' || '>'

begin-SELECT on-error=Error-Display
MJC.SETID
MJC.JOBCODE
MJC.EFFDT
MJC.EFF_STATUS
MJC.DESCR
MJC.SAL_ADMIN_PLAN
MJC.GRADE
MJC.STEP
MJC.CURRENCY_CD
MJC.STD_HOURS
MJC.STD_HRS_FREQUENCY
MJC.REG_TEMP
MJC.SURVEY_SALARY

   do INSERT-ZBD-JOBCODE

FROM PS_JOBCODE_TBL MJC
WHERE MJC.EFF_STATUS = 'A'
  AND MJC.EFFDT = (SELECT MAX(MJC1.EFFDT)
                     FROM PS_JOBCODE_TBL MJC1
                    WHERE MJC1.SETID = MJC.SETID
                      AND MJC1.JOBCODE = MJC.JOBCODE
                      AND MJC1.EFFDT <= $Prm_Effdt)
end-SELECT

end-procedure MAINLINE-JOBCODES

!***********************************************************************
! Procedure: INSERT-ZBD-JOBCODE                                        *
! Descr:     Inserts a row into ZBD_JOBCODE_TBL.                       *
!                                                                      *
! Called by: MAINLINE-JOBCODES                                         *
!***********************************************************************
begin-procedure INSERT-ZBD-JOBCODE

   let $err-statement1 = 'BUD010, INSERT, PS_ZBD_JOBCODE_TBL, INSERT-ZBD-JOBCODE'
   let $err-statement2 = 'Params: SETID=<' || &MJC.SETID ||
                              '>, JOBCODE=<' || &MJC.JOBCODE ||
                              '>, EFFDT =<' || &MJC.EFFDT || '>'

begin-sql ON-ERROR=Error-Display
INSERT INTO PS_ZBD_JOBCODE_TBL (
  SETID
, JOBCODE
, EFFDT
, EFF_STATUS
, DESCR
, SAL_ADMIN_PLAN
, GRADE
, STEP
, CURRENCY_CD
, STD_HOURS
, STD_HRS_FREQUENCY
, REG_TEMP
, BD_DFLT_SAL_VAL
, BD_DFLT_OVERRIDE
, SURVEY_SALARY
, BD_USER_OVERID_FLG
, BD_POS_BNFT_OPTN
, BD_DFLT_BNFT_VAL
, BD_BNFT_MULT
, BD_DFLT_BNFT_OVRD
, BD_DFLT_BNFT_AMT
, BD_DFLT_BNFT_PCT
, BD_USER_BNFT_OVRD  )
VALUES(
  &MJC.SETID
, &MJC.JOBCODE
, &MJC.EFFDT
, &MJC.EFF_STATUS
, &MJC.DESCR
, &MJC.SAL_ADMIN_PLAN
, &MJC.GRADE
, &MJC.STEP
, &MJC.CURRENCY_CD
, &MJC.STD_HOURS
, &MJC.STD_HRS_FREQUENCY
, &MJC.REG_TEMP
, $Out_Dflt_Sal_Val
, $Out_Dflt_Override
, &MJC.SURVEY_SALARY
, $Out_User_Overid_Flg
, $Out_Pos_Bnft_Optn
, $Out_Dflt_Bnft_Val
, $Out_Bnft_Mult
, $Out_Dflt_Bnft_Ovrd
, #Out_Dflt_Bnft_Amt
, #Out_Dflt_Bnft_Pct
, $Out_User_Bnft_Ovrd  )
end-sql

end-procedure !INSERT-ZBD-JOBCODE

!***********************************************************************
! Procedure: PROCESS-TRANSACTION                                       *
! Descr:     Handles starting and committing database transactions     *
!                                                                      *
! Called by: OUTPUT-POSN-TABLES                                        *
!***********************************************************************
begin-procedure PROCESS-TRANSACTION

   if #Commit_Cnt >= #Gbl_Commit_After
      do Commit-Transaction
      let #Commit_cnt = 1
   else
      add 1 to #commit-cnt
   end-if

end-procedure PROCESS-TRANSACTION

!***********************************************************************
! Procedure: WRAPUP                                                    *
! Descr:     This paragraph ends the report process and updates the    *
!            status of the job in the process scheduler                *
!                                                                      *
! Called by: BEGIN-REPORT                                              *
!***********************************************************************
Begin-Procedure WRAPUP

   do Commit-Transaction
   do Reset
   do Successful-EOJ

End-Procedure WRAPUP

!***********************************************************************
! SQCs                                                                 *
!***********************************************************************
#include 'reset.sqc'     !Reset printer procedure
#include 'curdttim.sqc'  !Get-Current-DateTime procedure
#include 'datetime.sqc'  !Routines for date and time formatting
#include 'number.sqc'    !Routines to format numbers
#include 'stderror.sqc'  !Routines to display error output
#Include 'stdapi.sqc'    !Routines to Update Run Status
#include 'btrnctl1.sqc'  !Get Variables entered through Process Scheduler
#include 'btgetval.sqc'  !Formats run control parameters.
#Include 'tranctrl.sqc'  !Transaction control (commits, etc.)
#include 'datemath.sqc'
#include 'askaod.sqc'
#include 'getactrs.sqc'
#include 'getdptnm.sqc'
