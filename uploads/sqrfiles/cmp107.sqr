!***********************************************
!  CMP107:  Load Auto Salary Step Increments   *
!***********************************************
!***********************************************************************
!                                                                      *
!               Confidentiality Information:                           *
!                                                                      *
!                                                                      *
! This module contains confidential and proprietary information        *
! of Oracle; it is not to be copied, reproduced, or transmitted        *
! in any form, by any means, in whole or in part, nor is it to         *
! be used for any purpose other than that for which it is              *
! expressly provided under the applicable license agreement.           *
!                                                                      *
! Copyright (C) 2006 Oracle. All Rights Reserved.                      *
!                                                                      *
!***********************************************************************
!***********************************************************************
!                                                                      *
!          $Date:  2006/10/08:22:06:22                                 !
!       $Release:  HR9                                                 !
!      $Revision:  102                                                 !
!                                                                      *
!***********************************************************************
! This program is specific to HRMS for Public Sector.                  *
!***********************************************************************

#include 'setenv.sqc'    !Set environment
#Include 'setup32.sqc'   !Printer and page-size initialization

begin-report

  do Init-DateTime
  do Init-Number
  move 'CMP107' to $ReportID
  do Get-Current-DateTime
  do Get-Calendar-Year-Id
  do Init-Report
  display $ReportTitle
  do Plan-Grade
  do Reset
  do Stdapi-Term

end-report

!***********************************************************************
! Procedure: Begin-Heading                                             *
! Descr:     Produces report title and columns for report              *
!                                                                      *                                                                      *
! Called by:                                                           *
!***********************************************************************
begin-heading 7

  #Include 'stdhdgtr.sqc'                                             !F-LPARKER-125 (CAMI)
  print $Process_Type                    (-1) Center                  !F-LPARKER-125 (CAMI)
  print $CMP107_EMPLOYEE                 (+3,1)                       !F-LPARKER-125 (CAMI)
  print $CMP107_EMP_NAME                 (0, 11)                      !F-LPARKER-125 (CAMI)
  print $CMP107_STATUS                   (0,34)                       !F-LPARKER-125 (CAMI)
  print $CMP107_PLAN_GRADE               (0,41)                       !F-LPARKER-125 (CAMI)
  print $CMP107_PREV                     (0,53)                       !F-LPARKER-125 (CAMI)
  print $CMP107_EFF                      (0,59)                       !F-LPARKER-125 (CAMI)
  print $CMP107_PREV                     (0,65)                       !F-LPARKER-125 (CAMI)
  print $CMP107_PREV                     (0,81)                       !F-LPARKER-125 (CAMI)
  print $CMP107_RATE                     (0,87)                       !F-LPARKER-125 (CAMI)
  print $CMP107_NEW                      (0,93)                       !F-LPARKER-125 (CAMI)
  print $CMP107_EFF                      (0,98)                       !F-LPARKER-125 (CAMI)
  print $CMP107_NEW                      (0,106)                      !F-LPARKER-125 (CAMI)
  print $CMP107_NEW                      (0,122)                      !F-LPARKER-125 (CAMI)
  print $CMP107_RATE                     (0,127)                      !F-LPARKER-125 (CAMI)
  print $CMP107_MESSAGES                 (0,138)                      !F-LPARKER-125 (CAMI)
  print $CMP107_ID                       (+1,1)                       !F-LPARKER-125 (CAMI)
  print $CMP107_DATE                     (0,53)                       !F-LPARKER-125 (CAMI)
  print $CMP107_STEP                     (0,65)                       !F-LPARKER-125 (CAMI)
  print $CMP107_DATE                     (0,93)                       !F-LPARKER-125 (CAMI)
  print $CMP107_STEP                     (0,105)                      !F-LPARKER-125 (CAMI)

end-heading


!***********************************************************************
! F-LPARKER-125 (CAMI)                                                 *
! Read language-dependent text from the database using CMP107 program  *
! ids.                                                                 *
!***********************************************************************
begin-procedure REPORT-TRANSLATION

  let $language_cd = $PRCS_LANGUAGE_CD
  do Init_Report_Translation($ReportID,$Language_Cd)

  do Get_Field_Information ('CMP107', 'DATE',          $CMP107_DATE,        #DW)
  do Get_Field_Information ('CMP107', 'EFF',           $CMP107_EFF,         #DW)
  do Get_Field_Information ('CMP107', 'EMPLOYEE',      $CMP107_EMPLOYEE,    #DW)
  do Get_Field_Information ('CMP107', 'EMPLOYEE_NAME', $CMP107_EMP_NAME,    #DW)
  do Get_Field_Information ('CMP107', 'ERROR_NO_STEP', $CMP107_ERR_NO_STEP, #DW)
  do Get_Field_Information ('CMP107', 'ERROR_OVERFLOW',$CMP107_ERR_OVERFLOW,#DW)
  do Get_Field_Information ('CMP107', 'ERROR_STEP_MAX',$CMP107_ERR_STEP_MAX,#DW)
  do Get_Field_Information ('CMP107', 'ID',            $CMP107_ID,          #DW)
  do Get_Field_Information ('CMP107', 'MESSAGES',      $CMP107_MESSAGES,    #DW)
  do Get_Field_Information ('CMP107', 'NEW',           $CMP107_NEW,         #DW)
  do Get_Field_Information ('CMP107', 'PLAN_GRADE',    $CMP107_PLAN_GRADE,  #DW)
  do Get_Field_Information ('CMP107', 'OVERFLOW1',     $CMP107_OVERFLOW1,   #DW)
  do Get_Field_Information ('CMP107', 'OVERFLOW2',     $CMP107_OVERFLOW2,   #DW)
  do Get_Field_Information ('CMP107', 'PREV',          $CMP107_PREV,        #DW)
  do Get_Field_Information ('CMP107', 'PROC_TYPE1',    $CMP107_PROC_TYPE1,  #DW)
  do Get_Field_Information ('CMP107', 'PROC_TYPE2',    $CMP107_PROC_TYPE2,  #DW)
  do Get_Field_Information ('CMP107', 'RATE',          $CMP107_RATE,        #DW)
  do Get_Field_Information ('CMP107', 'REPORT_TITLE',  $REPORTTITLE,        #DW)
  do Get_Field_Information ('CMP107', 'STATUS',        $CMP107_STATUS,      #DW)
  do Get_Field_Information ('CMP107', 'STEP',          $CMP107_STEP,        #DW)

end-procedure

!***********************************************************************
! Procedure: INIT_REPORT                                               *
! Descr:     Creates the arrays and obtains all necessary values       *
!            necessary for producing the report. Arrays are created    *
!            for salary step and related compensations                 *
!                                                                      *
! Called by: MAIN PROGRAM                                              *
!***********************************************************************
begin-procedure Init-Report

  do Stdapi-Init

  if $prcs_process_instance = ''
     do Ask-Salary-Step-Increments
  else
     do Select-Parameters
  end-if

  create-array name=StepData size=15  field=sd_step:number
                                      field=sd_hourly_rt:number
                                      field=sd_daily_rt:number
                                      field=sd_monthly_rt:number
                                      field=sd_annual_rt:number
                                      field=sd_increm_months:number
                                      field=sd_increm_hours:number
                                      field=sd_comp_begin_idx:number
                                      field=sd_comp_end_idx:number
                                      field=sd_currency_cd:char

  create-array name=StepComp size=150 field=sc_comp_effseq:number
                                      field=sc_comp_ratecd:char
                                      field=sc_currency_cd:char
                                      field=sc_comp_frequency:char
                                      field=sc_hourly_rt:number
                                      field=sc_monthly_rt:number
                                      field=sc_annual_rt:number
                                      field=sc_comp_rate_points:number
                                      field=sc_comp_pct:number
                                      field=sc_rate_code_group:char
                                      field=sc_comprate:number
                                      field=sc_daily_rt:number
                                      field=rc_comp_rate_type:char
                                      field=rc_comp_base_pay_sw:char

  create-array name=CompArray size=50 field=cp_effseq:number
                                      field=cp_comp_effseq:number
                                      field=cp_comp_ratecd:char
                                      field=cp_comp_rate_points:number
                                      field=cp_comprate:number
                                      field=cp_comp_pct:number
                                      field=cp_comp_frequency:char
                                      field=cp_currency_cd:char
                                      field=cp_manual_sw:char
                                      field=cp_convert_comprt:number
                                      field=cp_rate_code_group:char
                                      field=cp_fte_indicator:char
                                      field=cp_cmp_src_ind:char
                                      field=cp_rate_code_class:char

  create-array name=Month_Array size=12 field=Days:Number
  put 31 into Month_Array(00) Days  !January
  put 28 into Month_Array(01) Days  !February (not leap year)
  put 31 into Month_Array(02) Days  !March
  put 30 into Month_Array(03) Days  !April
  put 31 into Month_Array(04) Days  !May
  put 30 into Month_Array(05) Days  !June
  put 31 into Month_Array(06) Days  !July
  put 31 into Month_Array(07) Days  !August
  put 30 into Month_Array(08) Days  !September
  put 31 into Month_Array(09) Days  !October
  put 30 into Month_Array(10) Days  !November
  put 31 into Month_Array(11) Days  !December

  do REPORT-TRANSLATION                                               !F-LPARKER-125 (CAMI)

  ! The following was moved from Get-Values.                          !F-LPARKER-125 (CAMI)
  if $Process = 'Y'                           !PUBSEC
     let $Process_Type = $CMP107_PROC_TYPE1   !PUBSEC                 !F-LPARKER-125 (CAMI)
  else                                        !PUBSEC
     let $Process_Type = $CMP107_PROC_TYPE2   !PUBSEC                 !F-LPARKER-125 (CAMI)
  end-if                                      !PUBSEC

end-procedure

!***********************************************************************
! Procedure: GET-VALUES                                                *
! Descr:     Get Parameters for report                                 *
!                                                                      *
! Called by: COMMON                                                    *
!***********************************************************************
begin-procedure Get-Values

  do Get-CMP107-Parameters
  move $Effdt to $New_Job_Effdt
  do Format-DateTime($StartDt, $StartDt, {DEFCMP}, '', '')                     !PUBSEC
  do Format-DateTime($EndDt, $EndDt,  {DEFCMP}, '', '')                        !PUBSEC

end-procedure

!***********************************************************************
! Procedure: PLAN-GRADE                                                *
! Descr:     For the Grade specified to be processed get the steps     *
!            and rate components for that grade, process employees     *
!            whose job rates are for that grade and qualify for a step *
!            increase.                                                 *
!                                                                      *
! Called by: MAIN-PROGRAM                                              *
!***********************************************************************
begin-procedure Plan-Grade

begin-SELECT
Z.SAL_ADMIN_PLAN
Z.GRADE
Z.EFFDT
Z.STEP_INCREM_TYPE
Z.STEP_INCREM_ACCUM

  do Get-Steps
  do Process-Emps
  next-listing skiplines = 1                                                   !PUBSEC

FROM  PS_SAL_GRADE_TBL Z
WHERE Z.SETID = $SET                                                           !PUBSEC
 AND Z.SAL_ADMIN_PLAN = $SalPlan
 AND Z.GRADE [$Grade_Parm]
 AND Z.EFFDT = (SELECT MAX(EFFDT)
                FROM PS_SAL_GRADE_TBL
               WHERE SETID          = Z.SETID                                  !PUBSEC
                 AND SAL_ADMIN_PLAN = Z.SAL_ADMIN_PLAN
                 AND GRADE          = Z.GRADE)
  AND Z.STEP_INCREM_TYPE <> 'M'
  AND Z.STEP_INCREM_TYPE <> ' '                                                !PUBSEC
ORDER BY Z.GRADE
end-SELECT

end-procedure

!***********************************************************************
! Procedure: GET-STEPS                                                 *
! Descr:     For the Grade specified to be processed get the steps     *
!            and rate components for that grade, store them in arrays  *
!            for later searches and processing                         *
!            increase.                                                 *
!                                                                      *
! Called by: PLAN-GRADE                                                *
!***********************************************************************
begin-procedure Get-Steps

  move 0 to #idx
  move 0 to #SC_idx

begin-SELECT
Y.STEP
Y.HOURLY_RT
Y.DAILY_RT
Y.MONTHLY_RT
Y.ANNUAL_RT
Y.INCREM_MONTHS
Y.INCREM_HOURS
Y.CURRENCY_CD

  if #idx < 15
    PUT &Y.STEP          INTO stepdata(#idx) sd_step
    PUT &Y.HOURLY_RT     INTO stepdata(#idx) sd_hourly_rt
    PUT &Y.DAILY_RT      INTO stepdata(#idx) sd_daily_rt
    PUT &Y.MONTHLY_RT    INTO stepdata(#idx) sd_monthly_rt
    PUT &Y.ANNUAL_RT     INTO stepdata(#idx) sd_annual_rt
    PUT &Y.INCREM_MONTHS INTO stepdata(#idx) sd_increm_months
    PUT &Y.INCREM_HOURS  INTO stepdata(#idx) sd_increm_hours
    PUT &Y.CURRENCY_CD   INTO stepdata(#idx) sd_currency_cd

    do GET-COMPONENTS

    put #save_comp_begin INTO stepdata(#idx) sd_comp_begin_idx
    put #save_comp_end   INTO stepdata(#idx) sd_comp_end_idx

    add 1 to #idx
  else
    display $CMP107_ERR_OVERFLOW                                      !F-LPARKER-125 (CAMI)
  end-if
  let #Max-Step = &Y.Step

FROM  PS_SAL_STEP_TBL Y
WHERE Y.SETID          = $SET                         !PUBSEC
AND   Y.SAL_ADMIN_PLAN = &Z.Sal_Admin_Plan
AND   Y.GRADE          = &Z.Grade
AND   Y.EFFDT          = &Z.EffDt
ORDER BY Y.STEP ASC
end-SELECT

end-procedure

!***********************************************************************
! Procedure: GET-COMPONENTS                                            *
! Descr:     Reads application table for all pay components which      *
!            comprise the current pay step for the employee.  Reads    *
!            database table PS_SAL_RATECD_TBL.                         *
!                                                                      *
! Called by: GET-STEPS                                                 *
!***********************************************************************
begin-procedure GET-COMPONENTS

   move 'Y' to $First_Pass_Sw

begin-SELECT
SC.COMP_EFFSEQ
SC.COMP_RATECD
SC.CURRENCY_CD
SC.COMP_FREQUENCY
SC.HOURLY_RT
SC.MONTHLY_RT
SC.ANNUAL_RT
SC.COMP_RATE_POINTS
SC.COMP_PCT
SC.RATE_CODE_GROUP
SC.COMPRATE
SC.DAILY_RT
RC.COMP_RATE_TYPE
RC.COMP_BASE_PAY_SW

  if #SC_idx < 150

      if $First_Pass_Sw ='Y'
         move #SC_idx to #save_comp_begin
         move 'N' to $First_Pass_Sw
      end-if

      put &SC.COMP_EFFSEQ      INTO stepcomp(#SC_idx) sc_Comp_Effseq
      put &SC.COMP_RATECD      INTO stepcomp(#SC_idx) sc_Comp_Ratecd
      put &SC.CURRENCY_CD      INTO stepcomp(#SC_idx) sc_Currency_cd
      put &SC.COMP_FREQUENCY   INTO stepcomp(#SC_idx) sc_Comp_Frequency
      put &SC.HOURLY_RT        INTO stepcomp(#SC_idx) sc_Hourly_Rt
      put &SC.MONTHLY_RT       INTO stepcomp(#SC_idx) sc_Monthly_Rt
      put &SC.ANNUAL_RT        INTO stepcomp(#SC_idx) sc_Annual_Rt
      put &SC.COMP_RATE_POINTS INTO stepcomp(#SC_idx) sc_Comp_Rate_Points
      put &SC.COMP_PCT         INTO stepcomp(#SC_idx) sc_Comp_Pct
      put &SC.RATE_CODE_GROUP  INTO stepcomp(#SC_idx) sc_Rate_Code_Group
      put &SC.COMPRATE         INTO stepcomp(#SC_idx) sc_Comprate
      put &SC.DAILY_RT         INTO stepcomp(#SC_idx) sc_Daily_Rt
      put &RC.COMP_RATE_TYPE   INTO stepcomp(#SC_idx) rc_comp_rate_type
      put &RC.COMP_BASE_PAY_SW INTO stepcomp(#SC_idx) rc_comp_base_pay_sw

      move #SC_idx to #save_comp_end

      add 1 to #SC_idx
   else
       display $CMP107_OVERFLOW1                                      !F-LPARKER-125 (CAMI)
       display $CMP107_OVERFLOW2                                      !F-LPARKER-125 (CAMI)
!      display '*** Array overflow; limited to 150 compensation ratecodes ***'
!      display '***    for a single salary grade.                         ***'
   end-if

FROM  PS_SAL_RATECD_TBL SC
    , PS_COMP_RATECD_TBL RC
WHERE SC.SETID          = $SET                         !PUBSEC
AND   SC.SAL_ADMIN_PLAN = &Z.SAL_ADMIN_PLAN
AND   SC.GRADE          = &Z.GRADE
AND   SC.EFFDT          = &Z.EFFDT
AND   SC.STEP           = &Y.STEP
AND   RC.COMP_RATECD    = SC.COMP_RATECD
AND   RC.EFFDT          = (SELECT MAX (EFFDT)
                             FROM PS_COMP_RATECD_TBL RC1
                             WHERE RC1.COMP_RATECD = SC.COMP_RATECD AND
                             EFFDT <= &Z.EFFDT)
ORDER BY SC.COMP_EFFSEQ DESC, SC.COMP_RATECD ASC
end-SELECT

   if $First_Pass_sw = 'Y'
      move 1 to #save_comp_begin
      move 0 to #save_comp_end
   end-if

end-procedure !GET-COMPONENTS

!***********************************************************************
! Procedure: PROCESS-EMPS                                              *
! Descr:     For the Grade specified find all employees whose job is   *
!            defined as been in the specified grade. This procedure    *
!            determines if the job compensation is within the range to *
!            to qualify for a step increase.                           *
! *Only process employees who are within $0.01 of the Hourly rate, or  *
!*                                within $0.10 of the Daily rate, or   *
!*                                within $1.00 of the Monthly Rate, or *
!*                                within $1.00 of the Annual Rate      *
!                                                                      *
! Called by: PLAN_GRADE                                                *
!***********************************************************************
begin-procedure PROCESS-EMPS

  let #Prev-Step = 999

begin-SELECT
A.EMPLID
A.EMPL_RCD
A.EFFDT
A.EFFSEQ
A.PER_ORG
A.DEPTID
A.JOBCODE
A.POSITION_NBR
A.HR_STATUS
A.APPT_TYPE
A.MAIN_APPT_NUM_JPN
A.POSITION_OVERRIDE
A.POSN_CHANGE_RECORD
A.EMPL_STATUS
A.ACTION
A.ACTION_DT
A.ACTION_REASON
A.LOCATION
A.TAX_LOCATION_CD
A.JOB_ENTRY_DT
A.DEPT_ENTRY_DT
A.POSITION_ENTRY_DT
A.SHIFT
A.REG_TEMP
A.FULL_PART_TIME
A.COMPANY
A.PAYGROUP
A.BAS_GROUP_ID
A.ELIG_CONFIG1
A.ELIG_CONFIG2
A.ELIG_CONFIG3
A.ELIG_CONFIG4
A.ELIG_CONFIG5
A.ELIG_CONFIG6
A.ELIG_CONFIG7
A.ELIG_CONFIG8
A.ELIG_CONFIG9
A.BEN_STATUS
A.BAS_ACTION
A.COBRA_ACTION
A.EMPL_TYPE
A.HOLIDAY_SCHEDULE
A.STD_HOURS
A.STD_HRS_FREQUENCY
A.OFFICER_CD
A.EMPL_CLASS
A.SAL_ADMIN_PLAN
A.GRADE
A.GRADE_ENTRY_DT
A.STEP
A.STEP_ENTRY_DT
A.GL_PAY_TYPE
A.ACCT_CD
A.EARNS_DIST_TYPE
A.COMP_FREQUENCY
A.COMPRATE
A.CHANGE_AMT
A.CHANGE_PCT
A.ANNUAL_RT
A.MONTHLY_RT
A.DAILY_RT
A.HOURLY_RT
A.ANNL_BENEF_BASE_RT
A.SHIFT_RT
A.SHIFT_FACTOR
A.CURRENCY_CD
A.BUSINESS_UNIT
A.SETID_DEPT
A.SETID_JOBCODE
A.SETID_LOCATION
A.SETID_SALARY
A.REG_REGION
A.DIRECTLY_TIPPED
A.FLSA_STATUS
A.EEO_CLASS
A.FUNCTION_CD
A.TARIFF_GER
A.TARIFF_AREA_GER
A.PERFORM_GROUP_GER
A.LABOR_TYPE_GER
A.SPK_COMM_ID_GER
A.HOURLY_RT_FRA
A.ACCDNT_CD_FRA
A.VALUE_1_FRA
A.VALUE_2_FRA
A.VALUE_3_FRA
A.VALUE_4_FRA
A.VALUE_5_FRA
A.CTG_RATE
A.PAID_HOURS
A.PAID_FTE
A.PAID_HRS_FREQUENCY
A.UNION_FULL_PART
A.UNION_POS
A.MATRICULA_NBR
A.SOC_SEC_RISK_CODE
A.UNION_FEE_AMOUNT
A.UNION_FEE_START_DT
A.UNION_FEE_END_DT
A.EXEMPT_JOB_LBR
A.EXEMPT_HOURS_MONTH
A.WRKS_CNCL_FUNCTION
A.INTERCTR_WRKS_CNCL
A.CURRENCY_CD1
A.PAY_UNION_FEE
A.UNION_CD
A.BARG_UNIT
A.UNION_SENIORITY_DT
A.ENTRY_DATE
A.LABOR_AGREEMENT
A.EMPL_CTG
A.EMPL_CTG_L1
A.EMPL_CTG_L2
A.SETID_LBR_AGRMNT
A.GP_PAYGROUP
A.GP_DFLT_ELIG_GRP
A.GP_ELIG_GRP
A.GP_DFLT_CURRTTYP
A.CUR_RT_TYPE
A.GP_DFLT_EXRTDT
A.GP_ASOF_DT_EXG_RT
A.ADDS_TO_FTE_ACTUAL
A.CLASS_INDC
A.ENCUMB_OVERRIDE
A.FICA_STATUS_EE
A.FTE
A.PRORATE_CNT_AMT
A.PAY_SYSTEM_FLG
A.BORDER_WALKER
A.LUMP_SUM_PAY
A.CONTRACT_NUM
A.JOB_INDICATOR
A.WRKS_CNCL_ROLE_CHE
A.BENEFIT_SYSTEM
A.WORK_DAY_HOURS
A.SUPERVISOR_ID
A.REPORTS_TO
A.FORCE_PUBLISH
A.JOB_DATA_SRC_CD
A.ESTABID
A.HIRE_DT
A.LAST_HIRE_DT
A.TERMINATION_DT
A.ASGN_START_DT
A.LST_ASGN_START_DT
A.ASGN_END_DT
A.LDW_OVR
A.LAST_DATE_WORKED
A.EXPECTED_RETURN_DT
A.EXPECTED_END_DATE
A.AUTO_END_FLG
A.POI_TYPE
A.ABSENCE_SYSTEM_CD
A.SETID_SUPV_LVL
A.SUPV_LVL_ID
A.LAYOFF_EXEMPT_RSN
A.LAYOFF_EXEMPT_FLAG
A.LABOR_FACILITY_ID
A.WPP_STOP_FLAG
B.NAME
P.COUNTRY
F.FREQUENCY_TYPE

   !if &A.STEP <> #Prev_Step
      let $Step_Found = 'N'
      do FIND-STEP

   !   let #Prev_Step  = &A.STEP
   !end-if

   if $Step_Found = 'Y'

   !* Retrieve the PS_COMPENSATION records for the current job record.  For all
   !*   "base pay" rows (i.e. RATE_CODE_CLASS not in ('SENPAY', 'EDUPAY', 'GRPPAY')
   !*   and MANUAL_SW <> 'Y') use the parameters in the StepComp array to calc
   !*   annual, monthly, daily, and hourly rates of pay.

      move 'Y' to $Base_Only_Sw

      do GET-BASE-COMPENSATION

   !* Only process employees who are within $0.01 of the Hourly rate, or
   !*                                within $0.10 of the Daily rate, or
   !*                                within $1.00 of the Monthly Rate, or
   !*                                within $1.00 of the Annual Rate
   !*  of their current step.


      let #Adj_Hourly_Rt  = #Job_Hourly_Rt                                  !PUBSEC
      let #Adj_Daily_Rt   = #Job_Daily_Rt                                   !PUBSEC
      let #Adj_Monthly_Rt = #Job_Monthly_Rt                                 !PUBSEC
      let #Adj_Annual_Rt  = #Job_Annual_Rt                                  !PUBSEC
      move &A.Position_Entry_Dt to $Pos_Entry_Dt

      ! *** To qualify for step increase hourly, daily, annual, or monthly rate must
      ! *** be within cents, dollars or tens of dollars
      if (#Adj_Hourly_Rt  >= #Low_Hr_Rt and #Adj_Hourly_Rt  <= #High_Hr_Rt)    !PUBSEC
      or (#Adj_Daily_Rt   >= #Low_Dy_Rt and #Adj_Daily_Rt   <= #High_Dy_Rt)    !PUBSEC
      or (#Adj_Monthly_Rt >= #Low_Mn_Rt and #Adj_Monthly_Rt <= #High_Mn_Rt)    !PUBSEC
      or (#Adj_Annual_Rt  >= #Low_An_Rt and #Adj_Annual_Rt  <= #High_An_Rt)    !PUBSEC

         move 'N' to $Elig_For_Increm_Date
         move 'N' to $Elig_For_Increm_Hours

         if &Z.Step_Increm_Type = 'D' or &Z.Step_Increm_Type = 'E'
            do CHECK-DATE-ELIG

            !***** This message is really useful if you do not know why people are not qualifying for increase
            !if $elig_for_increm_date = 'N'
            !      let $error-msg = 'Not eligible based on Increm Date'
            !      do write-report
            !      let $error_msg = ' '
            !end-if
         end-if

         if $Elig_For_Increm_Date = 'N' and
            (&Z.Step_Increm_Type = 'H' or &Z.Step_Increm_Type = 'E')
            do CHECK-HOURS-ELIG

            !***** This message is really useful if you do not know why people are not qualifying for increase
            !if $elig_for_increm_hours = 'N'
            !      let $error-msg = 'Not eligible based on Increm Hours'
            !      do write-report
            !      let $error_msg = ' '
            !end-if
         end-if


         if $Elig_For_Increm_Date = 'Y' or $Elig_for_Increm_Hours = 'Y'
            if &A.STEP <> #Max-Step                        !PUBSEC Message for max step
               do Calc-New-Rates

               ! ****** Write Summary or rates to be applied
               let $Error-Msg = ' '
               do Write-Report

               if $Process = 'Y'          ! 'Y' = Report & Process Increases       PUBSEC

                  !   ******  Insert New Job Record with new Rates for new STEP
                  do Insert-New-Job-Rec   ! 'N' = Report Only                      PUBSEC

                  !   ******  Insert New Job Junior Row associated with New Job Row
                  do Proc-Job-Junior

                  !   ******  Insert New Compensation Components for JOB ************
                  !   ******  Compensation Components derived directly from RATECD set up for new GRADE/STEP *********
                  do Determine-New-Compensations                                   !PUBSEC

                  do Proc-Job-Erns-Dist
                  if $Error-Msg = ' '
                     if $Elig_for_Increm_Hours = 'Y'
                        do Reset-Accum-Hours
                     end-if
                     do Check-Audits
                     do Update-Empl-Increase-Dt
                  end-if
               end-if
            else
               let $Error-Msg = $CMP107_ERR_STEP_MAX                       !F-LPARKER-125 (CAMI)
               do WRITE-REPORT

            end-if                                                  ! End if for Max Step  PUBSEC

        end-if                                                      ! End If $Elig_for_Increm_step

      ! else

        !***** This message is really useful if you do not know why people are not qualifying for increase
        !let $error-msg = 'Rates not within minimum range'
        !do write-report
        !let $error_msg = ' '

      end-if

  else

    let $Error-Msg = $CMP107_ERR_NO_STEP                              !F-LPARKER-125 (CAMI)
    do Write-Report

  end-if

FROM PS_JOB            A,
     PS_PERSON_NAME    B,
     PS_PAYGROUP_TBL   P,
     PS_FREQUENCY_TBL  F
WHERE A.SAL_ADMIN_PLAN = &Z.Sal_Admin_Plan
  AND A.GRADE          = &Z.Grade
  AND ((A.EFFDT  =   (SELECT MAX(C.EFFDT)
                       FROM PS_JOB C
                      WHERE C.EMPLID    = A.EMPLID
                        AND C.EMPL_RCD  = A.EMPL_RCD
                        AND C.EFFDT    <= $New_Job_Effdt)
        AND A.EFFSEQ = (SELECT MAX(D.EFFSEQ)
                         FROM PS_JOB D
                        WHERE D.EMPLID    = A.EMPLID
                          AND D.EMPL_RCD  = A.EMPL_RCD
                          AND D.EFFDT     = A.EFFDT))
    OR (A.EFFDT   > $New_Job_Effdt
        AND A.EFFSEQ  =  (SELECT MAX(E.EFFSEQ)
                            FROM PS_JOB E
                           WHERE E.EMPLID    = A.EMPLID
                             AND E.EMPL_RCD  = A.EMPL_RCD
                             AND E.EFFDT     = A.EFFDT)))
  AND A.EMPL_STATUS NOT IN ('D', 'R', 'T')
  AND A.STEP     <> 0
  AND A.EMPLID    = B.EMPLID
  AND A.PAYGROUP  = P.PAYGROUP
  AND A.COMPANY   = P.COMPANY
  AND P.EFFDT     = (SELECT MAX(P1.EFFDT)
                       FROM PS_PAYGROUP_TBL P1
                      WHERE P1.COMPANY   = P.COMPANY
                        AND P1.PAYGROUP  = P.PAYGROUP
                        AND P1.EFFDT    <= $New_Job_Effdt)
  AND NOT EXISTS
      (SELECT 'X'
       FROM PS_RUN_CNTL_CMP107 RC,
            PS_EP_APPR EP
       WHERE RC.OPRID          = $prcs_oprid
         AND RC.RUN_CNTL_ID    = $prcs_run_cntl_id
         AND EP.EMPLID              = A.EMPLID
         AND EP.EMPL_RCD            = A.EMPL_RCD
         AND EP.EP_REVIEW_STATUS    = 'CO'
         AND (EP.EP_APPROVAL_STATUS = 'APRV' OR EP.EP_APPROVAL_STATUS = 'NREQ')
         AND EP.EP_REVIEW_TYPE = RC.EP_REVIEW_TYPE
         AND EP.PERIOD_END_DT       = (SELECT MAX(EP1.PERIOD_END_DT)
                                         FROM PS_EP_APPR EP1
                                        WHERE EP1.EMPLID              = A.EMPLID
                                          AND EP1.EMPL_RCD            = A.EMPL_RCD
                                          AND EP1.EP_REVIEW_STATUS    = 'CO'
                                          AND (EP1.EP_APPROVAL_STATUS = 'APRV' OR EP1.EP_APPROVAL_STATUS = 'NREQ')
                                          AND EP1.EP_REVIEW_TYPE = RC.EP_REVIEW_TYPE
                                          AND EP1.PERIOD_END_DT <= $New_Job_Effdt)
         AND EP.EP_CALC_METHOD = 'A'
         AND EP.RATING_MODEL   = RC.RATING_MODEL
         AND EP.REVIEW_RATING  = RC.REVIEW_RATING)
  AND A.COMP_FREQUENCY   = F.FREQUENCY_ID
  AND F.EFF_STATUS       = 'A'
  AND F.EFFDT            =
    (SELECT MAX(F1.EFFDT)
       FROM PS_FREQUENCY_TBL F1
      WHERE F1.FREQUENCY_ID   = F.FREQUENCY_ID
        AND F1.EFF_STATUS     = F.EFF_STATUS
        AND F1.EFFDT         <= A.EFFDT)

ORDER BY A.GRADE, A.STEP, B.NAME, A.EMPLID,
         A.EMPL_RCD, A.EFFDT, A.EFFSEQ
end-SELECT

end-procedure PROCESS-EMPS

!***********************************************************************
! Procedure: GET-BASE-COMPENSATION                                     *
! Descr:     Reads the PS_COMPENSATION rows associated with a part-    *
!            icular PS_JOB row.  For all "base pay" components, it     *
!            calls CONVERT-COMPONENT-COMPRATE to find applicable rates *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure GET-BASE-COMPENSATION

   move 'Y' to $Base_Comps_Only

   move 0.00 to #Job_Comprate
   move 0.00 to #Job_Annual_Rt
   move 0.00 to #Job_Monthly_Rt
   move 0.00 to #Job_Daily_Rt
   move 0.00 to #Job_Hourly_Rt

   move 0 to #cp_idx
   move 0 to #cp_cnt

begin-SELECT
CP.EFFSEQ
CP.COMP_EFFSEQ
CP.COMP_RATECD
CP.COMP_RATE_POINTS
CP.COMPRATE
CP.COMP_PCT
CP.COMP_FREQUENCY
CP.CURRENCY_CD
CP.MANUAL_SW
CP.CONVERT_COMPRT
CP.RATE_CODE_GROUP
CP.FTE_INDICATOR
CP.CMP_SRC_IND
CR.RATE_CODE_CLASS

   add 1 to #cp_idx
   put &CP.EFFSEQ            into CompArray (#cp_idx) cp_effseq
   put &CP.COMP_EFFSEQ       into CompArray (#cp_idx) cp_comp_effseq
   put &CP.COMP_RATECD       into CompArray (#cp_idx) cp_comp_ratecd
   put &CP.COMP_RATE_POINTS  into CompArray (#cp_idx) cp_comp_rate_points
   put &CP.COMPRATE          into CompArray (#cp_idx) cp_comprate

   put &CP.COMP_PCT          into CompArray (#cp_idx) cp_comp_pct
   put &CP.COMP_FREQUENCY    into CompArray (#cp_idx) cp_comp_frequency
   put &CP.CURRENCY_CD       into CompArray (#cp_idx) cp_currency_cd
   put &CP.MANUAL_SW         into CompArray (#cp_idx) cp_manual_sw
   put &CP.CONVERT_COMPRT    into CompArray (#cp_idx) cp_convert_comprt
   put &CP.RATE_CODE_GROUP   into CompArray (#cp_idx) cp_rate_code_group
   put &CP.FTE_INDICATOR     into CompArray (#cp_idx) cp_fte_indicator
   put &CP.CMP_SRC_IND       into CompArray (#cp_idx) cp_cmp_src_ind
   put &CR.RATE_CODE_CLASS   into CompArray (#cp_idx) cp_rate_code_class

   if &CR.Rate_Code_Class = 'SENPAY' ! or &CR.Rate_Code_Class = 'EDUPAY'  or  &CR.Rate_Code_Class = 'GRPPAY'
      or &CP.Manual_Sw = 'Y'

      move 'N' to $Base_Comps_Only

      !***** This message is really useful if you do not know why people are not qualifying for increase
      !let $error-msg = &CR.Rate_Code_Class || ' bypassed in Base Compensation'
      !do write-report
      !let $error_msg = ' '

      if $Base_Only_Sw <> 'Y'

         do CONVERT-OLD-COMPONENT-COMPRATE
         add #Exc_Comprate   to #Job_Comprate
         add #Exc_Annual_Rt  to #Job_Annual_Rt
         add #Exc_Monthly_Rt to #Job_Monthly_Rt
         add #Exc_Daily_Rt   to #Job_Daily_Rt
         add #Exc_Hourly_Rt  to #Job_Hourly_Rt

      end-if
   else

      do CONVERT-OLD-COMPONENT-COMPRATE
      add #Exc_Comprate   to #Job_Comprate
      add #Exc_Annual_Rt  to #Job_Annual_Rt
      add #Exc_Monthly_Rt to #Job_Monthly_Rt
      add #Exc_Daily_Rt   to #Job_Daily_Rt
      add #Exc_Hourly_Rt  to #Job_Hourly_Rt

   end-if

FROM PS_COMPENSATION CP
   , PS_COMP_RATECD_TBL CR
WHERE CP.EMPLID      = &A.EMPLID
  AND CP.EMPL_RCD    = &A.EMPL_RCD
  AND CP.EFFDT       = &A.EFFDT
  AND CP.EFFSEQ      = &A.EFFSEQ
  AND CP.COMP_RATECD = CR.COMP_RATECD
  AND CR.EFF_STATUS  = 'A'
  AND CR.EFFDT       = (SELECT MAX(CR1.EFFDT)
                          FROM PS_COMP_RATECD_TBL CR1
                         WHERE CR1.COMP_RATECD = CP.COMP_RATECD
                           AND CR1.EFFDT      <= &A.EFFDT)
end-SELECT

   move #cp_idx to #cp_cnt

end-procedure GET-BASE-COMPENSATION

!***********************************************************************
! Procedure: CONVERT-OLD-COMPONENT-COMPRATE                            *
! Descr:     For each pay component, this module calls ConvertCurrency *
!            to calculate pay in the base currency for PS_JOB, then it *
!            converts the result based on the Pay Frequency parameters *
!            from PS_JOB.  Following this, the Annual, Monthly, Daily  *
!            and Hourly rates are calculated using called procedures.  *
!                                                                      *
! Called by: GET-BASE-COMPENSATION                                     *
!***********************************************************************
begin-procedure CONVERT-OLD-COMPONENT-COMPRATE

   do CONVERTCURRENCY(&CP.COMPRATE,&CP.CURRENCY_CD,$Old_Step_Currency,
                      'OFFIC',&A.EFFDT,#Wrk_Comprate,'W')

   do CONVERT-FREQUENCY(&A.EFFDT,#Wrk_Comprate,&CP.COMP_FREQUENCY,'A',
                        &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Comprate)

   if &F.FREQUENCY_TYPE = 'C'
      let $Monthly_Freq = ' '
      let $Daily_Freq = ' '
      do GET-PAYGROUP-FREQ-CNT(&A.EMPLID,&A.EMPL_RCD,&A.EFFDT,$Monthly_Freq,$Daily_Freq)
   else
      let $Monthly_Freq = 'M'
      let $Daily_Freq = 'D'
   end-if

   do DET-ANNUAL-RT(&A.EFFDT,#Exc_Comprate,'A',
                        &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Annual_Rt)

   do DET-MONTHLY-RT(&A.EFFDT,#Exc_Comprate,'A',$Monthly_Freq,
                        &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Monthly_Rt)

   do DET-DAILY-RT(&A.EFFDT,#Exc_Comprate,'A',$Daily_Freq,
                        &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_daily_rt)

   do DET-HOURLY-RT(&A.EFFDT,#Exc_Comprate,'A',
                        &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Hourly_rt)

   !*** Comprate does not reflect FTE
   let #Exc_Comprate   = #Exc_Comprate
   let #Exc_Annual_Rt  = #Exc_Annual_Rt
   let #Exc_Monthly_Rt = #Exc_Monthly_Rt
   let #Exc_Daily_Rt   = #Exc_Daily_Rt
   let #Exc_Hourly_Rt  = #Exc_Hourly_Rt

   ! if &CP.FTE_INDICATOR = 'Y' and &A.FTE < 1
   !   let #Exc_Comprate   = #Exc_Comprate * &A.FTE
   !   let #Exc_Annual_Rt  = #Exc_Annual_Rt * &A.FTE
   !   let #Exc_Monthly_Rt = #Exc_Monthly_Rt * &A.FTE
   !   let #Exc_Daily_Rt   = #Exc_Daily_Rt * &A.FTE
   !   let #Exc_Hourly_Rt  = #Exc_Hourly_Rt * &A.FTE
   !end-if

end-procedure !CONVERT-COMPONENT-COMPRATE

!***********************************************************************
! Procedure: PROC-JOB-ERNS-DIST                                        *
! Descr:     Reads the PS_JOB_EARNS_DIST rows associated with a part-  *
!            icular PS_JOB row.  Inserts rows into PS_JOB_EARNS_DIST   *
!            for new PS_JOB record.                                    *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure PROC-JOB-ERNS-DIST

begin-SELECT
J.EMPLID
J.EMPL_RCD
J.EFFDT
J.EFFSEQ
J.DEPTID
J.JOBCODE
J.POSITION_NBR
J.GL_PAY_TYPE
J.ACCT_CD
J.SHIFT
J.LOCATION
J.ERNCD
J.COMPRATE
J.DIST_PCT
J.STD_HOURS
J.BUSINESS_UNIT

  do Insert-New-JobDist-Rec

FROM PS_JOB_EARNS_DIST J

WHERE J.EMPLID    = &A.EMPLID
  AND J.EMPL_RCD  = &A.EMPL_RCD
  AND J.EFFDT   =
                    (SELECT MAX(J1.EFFDT)
                       FROM PS_JOB_EARNS_DIST J1
                      WHERE J1.EMPLID    = J.EMPLID
                        AND J1.EMPL_RCD  = J.EMPL_RCD
                        AND J1.EFFDT     = &A.EFFDT)
  AND J.EFFSEQ    =
                    (SELECT MAX(J2.EFFSEQ)
                       FROM PS_JOB_EARNS_DIST J2
                      WHERE J2.EMPLID    = J.EMPLID
                        AND J2.EMPL_RCD  = J.EMPL_RCD
                        AND J2.EFFDT     = J.EFFDT)

ORDER BY J.EMPL_RCD ASC,
         J.EFFDT ASC,
         J.EFFSEQ ASC
end-SELECT

end-procedure  !* PROC-JOB-ERNS-DIST

!***********************************************************************
! Procedure: FIND-STEP                                                 *
! Descr:     While processing the employee's job using the step        *
!            find the existing rates for the grade and step.  Save for *
!            future the new rates and step if the employee qualifies   *
!            for a step increase.                                      *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure FIND-STEP

  move 0 to #idx
  while #idx <= 14
    get #step from Stepdata(#idx) sd_step
    if &A.Step = #step
      let $Step_Found = 'Y'
      get #Increm_Months      from Stepdata(#idx) sd_increm_months
      get #Increm_Hours       from Stepdata(#idx) sd_increm_hours
      get #Old_Step_Hr_Rate   from Stepdata(#idx) sd_hourly_rt
      get #Old_Step_Dy_Rate   from Stepdata(#idx) sd_daily_rt          !PUBSEC
      get #Old_Step_Mn_Rate   from Stepdata(#idx) sd_monthly_rt        !PUBSEC
      get #Old_Step_An_Rate   from Stepdata(#idx) sd_annual_rt         !PUBSEC
      get $Old_Step_Currency  from Stepdata(#idx) sd_currency_cd
      get #Old_comp_begin_idx from Stepdata(#idx) sd_comp_begin_idx
      get #Old_comp_end_idx   from Stepdata(#idx) sd_comp_end_idx

      let #Low_Hr_Rt  = #Old_Step_Hr_Rate - .01                        !PUBSEC
      let #High_Hr_Rt = #Old_Step_Hr_Rate + .01                        !PUBSEC
      let #Low_Dy_Rt  = #Old_Step_Dy_Rate - .10                        !PUBSEC
      let #High_Dy_Rt = #Old_Step_Dy_Rate + .10                        !PUBSEC
      let #Low_Mn_Rt  = #Old_Step_Mn_Rate - 1                          !PUBSEC
      let #High_Mn_Rt = #Old_Step_Mn_Rate + 1                          !PUBSEC
      let #Low_An_Rt  = #Old_Step_An_Rate - 1                          !PUBSEC
      let #High_An_Rt = #Old_Step_An_Rate + 1                          !PUBSEC

      add 1 to #idx

      get #New_Step            from Stepdata(#idx) sd_step
      get #New_Step_Hourly_Rt  from Stepdata(#idx) sd_hourly_rt
      get #New_Step_Daily_Rt   from Stepdata(#idx) sd_daily_rt
      get #New_Step_Monthly_Rt from Stepdata(#idx) sd_monthly_rt
      get #New_Step_Annual_Rt  from Stepdata(#idx) sd_annual_rt
      get $New_Step_Currency   from Stepdata(#idx) sd_currency_cd
      get #New_comp_begin_idx  from Stepdata(#idx) sd_comp_begin_idx
      get #New_comp_end_idx    from Stepdata(#idx) sd_comp_end_idx

      break

    end-if
    add 1 to #idx
  end-while

end-procedure

!***********************************************************************
! Procedure: CHECK_DATE_ELIG                                           *
! Descr:     Based on the increment months determine if a step increase*
!            can occur because it has been XXX months since the last   *
!            step increase                                             *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure Check-Date-Elig

  if isnull(&A.Step_Entry_Dt) = 0
    let $Date1 = &A.Step_Entry_Dt
    do  Format-DateTime($Date1, $Date1, {DEFCMP}, '', '')

    let #Year1        = to_number(substr($Date1, 1, 4))
    let #Month1       = to_number(substr($Date1, 5, 2))
    let #Day1         = to_number(substr($Date1, 7, 2))
    let #Total_Months = (#Year1 * 12) + #Month1 + #Increm_Months
    let #Year2        = trunc(#Total_Months / 12, 0)
    let #Month2       = mod(#Total_Months, 12)

    if #Month2 = 0
      let #Year2  = #Year2 - 1
      let #Month2 = 12
    end-if

    let #Day2      = #Day1
    let #Remainder = mod(#Year2, 4)

    if #Remainder != 0 or #Year2 = 0          !if not leap year
      put 28 into Month_Array(1) Days
    else                                      !else if leap year
      put 29 into Month_Array(1) Days
    end-if

    let #Offset = #Month2 - 1
    get #Days from Month_Array(#Offset) Days  !get days in month

    if #Day2 > #Days                          !if fewer days in month
      let #Day2 = #Days
    end-if

    let $Date2 = lpad(to_char(#Year2),  2, '0') || '/' ||
                 lpad(to_char(#Month2), 2, '0') || '/' ||
                 lpad(to_char(#Day2),   2, '0')

    do Format-DateTime($Date2, $Date2, {DEFYMD}, '', {DEFDATE})
    do Format-DateTime($Date2, $Date2, {DEFCMP}, '', '')

    if $Date2 >= $StartDt and $Date2 <= $EndDt
      move 'Y' to $Elig_For_Increm_Date
    end-if

    do Format-DateTime($Date2, $Date2, {DEFCMP}, '', {DEFDATE})

  else

    let $Error-Msg = 'NO STEP ENTRY DATE SPECIFIED'
    do Write-Report
    let $Error-Msg = ' '

  end-if

end-procedure

!***********************************************************************
! Procedure: CHECK_HOURS_ELIG                                          *
! Descr:     Based on the increment hours determine if a step increase *
!            can occur because there are enough accumulated hours      *
!            according to the grade definition. If enough hours        *
!            accumulated in the special accumulator the required amt   *
!            is reduced from the accumulated hours                     *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure CHECK-HOURS-ELIG

  let #Accum_Hours   = 0
  do Get-Accum-Hours
  if #Accum_Hours >= #Increm_Hours and #Accum_Hours <> 0
    move 'Y' to $Elig_For_Increm_Hours
    let #Remain_Hours = #Accum_Hours - #Increm_Hours
  end-if

end-procedure !CHECK-HOURS-ELIG

!***********************************************************************
! Procedure: GET_ACUM_HOURS                                            *
! Descr:     Get the hours from the special accumulator as to          *
!            determine hours eligibility                               *
!                                                                      *
! Called by: CHECK_HOURS_ELIG                                          *
!***********************************************************************
begin-procedure Get-Accum-Hours

  if &P.COUNTRY = 'CAN'
     do Get-CAN-Accum-Hours
  else
     do Get-USA-Accum-Hours
  end-if

end-procedure

!***********************************************************************
! Procedure: GET_CAN_ACUM_HOURS                                        *
! Descr:     Get the hours from the special accumulator as to          *
!            determine hours eligibility when JOB country specified    *
!            as CANADA                                                 *
!                                                                      *
! Called by: GET_ACCUM_HOURS                                           *
!***********************************************************************
Begin-Procedure Get-CAN-Accum-Hours

begin-SELECT
F.COMPANY
F.BALANCE_YEAR
F.BALANCE_ID
F.WAGE_LOSS_PLAN
F.PROVINCE
F.BALANCE_QTR
F.BALANCE_PERIOD
F.HRS_YTD
  add &F.Hrs_YTD to #Accum_Hours
FROM  PS_CAN_ERN_BALANCE F
WHERE F.SPCL_BALANCE = 'Y'
AND   F.ERNCD        = &Z.Step_Increm_Accum
AND   F.EMPLID       = &A.EmplID
AND   F.EMPL_RCD    = &A.Empl_Rcd
AND   F.BALANCE_PERIOD    =
                 (SELECT MAX(G.BALANCE_PERIOD)
                   FROM  PS_CAN_ERN_BALANCE G
                   WHERE G.EMPLID         = F.EMPLID
                          AND  G.EMPL_RCD       = F.EMPL_RCD
                    AND  G.COMPANY        = F.COMPANY
                    AND  G.ERNCD          = F.ERNCD             !PUBSEC
                    AND  G.BALANCE_YEAR   = F.BALANCE_YEAR
                    AND  G.BALANCE_ID     = F.BALANCE_ID
                    AND  G.WAGE_LOSS_PLAN = F.WAGE_LOSS_PLAN
                    AND  G.PROVINCE       = F.PROVINCE)
AND  F.BALANCE_ID = $Calendar_Year_Id
ORDER BY F.BALANCE_YEAR ASC, F.BALANCE_QTR ASC, F.BALANCE_PERIOD ASC
end-SELECT

end-procedure

!***********************************************************************
! Procedure: GET_USA_ACUM_HOURS                                        *
! Descr:     Get the hours from the special accumulator as to          *
!            determine hours eligibility when JOB country specified    *
!            not =  CANADA                                             *
!                                                                      *
! Called by: GET_ACCUM_HOURS                                           *
!***********************************************************************
Begin-Procedure Get-USA-Accum-Hours

begin-SELECT
H.COMPANY
H.BALANCE_YEAR
H.BALANCE_ID
H.BALANCE_QTR
H.BALANCE_PERIOD
H.HRS_YTD
  add &H.Hrs_YTD to #Accum_Hours
FROM  PS_EARNINGS_BAL H
WHERE H.SPCL_BALANCE = 'Y'
AND   H.ERNCD        = &Z.Step_Increm_Accum
AND   H.EMPLID       = &A.EmplID
AND   H.EMPL_RCD    = &A.Empl_Rcd
AND   H.BALANCE_PERIOD    =
                 (SELECT MAX(I.BALANCE_PERIOD)
                   FROM  PS_EARNINGS_BAL I
                   WHERE I.EMPLID         = H.EMPLID
                    AND  I.EMPL_RCD       = H.EMPL_RCD
                    AND  I.COMPANY        = H.COMPANY
                    AND  I.ERNCD          = H.ERNCD             !PUBSEC
                    AND  I.BALANCE_YEAR   = H.BALANCE_YEAR
                    AND  I.BALANCE_ID     = H.BALANCE_ID)
AND  H.BALANCE_ID = $Calendar_Year_Id
ORDER BY H.BALANCE_YEAR ASC, H.BALANCE_QTR ASC, H.BALANCE_PERIOD ASC
end-SELECT

end-procedure

!***********************************************************************
! Procedure: CALC-NEW-RATES                                            *
! Descr:     Calculates the new rates and fields for the new JOB       *
!            row that will result from the step increase. This         *
!            procedure only does JOB not the compensations for the     *
!            JOB. The new field values are saved for the actual insert *
!            for the insert of the new JOB row                         *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure Calc-New-Rates

   do Format-DateTime(&A.EFFDT, $A_Effdt, {DEFCMP}, '', '')
   do Format-DateTime($New_Job_Effdt, $Job_Effdt, {DEFCMP}, '', '')

   if $A_Effdt < $Job_Effdt
     if $Elig_for_Increm_Date = 'Y'
       let $New_EffDt = $Date2
     else
       let $New_EffDt = $New_Job_Effdt
     end-if
     let #New_EffSeq = 0
   else
     let $New_EffDt  = &A.EFFDT
     let #New_EffSeq = &A.EFFSEQ + 1
   end-if

   ! Initialize Rates for New Job
   move #new_step to #new_JobRec_step
   move $new_effdt to $new_JobRec_effdt
   move #new_effseq to #new_JobRec_effseq
   move 0 to #new_JobRec_hourly_rt
   move 0 to #new_jobRec_daily_rt
   move 0 to #new_Jobrec_monthly_rt
   move 0 to #new_JobRec_annual_rt

   !*** For each new comprate convert to Job Currency and frequency **
   let #no_more_new_components = 0
   let #first_component = 1
   let #new_Job_comprate = 0

   while #no_more_new_components = 0

        do FIND-NEW-COMP-STEP

        do CONVERT-NEW-COMPONENT-COMPRATE

        !***  setting the find mode to look for class in FInd Old Compensatation
        let $Comp_Find_mode = 'BASE'
        let #start_find_idx = 0

        !* Make sure at least one search is performed
        let $old_ratecd_fnd = 'Y'
        do find_old_compensation

        let $old_fte_indicator = 'N'

        If $old_ratecd_fnd = 'Y'
           get $old_fte_indicator from comparray (#old_comp_idx) cp_fte_indicator
        else

           !*****  According to HR rules of the Job page FTE is disabled when
           !****** Frequency is H, Rate type is PC, HF, or HR and Base Pay SW = N

           if $NewCP_Comp_Frequency <> 'H' and $NewComp_Rate_Type <> 'PC' and
              $NewComp_Rate_Type <> 'HF' and $NewComp_Rate_Type <> 'HR' and
              $NewComp_Base_Pay_Sw <> 'N'

               if &A.FTE <> 0 and &A.FTE <> 1
                      let $old_fte_indicator = 'Y'
                      let $error-msg = 'Default Comprate ' || $NewCP_Comp_Ratecd
                              || ' FTE Indic to Y'
                      do write-report
                      let $error_msg = ' '
               end-if
           end-if
        end-if

        do DET-ANNUAL-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#new_step_annual_rt)

        do DET-MONTHLY-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,$Monthly_Freq,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#new_step_monthly_rt)

        do DET-DAILY-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,$Daily_Freq,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#new_step_daily_rt)

        do DET-HOURLY-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#new_step_hourly_rt)

        if $old_fte_indicator = 'Y' and &A.FTE <> 0.00
           let #Exc_Comprate = #Exc_Comprate * &A.FTE
           let #new_step_hourly_rt = #new_step_hourly_rt * &A.FTE
           let #new_step_daily_rt  = #new_step_daily_rt * &A.FTE
           let #new_step_monthly_rt  = #new_step_monthly_rt * &A.FTE
           let #new_step_annual_rt   = #new_step_annual_rt * &A.FTE
        else
           let #Exc_Comprate = #Exc_Comprate
        end-if

        let #new_Job_comprate = #New_Job_comprate + #Exc_Comprate

        ! Setup Rates for New Job
        let #new_JobRec_hourly_rt = #new_JobRec_hourly_rt + #new_step_hourly_rt
        let #new_jobRec_daily_rt  = #new_jobRec_daily_rt  + #new_step_daily_rt
        let #new_Jobrec_monthly_rt = #new_Jobrec_monthly_rt + #new_step_monthly_rt
        let #new_JobRec_annual_rt = #new_JobRec_annual_rt + #new_step_annual_rt

        let #first_component = 0

   end-while

   !**** Accumulate new Job entries into accumulators
   let #New_Comprate   =  #new_Job_comprate
   let #New_Annual_Rt  =  #new_JobRec_annual_rt
   let #New_Monthly_Rt =  #new_Jobrec_monthly_rt
   let #New_Daily_Rt   =  #new_jobRec_daily_rt
   let #New_Hourly_Rt  =  #new_JobRec_hourly_rt


   !Add on any SENPAY entries
   !***  setting the find mode to look for class in FInd Old Compensatation
   let $Comp_Find_mode = 'CLASS'
   let #start_find_idx = 0
   let $out_rate_code_class = 'SENPAY'

   !* Make sure at least one search is performed
   let $old_ratecd_fnd = 'Y'

   !*** Continue searching until no more entries are found
   while $old_ratecd_fnd <> 'N'
         do find_old_compensation

         if $old_ratecd_fnd = 'Y'

                get #old_comp_amt from comparray (#old_comp_idx) cp_comprate
                get $old_comp_frequency from comparray (#old_comp_idx) cp_comp_frequency
                get $old_comp_currency_cd from comparray (#old_comp_idx) cp_currency_cd
                get $old_fte_indicator from comparray (#old_comp_idx) cp_fte_indicator


                !*   Need to take old rate and reapply against the job
                do Convert_old_Comprate

                if $old_fte_indicator = 'Y' and &A.FTE <> 0
                     let #Exc_Comprate   = #Exc_Comprate * &A.FTE
                     let #Exc_Annual_Rt  = #Exc_Annual_Rt * &A.FTE
                     let #Exc_Monthly_Rt = #Exc_Monthly_Rt * &A.FTE
                     let #Exc_Daily_Rt   = #Exc_Daily_Rt * &A.FTE
                     let #Exc_Hourly_Rt  = #Exc_Hourly_Rt * &A.FTE
                end-if

                let #New_Comprate   =  #new_comprate + #Exc_Comprate
                let #New_Annual_Rt  =  #New_Annual_Rt + #Exc_annual_rt
                let #New_Monthly_Rt =  #New_Monthly_Rt + #Exc_Monthly_rt
                let #New_Daily_Rt   =  #New_Daily_Rt + #Exc_daily_rt
                let #New_Hourly_Rt  =  #New_Hourly_Rt + #Exc_Hourly_rt

                !*** For the next loop make sure we dont search entries we have already searched
                let #start_find_idx = #old_comp_idx

        end-if

    end-while

   !Add on any Manual entries
   !***  setting the find mode to look for class in FInd Old Compensatation
   let $Comp_Find_mode = 'MANUAL'
   let #start_find_idx = 0
   let $out_rate_code_class = 'SENPAY'

   !* Make sure at least one search is performed
   let $old_ratecd_fnd = 'Y'

   !*** Continue searching until no more entries are found
   while $old_ratecd_fnd <> 'N'
         do find_old_compensation

         if $old_ratecd_fnd = 'Y'

                get #old_comp_amt from comparray (#old_comp_idx) cp_comprate
                get $old_comp_frequency from comparray (#old_comp_idx) cp_comp_frequency
                get $old_comp_currency_cd from comparray (#old_comp_idx) cp_currency_cd
                get $old_fte_indicator from comparray (#old_comp_idx) cp_fte_indicator

                !*   Need to take old rate and reapply against the job
                do Convert_old_Comprate

                !**   Apply FTE from JOB if compensation record is checked
                if $old_fte_indicator = 'Y' and &A.FTE <> 0
                     let #Exc_Comprate   = #Exc_Comprate * &A.FTE
                     let #Exc_Annual_Rt  = #Exc_Annual_Rt * &A.FTE
                     let #Exc_Monthly_Rt = #Exc_Monthly_Rt * &A.FTE
                     let #Exc_Daily_Rt   = #Exc_Daily_Rt * &A.FTE
                     let #Exc_Hourly_Rt  = #Exc_Hourly_Rt * &A.FTE
                end-if

                let #New_Comprate   =  #new_comprate + #Exc_Comprate
                let #New_Annual_Rt  =  #New_Annual_Rt + #Exc_annual_rt
                let #New_Monthly_Rt =  #New_Monthly_Rt + #Exc_Monthly_rt
                let #New_Daily_Rt   =  #New_Daily_Rt + #Exc_daily_rt
                let #New_Hourly_Rt  =  #New_Hourly_Rt + #Exc_Hourly_rt

                !*** For the next loop make sure we dont search entries we have already searched
                let #start_find_idx = #old_comp_idx

        end-if

    end-while

   let #New_Job_Comprate   =   #New_Comprate
   let #New_jobrec_Annual_Rt  = #new_Annual_Rt
   let #New_jobrec_Monthly_Rt = #new_monthly_Rt
   let #New_jobrec_Daily_Rt   = #new_Daily_Rt
   let #New_jobrec_Hourly_Rt  = #new_Hourly_Rt

   let #New_Change_Amt = #New_Job_Comprate - &A.Comprate

   if &A.Comprate <> 0
      let #New_Change_Pct = round(#New_Change_Amt / &A.Comprate * 100, 3)
   else
      let #New_Change_Pct = 0
   end-if

end-procedure

!***********************************************************************
! Procedure: CONVERT-NEW-COMPONENT-COMPRATE                            *
! Descr:     For each pay component, this module calls ConvertCurrency *
!            to calculate pay in the base currency for PS_JOB, then it *
!            converts the result based on the Pay Frequency parameters *
!            from PS_JOB.  Following this, the Annual, Monthly, Daily  *
!            and Hourly rates are calculated using called procedures.  *
!                                                                      *
! Called by: CALC-NEW-RATES                                            *
!***********************************************************************
begin-procedure CONVERT-NEW-COMPONENT-COMPRATE

   do CONVERTCURRENCY(#NewCP_Comprate,$NewCP_Currency_cd,&A.CURRENCY_CD,
                      'OFFIC',&A.EFFDT,#Wrk_Comprate,'W')

   do CONVERT-FREQUENCY(&A.EFFDT,#Wrk_Comprate,$NewCP_Comp_Frequency,&A.COMP_FREQUENCY,
                        &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Comprate)


end-procedure !CONVERT-NEW-COMPONENT-COMPRATE

!***********************************************************************
! Procedure: FIND-NEW-COMP-STEP                                        *
! Descr:     For each pay component, this module searchs the working   *
!            storage array to find the new Pay Component grade/step    *
!            corresponding to the employee's new salary step.          *
!                                                                      *
! Called by: CALC-NEW-RATES                                            *
!***********************************************************************
begin-procedure FIND-NEW-COMP-STEP

   !** Default the new COMPENSATION fields to the old values, just in case a
   !**   new RATE_CODE_STEP row is not located.

   if #first_component = 1
       move #cp_Comp_Effseq       to #NewCP_Comp_Effseq
       move $cp_Comp_Ratecd       to $NewCP_Comp_Ratecd
       move #cp_Comp_Rate_Points  to #NewCP_Comp_Rate_Points
       move #cp_Comprate          to #NewCP_Comprate
       move #cp_Comp_Pct          to #NewCP_Comp_Pct
       move $cp_Comp_Frequency    to $NewCP_Comp_Frequency
       move $cp_Currency_Cd       to $NewCP_Currency_Cd
       move $cp_Manual_Sw         to $NewCP_Manual_Sw
       move #cp_Convert_Comprt    to #NewCP_Convert_Comprt
       move $cp_Rate_Code_Group   to $NewCP_Rate_Code_Group
       move 0.00                  to #NewCP_Change_Amt
       move 0.00                  to #NewCP_Change_Pct
       move 0.00                  to #NewCP_Change_Pts
       move $cp_FTE_Indicator     to $NewCP_FTE_Indicator
       move ' '                   to $NewComp_Rate_Type
       move ' '                   to $NewComp_Base_Pay_Sw

   !** Find the correct row for the current EFFSEQ and RATECD from the range
   !**   of rows in the RATE_CODE_STEP array which correspond to the new
   !**   salary grade and step.  Move the values into the COMPENSATION row.

       move #New_comp_begin_idx to #SC_idx

   else
     add 1 to #SC_idx
   end-if

   if #SC_idx <= #New_comp_end_idx
      get #NewCP_Comp_Effseq      from stepcomp(#SC_Idx) sc_Comp_Effseq
      get $NewCP_Comp_Ratecd      from stepcomp(#SC_Idx) sc_Comp_Ratecd
      get $NewCP_Currency_Cd      from stepcomp(#SC_Idx) sc_Currency_cd
      get $NewCP_Comp_Frequency   from stepcomp(#SC_Idx) sc_Comp_Frequency
      get #NewCP_Hourly_Rt        from stepcomp(#SC_Idx) sc_Hourly_Rt
      get #NewCP_Monthly_Rt       from stepcomp(#SC_Idx) sc_Monthly_Rt
      get #NewCP_Annual_Rt        from stepcomp(#SC_Idx) sc_Annual_Rt
      get #NewCP_Comp_Pct         from stepcomp(#SC_Idx) sc_Comp_Pct
      get #NewCP_Comp_Rate_Points from stepcomp(#SC_Idx) sc_Comp_Rate_Points
      get $NewCP_Rate_Code_Group  from stepcomp(#SC_Idx) sc_Rate_Code_Group
      get #NewCP_Comprate         from stepcomp(#SC_Idx) sc_Comprate
      get #NewCP_Daily_Rt         from stepcomp(#SC_Idx) sc_Daily_Rt
      get $NewComp_Rate_Type      from stepcomp(#SC_idx) rc_Comp_rate_type
      get $NewComp_Base_Pay_Sw    from stepcomp(#SC_idx) rc_Comp_base_pay_sw

   end-if

   if #SC_idx >= #New_comp_end_idx
         let #no_more_new_components = 1

   end-if

end-procedure !FIND-NEW-COMP-STEP

!***********************************************************************
! Procedure: CONVERT_OLD_COMPRATE                                      *
! Descr:     For each pay component, the amount is converted to its JOB*
!            equivalent                                                *
!                                                                      *
! Called by: CALC-NEW-RATES                                            *
!***********************************************************************
begin-procedure CONVERT_OLD_COMPRATE

   do CONVERTCURRENCY(#old_comp_amt,$old_comp_currency_cd,&A.CURRENCY_CD,
          'OFFIC',&A.EFFDT,#Wrk_Comprate,'W')

   do CONVERT-FREQUENCY(&A.EFFDT,#Wrk_Comprate,$old_comp_frequency,&A.COMP_FREQUENCY,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Comprate)

   if &F.FREQUENCY_TYPE = 'C'
           let $Monthly_Freq = ' '
           let $Daily_Freq = ' '
           do GET-PAYGROUP-FREQ-CNT(&A.EMPLID,&A.EMPL_RCD,&A.EFFDT,$Monthly_Freq,$Daily_Freq)
   else
           let $Monthly_Freq = 'M'
           let $Daily_Freq = 'D'
   end-if

   do DET-ANNUAL-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Annual_Rt)

   do DET-MONTHLY-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,$Monthly_Freq,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Monthly_Rt)

   do DET-DAILY-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,$Daily_Freq,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_daily_rt)

   do DET-HOURLY-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Hourly_rt)

end-procedure

!***********************************************************************
! Procedure: WRITE-REPORT                                              *
! Descr:     Produce a line on the report.  The report is only based   *
!            on Job Data not JOB Compensation data                     *
!                                                                      *
!                                                                      *
! Called by: PROCESS-EMPS, CHECK_DATE_ELIG                             *
!***********************************************************************
begin-procedure Write-Report

  print &A.EmplID                    (+1,1,9)
  print &B.Name                      (0,11,26)
  print &A.Empl_Status               (0,39,1)                    !PUBSEC
  print &A.Sal_Admin_Plan            (0,41,4)
  print &A.Grade                     (0,46,6)
  do Format-DateTime(&A.EFFDT, $out, {DEFDATE}, '', '')
  print $out                         (0,53,10)
  do Format-Number(&A.STEP, $out, '99')
  print $out                         (0,65)
  do Format-Number(&A.COMPRATE, $out, '9,999,999,999.999999')   !PUBSEC
  print $out                         (0,67)
  print '/'                          (0,89)                     !PUBSEC
  print &A.COMP_FREQUENCY            (0,90,2)                   !PUBSEC
  if $Error-Msg = ' '
    do Format-DateTime($New_JobRec_EffDt, $out, {DEFDATE}, '', '')
    print $out                       (0,93,10)
    do Format-Number(#New_JobRec_Step, $out, '99')
    print $out                       (0,105)
    do Format-Number(#New_Job_Comprate, $out, '9,999,999,999.999999') !PUBSEC
    print $out                       (0,107)
    print '/'                        (0,129)                     !PUBSEC
    print &A.COMP_FREQUENCY          (0,130,7)                   !PUBSEC
  else
    print $Error-Msg                 (0,138,40)                  !PUBSEC
  end-if

end-procedure

!***********************************************************************
! Procedure: INSERT-NEW-JOB-REC                                        *
! Descr:     An employee has just quialified for a step increase, use  *
!            the save values from the original JOB row and those       *
!            calculated in CALC_NEW_RATES insert a new JOB row for     *
!            the new step and rates                                    *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure Insert-New-Job-Rec
let $SQL-Statement = 'CMP107.SQR, Insert-New-Job-Rec'

  ! initialize job found flag to false
  let #new_job_found = 0

!Determine if the JOB and EFFSEQ already exist

begin-SELECT on-error=SQL-Error
JOBD.EFFSEQ

  let #new_job_found = 1

FROM PS_JOB            JOBD
WHERE JOBD.EMPLID    = &A.EMPLID
AND   JOBD.EMPL_RCD  = &A.Empl_Rcd
AND   JOBD.EFFDT     = $new_JobRec_effdt
AND   JOBD.EFFSEQ    = (SELECT MAX(JOBDD.EFFSEQ)
                        FROM PS_JOB JOBDD
                        WHERE JOBDD.EMPLID = JOBD.EMPLID
                        AND JOBDD.EMPL_RCD = JOBD.EMPL_RCD
                        AND JOBDD.EFFDT    = JOBD.EFFDT)

end-SELECT

 ! Use the max effseq Plus 1 if the job is found if new effective
 ! dated job being created use the effective sequence calculated
  if #new_job_found = 1

     let #new_JobRec_effseq = &JOBD.EFFSEQ + 1

  end-if


begin-SQL on-error=SQL-Error

INSERT INTO PS_JOB
( EMPLID
, EMPL_RCD
, EFFDT
, EFFSEQ
, PER_ORG
, DEPTID
, JOBCODE
, POSITION_NBR
, HR_STATUS
, APPT_TYPE
, MAIN_APPT_NUM_JPN
, POSITION_OVERRIDE
, POSN_CHANGE_RECORD
, EMPL_STATUS
, ACTION
, ACTION_DT
, ACTION_REASON
, LOCATION
, TAX_LOCATION_CD
, JOB_ENTRY_DT
, DEPT_ENTRY_DT
, POSITION_ENTRY_DT
, SHIFT
, REG_TEMP
, FULL_PART_TIME
, COMPANY
, PAYGROUP
, BAS_GROUP_ID
, ELIG_CONFIG1
, ELIG_CONFIG2
, ELIG_CONFIG3
, ELIG_CONFIG4
, ELIG_CONFIG5
, ELIG_CONFIG6
, ELIG_CONFIG7
, ELIG_CONFIG8
, ELIG_CONFIG9
, BEN_STATUS
, BAS_ACTION
, COBRA_ACTION
, EMPL_TYPE
, HOLIDAY_SCHEDULE
, STD_HOURS
, STD_HRS_FREQUENCY
, OFFICER_CD
, EMPL_CLASS
, SAL_ADMIN_PLAN
, GRADE
, GRADE_ENTRY_DT
, STEP
, STEP_ENTRY_DT
, GL_PAY_TYPE
, ACCT_CD
, EARNS_DIST_TYPE
, COMP_FREQUENCY
, COMPRATE
, CHANGE_AMT
, CHANGE_PCT
, ANNUAL_RT
, MONTHLY_RT
, DAILY_RT
, HOURLY_RT
, ANNL_BENEF_BASE_RT
, SHIFT_RT
, SHIFT_FACTOR
, CURRENCY_CD
, BUSINESS_UNIT
, SETID_DEPT
, SETID_JOBCODE
, SETID_LOCATION
, SETID_SALARY
, REG_REGION
, DIRECTLY_TIPPED
, FLSA_STATUS
, EEO_CLASS
, FUNCTION_CD
, TARIFF_GER
, TARIFF_AREA_GER
, PERFORM_GROUP_GER
, LABOR_TYPE_GER
, SPK_COMM_ID_GER
, HOURLY_RT_FRA
, ACCDNT_CD_FRA
, VALUE_1_FRA
, VALUE_2_FRA
, VALUE_3_FRA
, VALUE_4_FRA
, VALUE_5_FRA
, CTG_RATE
, PAID_HOURS
, PAID_FTE
, PAID_HRS_FREQUENCY
, UNION_FULL_PART
, UNION_POS
, MATRICULA_NBR
, SOC_SEC_RISK_CODE
, UNION_FEE_AMOUNT
, UNION_FEE_START_DT
, UNION_FEE_END_DT
, EXEMPT_JOB_LBR
, EXEMPT_HOURS_MONTH
, WRKS_CNCL_FUNCTION
, INTERCTR_WRKS_CNCL
, CURRENCY_CD1
, PAY_UNION_FEE
, UNION_CD
, BARG_UNIT
, UNION_SENIORITY_DT
, ENTRY_DATE
, LABOR_AGREEMENT
, EMPL_CTG
, EMPL_CTG_L1
, EMPL_CTG_L2
, SETID_LBR_AGRMNT
, GP_PAYGROUP
, GP_DFLT_ELIG_GRP
, GP_ELIG_GRP
, GP_DFLT_CURRTTYP
, CUR_RT_TYPE
, GP_DFLT_EXRTDT
, GP_ASOF_DT_EXG_RT
, ADDS_TO_FTE_ACTUAL
, CLASS_INDC
, ENCUMB_OVERRIDE
, FICA_STATUS_EE
, FTE
, PRORATE_CNT_AMT
, PAY_SYSTEM_FLG
, BORDER_WALKER
, LUMP_SUM_PAY
, CONTRACT_NUM
, JOB_INDICATOR
, WRKS_CNCL_ROLE_CHE
, BENEFIT_SYSTEM
, WORK_DAY_HOURS
, SUPERVISOR_ID
, REPORTS_TO
, FORCE_PUBLISH
, JOB_DATA_SRC_CD
, ESTABID
, HIRE_DT
, LAST_HIRE_DT
, TERMINATION_DT
, ASGN_START_DT
, LST_ASGN_START_DT
, ASGN_END_DT
, LDW_OVR
, LAST_DATE_WORKED
, EXPECTED_RETURN_DT
, EXPECTED_END_DATE
, AUTO_END_FLG
, LASTUPDOPRID
, POI_TYPE
, ABSENCE_SYSTEM_CD
, SETID_SUPV_LVL
, SUPV_LVL_ID 
, LAYOFF_EXEMPT_RSN
, LAYOFF_EXEMPT_FLAG
, LABOR_FACILITY_ID
, WPP_STOP_FLAG )
VALUES
( &A.EmplID
, &A.Empl_Rcd
, $new_JobRec_effdt
, #new_JobRec_effseq
, &A.PER_ORG
, &A.DeptID
, &A.JobCode
, &A.Position_Nbr
, &A.HR_STATUS
, &A.Appt_Type
, &A.Main_Appt_Num_Jpn
, &A.Position_Override
, &A.Posn_Change_Record
, &A.Empl_Status
, 'PAY'                                           !Pay Rate Change
, $AsOfToday
, 'SPG'                                           !PUBSEC Step Progression
, &A.Location
, &A.Tax_Location_Cd
, &A.Job_Entry_Dt
, &A.Dept_Entry_Dt
, $Pos_Entry_Dt             !, &A.Position_Entry_Dt
, &A.Shift
, &A.Reg_Temp
, &A.Full_Part_Time
, &A.Company
, &A.PayGroup
, &A.BAS_GROUP_ID
, &A.ELIG_CONFIG1
, &A.ELIG_CONFIG2
, &A.ELIG_CONFIG3
, &A.ELIG_CONFIG4
, &A.ELIG_CONFIG5
, &A.ELIG_CONFIG6
, &A.ELIG_CONFIG7
, &A.ELIG_CONFIG8
, &A.ELIG_CONFIG9
, &A.BEN_STATUS
, &A.BAS_ACTION
, ' '
, &A.EMPL_TYPE
, &A.HOLIDAY_SCHEDULE
, &A.STD_HOURS
, &A.STD_HRS_FREQUENCY
, &A.OFFICER_CD
, &A.EMPL_CLASS
, &A.SAL_ADMIN_PLAN
, &A.GRADE
, &A.GRADE_ENTRY_DT
, #new_JobRec_step
, $new_JobRec_effdt
, &A.GL_PAY_TYPE
, &A.ACCT_CD
, &A.EARNS_DIST_TYPE
, &A.COMP_FREQUENCY
, #New_Job_Comprate
, #New_Change_Amt
, #New_Change_Pct
, #New_jobrec_Annual_Rt
, #New_jobrec_Monthly_Rt
, #New_jobrec_Daily_Rt
, #New_jobrec_Hourly_Rt
, &A.ANNL_BENEF_BASE_RT
, &A.SHIFT_RT
, &A.SHIFT_FACTOR
, &A.CURRENCY_CD
, &A.BUSINESS_UNIT
, &A.SETID_DEPT
, &A.SETID_JOBCODE
, &A.SETID_LOCATION
, &A.SETID_SALARY
, &A.REG_REGION
, &A.DIRECTLY_TIPPED
, &A.FLSA_STATUS
, &A.EEO_CLASS
, &A.FUNCTION_CD
, &A.TARIFF_GER
, &A.TARIFF_AREA_GER
, &A.PERFORM_GROUP_GER
, &A.LABOR_TYPE_GER
, &A.SPK_COMM_ID_GER
, &A.HOURLY_RT_FRA
, &A.ACCDNT_CD_FRA
, &A.VALUE_1_FRA
, &A.VALUE_2_FRA
, &A.VALUE_3_FRA
, &A.VALUE_4_FRA
, &A.VALUE_5_FRA
, &A.CTG_RATE
, &A.PAID_HOURS
, &A.PAID_FTE
, &A.PAID_HRS_FREQUENCY
, &A.UNION_FULL_PART
, &A.UNION_POS
, &A.MATRICULA_NBR
, &A.SOC_SEC_RISK_CODE
, &A.UNION_FEE_AMOUNT
, &A.UNION_FEE_START_DT
, &A.UNION_FEE_END_DT
, &A.EXEMPT_JOB_LBR
, &A.EXEMPT_HOURS_MONTH
, &A.WRKS_CNCL_FUNCTION
, &A.INTERCTR_WRKS_CNCL
, &A.CURRENCY_CD1
, &A.PAY_UNION_FEE
, &A.UNION_CD
, &A.BARG_UNIT
, &A.UNION_SENIORITY_DT
, &A.ENTRY_DATE
, &A.LABOR_AGREEMENT
, &A.EMPL_CTG
, &A.EMPL_CTG_L1
, &A.EMPL_CTG_L2
, &A.SETID_LBR_AGRMNT
, &A.GP_PAYGROUP
, &A.GP_DFLT_ELIG_GRP
, &A.GP_ELIG_GRP
, &A.GP_DFLT_CURRTTYP
, &A.CUR_RT_TYPE
, &A.GP_DFLT_EXRTDT
, &A.GP_ASOF_DT_EXG_RT
, &A.ADDS_TO_FTE_ACTUAL
, &A.CLASS_INDC
, &A.ENCUMB_OVERRIDE
, &A.FICA_STATUS_EE
, &A.FTE
, &A.PRORATE_CNT_AMT
, &A.PAY_SYSTEM_FLG
, &A.BORDER_WALKER
, &A.LUMP_SUM_PAY
, &A.CONTRACT_NUM
, &A.JOB_INDICATOR
, &A.WRKS_CNCL_ROLE_CHE
, &A.BENEFIT_SYSTEM
, &A.WORK_DAY_HOURS
, &A.SUPERVISOR_ID
, &A.REPORTS_TO
, &A.FORCE_PUBLISH
, &A.JOB_DATA_SRC_CD
, &A.ESTABID
, &A.HIRE_DT
, &A.LAST_HIRE_DT
, &A.TERMINATION_DT
, &A.ASGN_START_DT
, &A.LST_ASGN_START_DT
, &A.ASGN_END_DT
, &A.LDW_OVR
, &A.LAST_DATE_WORKED
, &A.EXPECTED_RETURN_DT
, &A.EXPECTED_END_DATE
, &A.AUTO_END_FLG
, $OperatorId
, &A.POI_TYPE
, &A.ABSENCE_SYSTEM_CD
, &A.SETID_SUPV_LVL
, &A.SUPV_LVL_ID 
, &A.LAYOFF_EXEMPT_RSN
, &A.LAYOFF_EXEMPT_FLAG
, &A.LABOR_FACILITY_ID
, &A.WPP_STOP_FLAG )
end-SQL

end-procedure

!***********************************************************************
! Procedure: PROC-JOB-JUNIOR                                           *
! Descr:     Reads the PS_JOB_JUNIOR rows associated with a PS_JOB row *
!            Inserts rows into PS_JOB_JUNIOR for new PS_JOB record.    *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure Proc-Job-Junior

begin-SELECT
JJR.EMPLID
JJR.EMPL_RCD
JJR.EFFDT
JJR.EFFSEQ
JJR.LASTUPDDTTM
JJR.LASTUPDOPRID
JJR.TAXCODE_UK
JJR.TAX_BASIS_UK
JJR.WORKER_TYPE_MEX
JJR.REDUCED_WEEK_MEX
JJR.LOCATED_CD_MEX
JJR.SALARY_TYPE_MEX
JJR.IMS_TERM_DT_MEX
JJR.BALANCE_GRP_NUM
JJR.FP_ACTION_2
JJR.CTG_RATE
JJR.FP_LEGALSTAT_CD
JJR.FP_SCNDMT_CD
JJR.FP_SCND_TYP
JJR.FP_CIVIL_PENSION
JJR.FP_SOURCE_ORG
JJR.FP_RECEP_ORG
JJR.FP_RETURN_CD
JJR.FP_PR_LEGSTA
JJR.FP_FOREND_DT
JJR.FP_END_DT
JJR.FP_CAREFRZPCT
JJR.FP_HIR_DOS_SIT
JJR.FP_PT_PCT_DET
JJR.FP_TITLE_NUM
JJR.FP_DURATION_PCT
JJR.FP_RATING_PRS_FLG
JJR.FP_BUDGET_NBR
JJR.FP_HDCNT_NBR
JJR.FP_POTENT_NBR
JJR.FP_RANK_CD
JJR.FP_STEP_CD
JJR.FP_RK_ENT_DT
JJR.FP_CORPS_CD
JJR.FP_CHG_COR_DT
JJR.FP_CATG_FP
JJR.FP_CATG_LEVEL
JJR.FP_RK_TRIALPD
JJR.FP_STEP_END_DT
JJR.FP_FOR_PROM_DT
JJR.FP_NOMINATION_DT
JJR.FP_TRAINEE
JJR.FP_TRNE_POSN
JJR.FP_RK_PD_END_DT
JJR.FP_SANCTION
JJR.FP_DOWN_GRA
JJR.FP_APPL_SAL_DT
JJR.FP_CHG_IND
JJR.FP_CLD_INST
JJR.FP_SETID_RANK
JJR.FP_INSTALL_DT
JJR.FP_EQUIV_STEP
JJR.FP_STEP_CD2
JJR.FP_BUSINESS_CD
JJR.FP_APPL_DT
JJR.FP_CHG_SAL
JJR.FP_POINTYP_CD
JJR.FP_GROSS_IND
JJR.FP_INCS_IND
JJR.FP_INCS_IND2
JJR.FP_PT_PCT
JJR.FP_PT_END_DT
JJR.FP_PT_FOREND_DT
JJR.FP_COMPRATE
JJR.FP_INST_STAT
JJR.FP_RETROSPECT
JJR.FP_ROW_END_DT
JJR.LAST_UPDATE_DATE
JJR.OTHER_ID_JPN
JJR.INTCP_XFR_FLG
JJR.INTCP_XFR_START_DT
JJR.INTCP_XFR_END_DT
JJR.INTCP_BUS_UNIT
JJR.INTCP_DEPTID
JJR.INTCP_DEPTID2
JJR.INTCP_SETID_DEPT
JJR.INTCP_COMPANY
JJR.INTCP_COMPANY2
JJR.INTCP_SUPV_LVL_ID
JJR.INTCP_SUPV_LVL_ID2
JJR.START_DATE_JPN
JJR.EXP_END_DATE_JPN
JJR.END_DATE_JPN
JJR.DUTIES_TYPE
JJR.ASSIGNMENT_ID
JJR.TARGET_COMPRATE
JJR.CMP_DONT_ABSORB
JJR.SSN_EMPLOYER
!JJR.SUSBTIT_REASON_ESP
!JJR.SUSBTIT_EMPLID_ESP
!JJR.PART_SUBROGTN_ESP
!JJR.LABOR_RLTNSHIP_ESP
!JJR.INACTIVITY_TYP_ESP
!JJR.PART_STRK_ACT_ESP
JJR.UNITA_PROD_CD
JJR.ACTION_ITA
JJR.ACTION_REASON_ITA
JJR.SPECIAL_HIRCTG_ITA
JJR.PART_TIME_TYPE_ITA
JJR.PART_TIME_PERC_ITA
JJR.PARTTIME_ENDDT_ITA
JJR.WORKDAYS_NLD
JJR.CONT_SAL_TYPE_BRA
JJR.CBO_CD_BRA
JJR.SEFIP_CATEGORY_BRA
JJR.UNION_CD_ALT_BRA

  do Insert-New-JobJr-Rec

  do Proc-Job-Aus
  
FROM PS_JOB_JR JJR
WHERE JJR.EMPLID    = &A.EMPLID
  AND JJR.EMPL_RCD  = &A.EMPL_RCD
  AND JJR.EFFDT     = &A.EFFDT
  AND JJR.EFFSEQ    = &A.EFFSEQ

end-SELECT

end-procedure Proc-Job-Junior

!***********************************************************************
! Procedure: PROC-JOB-AUS                                              *
! Descr:     Reads the PS_JOB_AUS rows associated with a PS_JOB_JR row *
!            Inserts rows into PS_JOB_AUS for new PS_JOB_JR record.    *
!                                                                      *
! Called by: Proc-Job-Jr                                               *
!***********************************************************************
begin-procedure Proc-Job-Aus

Let $JAUS_EMPLID                    = ' '
Let #JAUS_EMPL_RCD                  = 0
Let $JAUS_EFFDT                     = ' '
Let #JAUS_EFFSEQ                    = 0
Let $JAUS_CASUAL_IND                = ' '
Let $JAUS_SALARY_PACKAGED           = ' '
Let $JAUS_PAYROLL_STATE_AUS         = ' '
Let #JAUS_CLASSN_CURRENT_AUS        = 0
Let $JAUS_WORK_SECTOR_AUS           = ' '
Let $JAUS_FUNCTION_AUS              = ' '
Let #JAUS_ANN_CNTACT_HRS_AUS        = 0
Let #JAUS_TEACH_WEEKS_AUS           = 0
Let $JAUS_CASUAL_TYPE_AUS           = ' '
Let $JAUS_TERM_TYPE_AUS             = ' '
Let #JAUS_TERM_LTD_AUS              = 0

begin-SELECT
JAUS.EMPLID
JAUS.EMPL_RCD
JAUS.EFFDT
JAUS.EFFSEQ
JAUS.CASUAL_IND
JAUS.SALARY_PACKAGED
JAUS.PAYROLL_STATE_AUS
JAUS.CLASSN_CURRENT_AUS
JAUS.WORK_SECTOR_AUS
JAUS.FUNCTION_AUS
JAUS.ANN_CNTACT_HRS_AUS
JAUS.TEACH_WEEKS_AUS
JAUS.CASUAL_TYPE_AUS
JAUS.TERM_TYPE_AUS
JAUS.TERM_LTD_AUS

 Let $JAUS_EMPLID                    = &JAUS.EMPLID
 Let #JAUS_EMPL_RCD                  = &JAUS.EMPL_RCD
 Let $JAUS_EFFDT                     = &JAUS.EFFDT
 Let #JAUS_EFFSEQ                    = &JAUS.EFFSEQ
 Let $JAUS_CASUAL_IND                = &JAUS.CASUAL_IND
 Let $JAUS_SALARY_PACKAGED           = &JAUS.SALARY_PACKAGED
 Let $JAUS_PAYROLL_STATE_AUS         = &JAUS.PAYROLL_STATE_AUS
 Let #JAUS_CLASSN_CURRENT_AUS        = &JAUS.CLASSN_CURRENT_AUS
 Let $JAUS_WORK_SECTOR_AUS           = &JAUS.WORK_SECTOR_AUS
 Let $JAUS_FUNCTION_AUS              = &JAUS.FUNCTION_AUS
 Let #JAUS_ANN_CNTACT_HRS_AUS        = &JAUS.ANN_CNTACT_HRS_AUS
 Let #JAUS_TEACH_WEEKS_AUS           = &JAUS.TEACH_WEEKS_AUS
 Let $JAUS_CASUAL_TYPE_AUS           = &JAUS.CASUAL_TYPE_AUS
 Let $JAUS_TERM_TYPE_AUS             = &JAUS.TERM_TYPE_AUS
 Let #JAUS_TERM_LTD_AUS              = &JAUS.TERM_LTD_AUS

FROM PS_JOB_AUS JAUS
WHERE JAUS.EMPLID    = &A.EMPLID
  AND JAUS.EMPL_RCD  = &A.EMPL_RCD
  AND JAUS.EFFDT     = &A.EFFDT
  AND JAUS.EFFSEQ    = &A.EFFSEQ

end-SELECT

do Insert-New-JobAus-Rec

end-procedure Proc-Job-Aus

!***********************************************************************
! Procedure: DETERMINE-NEW-COMPENSATIONS                               *
! Descr:     Get compensation base information from the array storing  *
!            RATECD information for the given step.  Once base info    *
!            retrieved calculate remainder, (CONVERT_COMPRT, CHANGE_AMT*
!            CHANGE_PCT and CHANGE_PTS).  Insert a new compensation    *
!                                                                      *
! Called by: PROCESS_EMPS                                              *
!***********************************************************************
begin-procedure Determine-New-Compensations

  ! *** Starting at the first rate code entry for the new step insert
  ! *** a new compensation record directly releated to the RATECD
  ! *** for the new step
  let #out_cp_idx = #New_comp_begin_idx
  let #out_cp_cnt = #New_comp_end_idx

  ! *** All ratecd entries for NEW STEP are turned into COMPENSATIONS
  ! *** Comprate reflects post Frequency but pre Currency conversion
     while #out_cp_idx <= #out_cp_cnt
       get #out_Comp_effseq       from  stepcomp (#out_cp_idx) sc_comp_effseq
       get $out_Comp_ratecd       from  stepcomp (#out_cp_idx) sc_comp_ratecd
       get #out_Comp_rate_points  from  stepcomp (#out_cp_idx) sc_comp_rate_points
       get #out_Comprate          from  stepcomp (#out_cp_idx) sc_comprate
       get #out_Comp_pct          from  stepcomp (#out_cp_idx) sc_comp_pct
       get $out_Comp_frequency    from  stepcomp (#out_cp_idx) sc_comp_frequency
       get $out_Currency_cd       from  stepcomp (#out_cp_idx) sc_currency_cd
       get $out_Rate_code_group   from  stepcomp (#out_cp_idx) sc_rate_code_group
       get $out_comp_rate_type    from  stepcomp (#out_cp_idx) rc_comp_rate_type
       get $out_comp_base_pay_sw  from  stepcomp (#out_cp_idx) rc_comp_base_pay_sw

       let $out_Manual_sw         =  'N'
       let $out_cmp_src_ind       =  'S'

       !*** When doing a manual step upgrade the FTE flag defaults to N ***
       let $out_FTE_Indicator     =  'N'

       ! ***** Determine the Convert Comprate for record by applying
       ! ***** Currency Factor
       do CONVERTCURRENCY(#out_Comprate,$out_Currency_cd,&A.CURRENCY_CD,
                      'OFFIC',&A.EFFDT,#out_wk_Convert_Comprate,'W')

       ! **** New to build 36
       do CONVERT-FREQUENCY(&A.EFFDT,#out_wk_Convert_Comprate,$out_comp_frequency,&A.COMP_FREQUENCY,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#out_Convert_Comprate)

       ! ***** Now calculate difference between rate before and rate after if
       ! ***** it existed prior to this new job step
       let $Comp_find_mode = 'RATECD'
       let #start_find_idx = 0
       do FIND_OLD_COMPENSATION

       ! ***** If an old entry for the Rate code not found then all change
       ! ***** amounts are set to 0
       ! ***** $Old_ratecd_fnd set in Find_old_compensation as is old_comp_idx
       if $Old_ratecd_fnd = 'N'
           let #out_comp_change_amt = 0
           let #out_comp_change_pct = 0
           let #out_comp_change_pts = 0

           !*****  According to HR rules of the Job page FTE is disabled when
           !****** Frequency is H, Rate type is PC, HF, or HR and Base Pay SW = N

           if $out_Comp_frequency <> 'H' and $out_comp_rate_type <> 'PC' and
              $out_comp_rate_type <> 'HF' and $out_comp_rate_type <> 'HR' and
              $out_comp_base_pay_sw <> 'N'

               if &A.FTE <> 0.00 and &A.FTE <> 1
                   let #out_Convert_Comprate = #out_Convert_Comprate * &A.FTE
                   let $out_FTE_Indicator     =  'Y'
               end-if
           end-if

       else

           get #Old_comp_amt from comparray (#old_comp_idx) cp_comprate
           get #Old_comp_pts from comparray (#old_comp_idx) cp_comp_rate_points
           get $old_comp_frequency from comparray (#old_comp_idx) cp_comp_frequency
           get $old_comp_currency from comparray (#old_comp_idx) cp_currency_cd
           get $old_fte_indicator from comparray (#old_comp_idx) cp_fte_indicator

           if $old_fte_indicator = 'Y' and &A.FTE <> 0.00
              let #out_Convert_Comprate = #out_Convert_Comprate * &A.FTE
              let $out_FTE_Indicator     =  'Y'
           end-if

           ! ***** Determine the Convert Comprate for record by applying
           ! ***** Currency Factor
           do CONVERTCURRENCY(#old_comp_amt,$old_comp_currency,$out_Currency_cd,
                      'OFFIC',&A.EFFDT,#out_work_Comprate,'W')

           ! ***** Make sure for change amounts we are comparing the same frequency IE Apple to Apple
           do CONVERT-FREQUENCY(&A.EFFDT,#out_work_Comprate,$old_comp_frequency,$out_comp_frequency,
                        &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#out_work_Comprate)

           let #out_comp_change_amt = #out_Comprate - #out_work_Comprate
           let #out_comp_change_pts = #out_Comp_rate_points - #Old_comp_pts

           ! **** Change percentage
           if #Old_comp_amt <> 0
              let #out_comp_change_Pct = round(#out_Comp_change_amt / #out_work_comprate * 100, 3)
           else
              let #out_comp_change_Pct = 0
           end-if
       end-if

       !****** Create new Compensation record for new job
       do INSERT-NEW-COMP-REC

       add 1 to #out_cp_idx

     end-while                                    !*** All new compensation now inserted

   !*** Now copy SENPAY from old compensation to new compensation
   !***  setting the find mode to look for class in FInd Old Compensatation
   let $Comp_Find_mode = 'CLASS'
   let #start_find_idx = 0
   let $out_rate_code_class = 'SENPAY'

   !* Make sure at least one search is performed
   let $old_ratecd_fnd = 'Y'

   !*** Continue searching until no more entries are found
   while $old_ratecd_fnd <> 'N'
         do find_old_compensation

         if $old_ratecd_fnd = 'Y'

                get #out_Comp_effseq       from  comparray (#old_comp_idx) cp_comp_effseq
                get $out_Comp_ratecd       from  comparray (#old_comp_idx) cp_comp_ratecd
                get #out_Comp_rate_points  from  comparray (#old_comp_idx) cp_comp_rate_points
                get #out_Comprate          from  comparray (#old_comp_idx) cp_comprate
                get #out_Comp_pct          from  comparray (#old_comp_idx) cp_comp_pct
                get $out_Comp_frequency    from  comparray (#old_comp_idx) cp_comp_frequency
                get $out_Currency_cd       from  comparray (#old_comp_idx) cp_currency_cd
                get $out_Rate_code_group   from  comparray (#old_comp_idx) cp_rate_code_group
                get $out_Manual_sw         from  comparray (#old_comp_idx) cp_manual_sw
                get $out_FTE_Indicator     from  comparray (#old_comp_idx) cp_fte_indicator
                get $out_cmp_src_ind       from  comparray (#old_comp_idx) cp_cmp_src_ind
                get #out_Convert_Comprate  from  comparray (#old_comp_idx)  cp_convert_comprt

                ! ***** amounts are set to 0
                let #out_comp_change_amt = 0
                let #out_comp_change_pct = 0
                let #out_comp_change_pts = 0

                !****** Create a copy of Compensation record for new job
                do INSERT-NEW-COMP-REC

        end-if

        !*** For the next loop make sure we dont search entries we have already searched
        let #start_find_idx = #old_comp_idx

    end-while

   !Add on any Manual entries
   !***  setting the find mode to look for class in FInd Old Compensatation
   let $Comp_Find_mode = 'MANUAL'
   let #start_find_idx = 0
   let $out_rate_code_class = 'SENPAY'

   !* Make sure at least one search is performed
   let $old_ratecd_fnd = 'Y'

   !*** Continue searching until no more entries are found
   while $old_ratecd_fnd <> 'N'
         do find_old_compensation

         if $old_ratecd_fnd = 'Y'

                get #out_Comp_effseq       from  comparray (#old_comp_idx) cp_comp_effseq
                get $out_Comp_ratecd       from  comparray (#old_comp_idx) cp_comp_ratecd
                get #out_Comp_rate_points  from  comparray (#old_comp_idx) cp_comp_rate_points
                get #out_Comprate          from  comparray (#old_comp_idx) cp_comprate
                get #out_Comp_pct          from  comparray (#old_comp_idx) cp_comp_pct
                get $out_Comp_frequency    from  comparray (#old_comp_idx) cp_comp_frequency
                get $out_Currency_cd       from  comparray (#old_comp_idx) cp_currency_cd
                get $out_Rate_code_group   from  comparray (#old_comp_idx) cp_rate_code_group
                get $out_Manual_sw         from  comparray (#old_comp_idx) cp_manual_sw
                get $out_FTE_Indicator     from  comparray (#old_comp_idx) cp_fte_indicator
                get $out_cmp_src_ind       from  comparray (#old_comp_idx) cp_cmp_src_ind
                get #out_Convert_Comprate  from  comparray (#old_comp_idx) cp_convert_comprt

                ! ***** amounts are set to 0
                let #out_comp_change_amt = 0
                let #out_comp_change_pct = 0
                let #out_comp_change_pts = 0

                !****** Create a copy of Compensation record for new job
                do INSERT-NEW-COMP-REC

        end-if

        !*** For the next loop make sure we dont search entries we have already searched
        let #start_find_idx = #old_comp_idx

    end-while

end-procedure

!***********************************************************************
! Procedure: INSERT-NEW-COMP-REC                                       *
! Descr:     Inserts a new record into the application table           *
!            PS_COMPENSATION.  This procedure is performed multiple    *
!            times per single JOB row insert.                          *
!                                                                      *
! Called by: GET-STEPS                                                 *
!***********************************************************************
begin-procedure INSERT-NEW-COMP-REC
let $SQL-Statement = 'CMP107.SQR, INSERT-NEW-COMP-REC'

if isnull($out_Rate_Code_Group)
    let $out_Rate_Code_Group = ' '
end-if

begin-SQL on-error=SQL-Error

INSERT INTO PS_COMPENSATION
( EMPLID
, EMPL_RCD
, EFFDT
, EFFSEQ
, COMP_EFFSEQ
, COMP_RATECD
, COMP_RATE_POINTS
, COMPRATE
, COMP_PCT
, COMP_FREQUENCY
, CURRENCY_CD
, MANUAL_SW
, CONVERT_COMPRT
, RATE_CODE_GROUP
, CHANGE_AMT
, CHANGE_PCT
, CHANGE_PTS
, FTE_INDICATOR
, CMP_SRC_IND  )
VALUES
( &A.EmplID
, &A.Empl_Rcd
, $new_JobRec_effdt
, #new_JobRec_effseq
, #out_Comp_Effseq
, $out_Comp_Ratecd
, #out_Comp_Rate_Points
, #out_Comprate
, #out_Comp_Pct
, $out_Comp_Frequency
, $out_Currency_Cd
, $out_Manual_Sw
, #out_Convert_Comprate
, $out_Rate_Code_Group
, #out_comp_change_amt
, #out_comp_change_pct
, #out_comp_change_pts
, $out_Fte_Indicator
, $out_cmp_src_ind  )
end-SQL

end-procedure !INSERT-NEW-COMP-REC

!***********************************************************************
! Procedure: INSERT-NEW-JOBDIST-REC                                    *
! Descr:     An employee has just quialified for a step increase, use  *
!            insert a copy of the original JOB EARNS DIST only this one*
!            is related to the JOB row we just inserted                *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure Insert-New-JobDist-Rec
let $SQL-Statement = 'CMP107.SQR, Insert-New-JobDist-Rec'
begin-SQL on-error=SQL-Error

INSERT INTO PS_JOB_EARNS_DIST
(EMPLID,
 EMPL_RCD ,
 EFFDT,
 EFFSEQ,
 DEPTID,
 JOBCODE,
 POSITION_NBR,
 GL_PAY_TYPE,
 ACCT_CD,
 SHIFT,
 LOCATION,
 ERNCD,
 COMPRATE,
 DIST_PCT,
 STD_HOURS,
 BUSINESS_UNIT)
VALUES
(&J.EmplID,
 &J.Empl_Rcd,
 $new_JobRec_effdt,
 #new_JobRec_effseq,
 &J.DeptID,
 &J.JobCode,
 &J.Position_Nbr,
 &J.GL_Pay_Type,
 &J.Acct_CD,
 &J.Shift,
 &J.Location,
 &J.Erncd,
 &J.Comprate,
 &J.Dist_Pct,
 &J.Std_Hours,
 &J.Business_Unit)
end-SQL

end-procedure

!***********************************************************************
! Procedure: INSERT-NEW-JOBJR-REC                                      *
! Descr:     An employee has just quialified for a step increase, use  *
!            insert a copy of the original JOB JR only the  one        *
!            is related to the JOB row we just inserted                *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure Insert-New-JobJr-Rec

let $SQL-Statement = 'CMP107.SQR, Insert-New-JobJr-Rec'

!*** Oracle database requires {DatetimeIn-Prefix} on insert statement

begin-SQL on-error=SQL-Error

INSERT INTO PS_JOB_JR
(EMPLID,
 EMPL_RCD,
 EFFDT,
 EFFSEQ,
 LASTUPDDTTM,
 LASTUPDOPRID,
 TAXCODE_UK,
 TAX_BASIS_UK,
 WORKER_TYPE_MEX,
 REDUCED_WEEK_MEX,
 LOCATED_CD_MEX,
 SALARY_TYPE_MEX,
 IMS_TERM_DT_MEX,
 BALANCE_GRP_NUM,
 FP_ACTION_2,
 CTG_RATE,
 FP_LEGALSTAT_CD,
 FP_SCNDMT_CD,
 FP_SCND_TYP,
 FP_CIVIL_PENSION,
 FP_SOURCE_ORG,
 FP_RECEP_ORG,
 FP_RETURN_CD,
 FP_PR_LEGSTA,
 FP_FOREND_DT,
 FP_END_DT,
 FP_CAREFRZPCT,
 FP_HIR_DOS_SIT,
 FP_PT_PCT_DET,
 FP_TITLE_NUM,
 FP_DURATION_PCT,
 FP_RATING_PRS_FLG,
 FP_BUDGET_NBR,
 FP_HDCNT_NBR,
 FP_POTENT_NBR,
 FP_RANK_CD,
 FP_STEP_CD,
 FP_RK_ENT_DT,
 FP_CORPS_CD,
 FP_CHG_COR_DT,
 FP_CATG_FP,
 FP_CATG_LEVEL,
 FP_RK_TRIALPD,
 FP_STEP_END_DT,
 FP_FOR_PROM_DT,
 FP_NOMINATION_DT,
 FP_TRAINEE,
 FP_TRNE_POSN,
 FP_RK_PD_END_DT,
 FP_SANCTION,
 FP_DOWN_GRA,
 FP_APPL_SAL_DT,
 FP_CHG_IND,
 FP_CLD_INST,
 FP_SETID_RANK,
 FP_INSTALL_DT,
 FP_EQUIV_STEP,
 FP_STEP_CD2,
 FP_BUSINESS_CD,
 FP_APPL_DT,
 FP_CHG_SAL,
 FP_POINTYP_CD,
 FP_GROSS_IND,
 FP_INCS_IND,
 FP_INCS_IND2,
 FP_PT_PCT,
 FP_PT_END_DT,
 FP_PT_FOREND_DT,
 FP_COMPRATE,
 FP_INST_STAT,
 FP_RETROSPECT,
 FP_ROW_END_DT,
 LAST_UPDATE_DATE,
 OTHER_ID_JPN,
 INTCP_XFR_FLG,
 INTCP_XFR_START_DT,
 INTCP_XFR_END_DT,
 INTCP_BUS_UNIT,
 INTCP_DEPTID,
 INTCP_DEPTID2,
 INTCP_SETID_DEPT,
 INTCP_COMPANY,
 INTCP_COMPANY2,
 INTCP_SUPV_LVL_ID,
 INTCP_SUPV_LVL_ID2,
 START_DATE_JPN,
 EXP_END_DATE_JPN,
 END_DATE_JPN,
 DUTIES_TYPE,
 ASSIGNMENT_ID,
 TARGET_COMPRATE,
 CMP_DONT_ABSORB,
 SSN_EMPLOYER,
 !SUSBTIT_REASON_ESP,
 !SUSBTIT_EMPLID_ESP,
 !PART_SUBROGTN_ESP,
 !LABOR_RLTNSHIP_ESP,
 !INACTIVITY_TYP_ESP,
 !PART_STRK_ACT_ESP,
 UNITA_PROD_CD,
 ACTION_ITA,
 ACTION_REASON_ITA,
 SPECIAL_HIRCTG_ITA,
 PART_TIME_TYPE_ITA,
 PART_TIME_PERC_ITA,
 PARTTIME_ENDDT_ITA,
 WORKDAYS_NLD,
 CONT_SAL_TYPE_BRA,
 CBO_CD_BRA,
 SEFIP_CATEGORY_BRA,
 UNION_CD_ALT_BRA
 )
VALUES
(&A.EmplID,
 &A.Empl_Rcd,
 $new_JobRec_effdt,
 #new_JobRec_effseq,
 {DatetimeIn-Prefix}$SysDateTime{DatetimeIn-Suffix},!From Curdttim routines
 $OperatorId,                                       !From HRGETVAL routines,
 &JJR.TaxCode_UK,
 &JJR.Tax_Basis_UK,
 &JJR.WORKER_TYPE_MEX,
 &JJR.REDUCED_WEEK_MEX,
 &JJR.LOCATED_CD_MEX,
 &JJR.SALARY_TYPE_MEX,
 &JJR.IMS_TERM_DT_MEX,
 &JJR.BALANCE_GRP_NUM,
 &JJR.FP_ACTION_2,
 &JJR.CTG_RATE,
 &JJR.FP_LEGALSTAT_CD,
 &JJR.FP_SCNDMT_CD,
 &JJR.FP_SCND_TYP,
 &JJR.FP_CIVIL_PENSION,
 &JJR.FP_SOURCE_ORG,
 &JJR.FP_RECEP_ORG,
 &JJR.FP_RETURN_CD,
 &JJR.FP_PR_LEGSTA,
 &JJR.FP_FOREND_DT,
 &JJR.FP_END_DT,
 &JJR.FP_CAREFRZPCT,
 &JJR.FP_HIR_DOS_SIT,
 &JJR.FP_PT_PCT_DET,
 &JJR.FP_TITLE_NUM,
 &JJR.FP_DURATION_PCT,
 &JJR.FP_RATING_PRS_FLG,
 &JJR.FP_BUDGET_NBR,
 &JJR.FP_HDCNT_NBR,
 &JJR.FP_POTENT_NBR,
 &JJR.FP_RANK_CD,
 &JJR.FP_STEP_CD,
 &JJR.FP_RK_ENT_DT,
 &JJR.FP_CORPS_CD,
 &JJR.FP_CHG_COR_DT,
 &JJR.FP_CATG_FP,
 &JJR.FP_CATG_LEVEL,
 &JJR.FP_RK_TRIALPD,
 &JJR.FP_STEP_END_DT,
 &JJR.FP_FOR_PROM_DT,
 &JJR.FP_NOMINATION_DT,
 &JJR.FP_TRAINEE,
 &JJR.FP_TRNE_POSN,
 &JJR.FP_RK_PD_END_DT,
 &JJR.FP_SANCTION,
 &JJR.FP_DOWN_GRA,
 &JJR.FP_APPL_SAL_DT,
 &JJR.FP_CHG_IND,
 &JJR.FP_CLD_INST,
 &JJR.FP_SETID_RANK,
 &JJR.FP_INSTALL_DT,
 &JJR.FP_EQUIV_STEP,
 &JJR.FP_STEP_CD2,
 &JJR.FP_BUSINESS_CD,
 &JJR.FP_APPL_DT,
 &JJR.FP_CHG_SAL,
 &JJR.FP_POINTYP_CD,
 &JJR.FP_GROSS_IND,
 &JJR.FP_INCS_IND,
 &JJR.FP_INCS_IND2,
 &JJR.FP_PT_PCT,
 &JJR.FP_PT_END_DT,
 &JJR.FP_PT_FOREND_DT,
 &JJR.FP_COMPRATE,
 &JJR.FP_INST_STAT,
 &JJR.FP_RETROSPECT,
 &JJR.FP_ROW_END_DT,
 &JJR.LAST_UPDATE_DATE,
 &JJR.OTHER_ID_JPN,
 &JJR.INTCP_XFR_FLG,
 &JJR.INTCP_XFR_START_DT,
 &JJR.INTCP_XFR_END_DT,
 &JJR.INTCP_BUS_UNIT,
 &JJR.INTCP_DEPTID,
 &JJR.INTCP_DEPTID2,
 &JJR.INTCP_SETID_DEPT,
 &JJR.INTCP_COMPANY,
 &JJR.INTCP_COMPANY2,
 &JJR.INTCP_SUPV_LVL_ID,
 &JJR.INTCP_SUPV_LVL_ID2,
 &JJR.START_DATE_JPN,
 &JJR.EXP_END_DATE_JPN,
 &JJR.END_DATE_JPN,
 &JJR.DUTIES_TYPE,
 &JJR.ASSIGNMENT_ID,
 &JJR.TARGET_COMPRATE,
 &JJR.CMP_DONT_ABSORB,
 &JJR.SSN_EMPLOYER,
 !&JJR.SUSBTIT_REASON_ESP,
 !&JJR.SUSBTIT_EMPLID_ESP,
 !&JJR.PART_SUBROGTN_ESP,
 !&JJR.LABOR_RLTNSHIP_ESP,
 !&JJR.INACTIVITY_TYP_ESP,
 !&JJR.PART_STRK_ACT_ESP,
 &JJR.UNITA_PROD_CD,
 &JJR.ACTION_ITA,
 &JJR.ACTION_REASON_ITA,
 &JJR.SPECIAL_HIRCTG_ITA,
 &JJR.PART_TIME_TYPE_ITA,
 &JJR.PART_TIME_PERC_ITA,
 &JJR.PARTTIME_ENDDT_ITA,
 &JJR.WORKDAYS_NLD,
 &JJR.CONT_SAL_TYPE_BRA,
 &JJR.CBO_CD_BRA,
 &JJR.SEFIP_CATEGORY_BRA,
 &JJR.UNION_CD_ALT_BRA
 )
end-SQL

end-procedure  Insert-New-JobJr-Rec

!***********************************************************************
! Procedure: INSERT-NEW-JOBAUS-REC                                     *
! Descr:     An employee has just quialified for a step increase, use  *
!            insert to copy the original JOB AUS only this one         *
!            is related to the JOB JR row we just inserted             *
!                                                                      *
! Called by: Proc-Job-Aus                                              *
!***********************************************************************
begin-procedure Insert-New-JobAus-Rec

let $SQL-Statement = 'CMP107.SQR, Insert-New-JobAus-Rec'

!*** Oracle database requires {DatetimeIn-Prefix} on insert statement

begin-SQL on-error=SQL-Error

INSERT INTO PS_JOB_AUS
( EMPLID,
  EMPL_RCD,
  EFFDT,
  EFFSEQ,
  CASUAL_IND,
  SALARY_PACKAGED,
  PAYROLL_STATE_AUS,
  CLASSN_CURRENT_AUS,
  WORK_SECTOR_AUS,
  FUNCTION_AUS,
  ANN_CNTACT_HRS_AUS,
  TEACH_WEEKS_AUS,
  CASUAL_TYPE_AUS,
  TERM_TYPE_AUS,
  TERM_LTD_AUS )

VALUES
( &A.EmplID,
  &A.Empl_Rcd,
  $new_JobRec_effdt,
  #new_JobRec_effseq,
  $JAUS_CASUAL_IND,
  $JAUS_SALARY_PACKAGED,
  $JAUS_PAYROLL_STATE_AUS,
  #JAUS_CLASSN_CURRENT_AUS,
  $JAUS_WORK_SECTOR_AUS,
  $JAUS_FUNCTION_AUS,
  #JAUS_ANN_CNTACT_HRS_AUS,
  #JAUS_TEACH_WEEKS_AUS,
  $JAUS_CASUAL_TYPE_AUS,
  $JAUS_TERM_TYPE_AUS,
  #JAUS_TERM_LTD_AUS )
end-SQL

end-procedure  Insert-New-JobAus-Rec

!***********************************************************************
! Procedure: RESET-ACCUM-HOURS                                         *
! Descr:     Insert a new Earnings Balance for Canadian or US          *
!            earnings.  The hours reamining after the incremental hours*
!            have been subtracted are placed on the new Earnings row   *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure Reset-Accum-Hours

  if &P.COUNTRY = 'CAN'
     do Reset-CAN-Accum-Hours
  else
     do Reset-USA-Accum-Hours
  end-if

end-procedure

!***********************************************************************
! Procedure: RESET-CAN-ACCUM-HOURS                                     *
! Descr:     Insert a new Earnings Balance for Canadian                *
!            earnings.  The hours reamining after the incremental hours*
!            have been subtracted are placed on the new Earnings row   *
!                                                                      *
! Called by: RESET-ACCUM-HOURS                                         *
!***********************************************************************
Begin-Procedure Reset-CAN-Accum-Hours

let $SQL-Statement = 'CMP107.SQR, Reset-CAN-Accum-Hours'
begin-SQL on-error=SQL-Error
DELETE FROM PS_CAN_ERN_BALANCE
WHERE EMPLID       = &A.EmplID
 AND  ERNCD        = &Z.Step_Increm_Accum
 AND  SPCL_BALANCE = 'Y'
end-SQL

! Create a new special balance record containing remaining hours; use
! most recent company, wage loss plan, year, quarter, and month

let $SQL-Statement = 'CMP107.SQR, Reset-CAN-Accum-Hours'
begin-SQL on-error=SQL-Error
INSERT INTO PS_CAN_ERN_BALANCE
(EMPLID,
 EMPL_RCD,
 COMPANY,
 BALANCE_YEAR,
 BALANCE_ID,
 WAGE_LOSS_PLAN,
 PROVINCE,
 BALANCE_QTR,
 BALANCE_PERIOD,
 SPCL_BALANCE,
 ERNCD,
 HRS_YTD,
 HRS_QTD,
 HRS_MTD,
 GRS_YTD,
 GRS_QTD,
 GRS_MTD)
VALUES
(&A.EmplID,
 &A.Empl_rcd,
 &F.Company,
 &F.Balance_Year,
 &F.Balance_Id,
 &F.Wage_Loss_Plan,
 &F.Province,
 &F.Balance_Qtr,
 &F.Balance_Period,
 'Y',
 &Z.Step_Increm_Accum,
 #Remain_Hours,
 #Remain_Hours,
 #Remain_Hours,
 0,
 0,
 0)
end-SQL

end-procedure

!***********************************************************************
! Procedure: RESET-USA-ACCUM-HOURS                                     *
! Descr:     Insert a new Earnings Balance for other than Canadian     *
!            earnings.  The hours reamining after the incremental hours*
!            have been subtracted are placed on the new Earnings row   *
!                                                                      *
! Called by: RESET-ACCUM-HOURS                                         *
!***********************************************************************
Begin-Procedure Reset-USA-Accum-Hours

let $SQL-Statement = 'CMP107.SQR, Reset-USA-Accum-Hours'
begin-SQL on-error=SQL-Error
DELETE FROM PS_EARNINGS_BAL
WHERE EMPLID       = &A.EmplID
 AND  ERNCD        = &Z.Step_Increm_Accum
 AND  SPCL_BALANCE = 'Y'
end-SQL

! Create a new special balance record containing remaining hours; use
! most recent company, wage loss plan, year, quarter, and month

let $SQL-Statement = 'CMP107.SQR, Reset-USA-Accum-Hours'
begin-SQL on-error=SQL-Error
INSERT INTO PS_EARNINGS_BAL
(EMPLID,
 EMPL_RCD,
 COMPANY,
 BALANCE_YEAR,
 BALANCE_ID,
 BALANCE_QTR,
 BALANCE_PERIOD,
 SPCL_BALANCE,
 ERNCD,
 HRS_YTD,
 HRS_QTD,
 HRS_MTD,
 GRS_YTD,
 GRS_QTD,
 GRS_MTD)
VALUES
(&A.EmplID,
 &A.Empl_rcd,
 &H.Company,
 &H.Balance_Year,
 &H.Balance_Id,
 &H.Balance_Qtr,
 &H.Balance_Period,
 'Y',
 &Z.Step_Increm_Accum,
 #Remain_Hours,
 #Remain_Hours,
 #Remain_Hours,
 0,
 0,
 0)
end-SQL

end-procedure

!***********************************************************************
! Procedure: CHECK-AUDITS                                              *
! Descr:     Create Audit records on the database for any fields       *
!            specified for auditing by the user on the RUN parameters, *
!            calls the Insert Audit Rec if field was sepecified for    *
!            auditing                                                  *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure Check-Audits

  do Format-Number(#New_EffSeq, $New_EffSeq, '999')
  let $New-EffSeq = ltrim($New_EffSeq,' ')
  if $Audit-Step  = 'Y'
    let $FieldName = 'STEP'
    do Format-Number(&A.STEP, $OldValue, '99')
    let $OldValue = ltrim($OldValue,' ')
    do Format-Number(#New_Step, $NewValue, '99')
    let $NewValue = ltrim($NewValue,' ')
    do Insert-Audit-Rec
  end-if
  if $Audit-Step-Entry-Dt = 'Y'
    let $FieldName = 'STEP_ENTRY_DT'
    let $OldValue = &A.STEP_ENTRY_DT
    let $NewValue = $New_EffDt
    do Insert-Audit-Rec
  end-if
  if $Audit-Comprate  = 'Y'
    let $FieldName = 'COMPRATE'
    do Format-Number(&A.COMPRATE, $OldValue,   '999999999999.999999')
    let $OldValue = ltrim($OldValue,' ')
    do Format-Number(#New_Comprate, $NewValue, '999999999999.999999')
    let $NewValue = ltrim($NewValue,' ')
    do Insert-Audit-Rec
  end-if
  if $Audit-HourlyRt  = 'Y'
    let $FieldName = 'HOURLY_RT'
    do Format-Number(&A.HOURLY_RT, $OldValue,   '999999999999.999999')
    let $OldValue = ltrim($OldValue,' ')
    do Format-Number(#New_Hourly_Rt, $NewValue, '999999999999.999999')
    let $NewValue = ltrim($NewValue,' ')
    do Insert-Audit-Rec
  end-if
  if $Audit-MonthlyRt  = 'Y'
    let $FieldName = 'MONTHLY_RT'
    do Format-Number(&A.MONTHLY_RT, $OldValue,   '999999999999999.999')
    let $OldValue = ltrim($OldValue,' ')
    do Format-Number(#New_Monthly_Rt, $NewValue, '999999999999999.999')
    let $NewValue = ltrim($NewValue,' ')
    do Insert-Audit-Rec
  end-if
  if $Audit-AnnualRt  = 'Y'
    let $FieldName = 'ANNUAL_RT'
    do Format-Number(&A.ANNUAL_RT, $OldValue,    '999999999999999.999')
    let $OldValue = ltrim($OldValue,' ')
    do Format-Number(#New_Annual_Rt, $NewValue,  '999999999999999.999')
    let $NewValue = ltrim($NewValue,' ')
    do Insert-Audit-Rec
  end-if
  if $Audit-ChangeAmt  = 'Y'
    let $FieldName = 'CHANGE_AMT'
    do Format-Number(&A.CHANGE_AMT, $OldValue,   '999999999999.999999')
    let $OldValue = ltrim($OldValue,' ')
    do Format-Number(#New_Change_Amt, $NewValue, '999999999999.999999')
    let $NewValue = ltrim($NewValue,' ')
    do Insert-Audit-Rec
  end-if
  if $Audit-ChangePct  = 'Y'
    let $FieldName = 'CHANGE_PCT'
    do Format-Number(&A.CHANGE_PCT, $OldValue, '999.999')
    let $OldValue = ltrim($OldValue,' ')
    do Format-Number(#New_Change_Pct, $NewValue, '999.999')
    let $NewValue = ltrim($NewValue,' ')
    do Insert-Audit-Rec
   end-if

end-procedure

!***********************************************************************
! Procedure: INSERT-AUDIT-REC                                          *
! Descr:     Create Audit records on the database                      *
!                                                                      *
! Called by: CHECK-AUDITS                                              *
!***********************************************************************
begin-procedure Insert-Audit-Rec

let $SQL-Statement = 'CMP107.SQR, Insert-Audit-Rec'
let $Empl_Rcd = to_char(&A.EMPL_RCD)

if isnull($OldValue)
    let $OldValue = ' '
end-if

begin-SQL on-error=SQL-Error

INSERT INTO PSAUDIT
(AUDIT_OPRID,
 AUDIT_STAMP,
 AUDIT_ACTN,
 RECNAME,
 FIELDNAME,
 OLDVALUE,
 NEWVALUE,
 KEY1,
 KEY2,
 KEY3,
 KEY4,
 KEY5,
 KEY6,
 KEY7,
 KEY8,
 KEY9,
 KEY10,
 KEY11,
 KEY12,
 KEY13,
 KEY14,
 KEY15)
VALUES
('STEPINC',
 {DateTimeIn-Prefix}$SysDateTime{DateTimeIn-Suffix},
 'A',
 'JOB',
 $FieldName,
 $OldValue,
 $NewValue,
 &A.EmplID,
 $Empl_Rcd,
 $New_EffDt,
 $New_EffSeq,
 ' ',
 ' ',
 ' ',
 ' ',
 ' ',
 ' ',
 ' ',
 ' ',
 ' ',
 ' ',
 ' ')
end-SQL
end-procedure

!***********************************************************************
! Procedure: UPDATE_EMPL_INCREASE_DT                                   *
! Descr:     Updates the PS Employment row with the date of the last   *
!            rate increase. If there was a step increase then date of  *
!            the new job is the date of the last increase              *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure Update-Empl-Increase-Dt

let $sql-statement = 'CMP107.SQR,Update-Empl-Increase_Dt,UPDATE PS_PER_ORG_ASGN'
begin-sql on-error=SQL-Error
UPDATE PS_PER_ORG_ASGN
SET LAST_INCREASE_DT = $New_EffDt
where EMPLID    = &A.Emplid
and   EMPL_RCD  = &A.Empl_Rcd
end-SQL

end-procedure

!***********************************************************************
! Procedure: FIND_OLD_COMPENSATION                                     *
! Descr:     While attempting to create the new compensation record    *
!            the change amount and percentage are calculated, these    *
!            values will be based on what was stored for the Ratecd    *
!            in the old compensation
!                                                                      *
! Called by: GET-STEPS                                                 *
!***********************************************************************
begin-procedure FIND_OLD_COMPENSATION

!****** Using the ratecd being written see if it existed in old
!****** Compensation
let $Old_ratecd_fnd = 'N'

if #start_find_idx <> 0
        let #old_comp_idx = #start_find_idx
else
        let #old_comp_idx = 0
end-if

   !***** Search base compensations until rate code is found or no
   !***** no more entries to search
   while $Old_ratecd_fnd = 'N' and #old_comp_idx < #cp_cnt

        add 1 to #old_comp_idx

        if $Comp_find_mode = 'BASE'
               get $Old_comp_ratecd from comparray (#old_comp_idx) cp_comp_ratecd
               get #Old_cp_effseq from comparray (#old_comp_idx) cp_effseq
               get $Old_manual_sw from comparray (#old_comp_idx) cp_manual_sw


               if $NewCP_Comp_Ratecd = $Old_comp_ratecd and #out_Comp_effseq = #Old_cp_effseq
                             and $Old_manual_sw = 'N'
                    move 'Y' to $Old_ratecd_fnd
               end-if
        end-if

        if $Comp_find_mode = 'RATECD'
               get $Old_comp_ratecd from comparray (#old_comp_idx) cp_comp_ratecd
               get #Old_cp_effseq from comparray (#old_comp_idx) cp_effseq
               get $Old_manual_sw from comparray (#old_comp_idx) cp_manual_sw

               if $out_Comp_ratecd = $Old_comp_ratecd and #Out_NewCP_Comp_Effseq = #Old_cp_effseq
                             and $Old_manual_sw = 'N'
                    move 'Y' to $Old_ratecd_fnd
               end-if
        end-if

        if $Comp_find_mode = 'CLASS'
                get $Old_comp_rate_code_class from comparray (#old_comp_idx) cp_rate_code_class

                if $out_rate_code_class = $Old_comp_rate_code_class
                        move 'Y' to $Old_ratecd_fnd
                end-if
        end-if

        if $Comp_find_mode = 'MANUAL'
                get $Old_manual_sw from comparray (#old_comp_idx) cp_manual_sw
                get $Old_comp_rate_code_class from comparray (#old_comp_idx) cp_rate_code_class

                if $Old_manual_sw = 'Y' and $Old_comp_rate_code_class <> $out_rate_code_class
                        move 'Y' to $Old_ratecd_fnd
                end-if
        end-if

   end-while

end-procedure

#Include 'askstpin.sqc'  !Ask step increase parameters
#Include 'curdttim.sqc'  !Routines to get current date/time
#Include 'datetime.sqc'  !Routines for date and time formatting
#Include 'datemath.sqc'  !Routines for working with dates
#Include 'currency.sqc'  !Currency Conversion Routines
#Include 'getbalid.sqc'  !Get-Calendar-Year-Id
#Include 'hrrnctl1.sqc'  !Get run control parameter values
#Include 'hrgetval.sqc'  !Get values mask routines
#Include 'reset.sqc'     !Reset printer
#Include 'stdapi.sqc'    !Routines to Update Run Status
#Include 'sqrtrans.sqc'  !Translate SQR strings to given language       !F-LPARKER-125 (CAMI)
