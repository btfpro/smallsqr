!***********************************************************************
!   TL002:  Time & Labor TimeCard Report                               *
!***********************************************************************
!***********************************************************************
!                                                                      *
!               Confidentiality Information:                           *
!                                                                      *
!                                                                      *
! This module contains confidential and proprietary information        *
! of Oracle; it is not to be copied, reproduced, or transmitted        *
! in any form, by any means, in whole or in part, nor is it to         *
! be used for any purpose other than that for which it is              *
! expressly provided under the applicable license agreement.           *
!                                                                      *
! Copyright (C) 2007 Oracle. All Rights Reserved.                      *
!                                                                      *
!***********************************************************************
!***********************************************************************
!                                                                      *
!          $Date:  2007/02/06:04:22:48                                 !
!       $Release:  HR9                                                 !
!    $Resolution:  688700                                              !
!                                                                      *
!***********************************************************************

#include 'setenv.sqc'   !Set environment

#include 'setup31.sqc'  !Printer and page-size initialization, SETUP31 and
                        !  SETUP32 SQCs to support HTML, HP PCL, PostScript,
                        !  PDF and Window in addition to Line Printer as
                        !  the output type.

!***********************************************************************
!                                                                      *
! begin-report                                                         *
!                                                                      *
! Called By: N/A                                                       *
! Calls:     Init-Processing                                           *
!            Get-Values                                                *
!            Process-Main                                              *
!            Reset                                                     *
!            Print-ReportCount                                         *
!            End-Report                                                *
!                                                                      *
!***********************************************************************

begin-report

#ifdef debugy
        show 'INIT-PROCESSING'
#end-if
        do Init-Processing


#ifdef debugy
        show 'GET-VALUES'
#end-if
        do Get-Values


#ifdef debugy
        show 'PROCESS-MAIN'
#end-if
        do Process-Main


#ifdef debugy
        show 'RESET'
#end-if
        do Reset                        ! called from reset.sqc


#ifdef debugq
        show 'PRINT-REPORTCOUNT'
        do Print-ReportCount
#end-if


#ifdef debugy
        show 'END-REPORT'
#end-if

        do Update-Prcs-Run-Status       ! called from prcsapi.sqc to update
                                        ! the Process Monitor to Success

end-report



!***********************************************************************
!                                                                      *
! Init-Processing                                                      *
!                                                                      *
!                                                                      *
! Called By:    begin-report                                           *
! Calls:        Init-Datetime           - datetime.sqc                 *
!               Get-Current-Datetime    - prcsapi.sqc (curdttim.sqc)   *
!               Define-Prcs-Vars        - prcsapi.sqc (prcsdef.sqc)    *
!               Get-Run-Control-Parms   - prcsapi.sqc                  *
!               Init-Report                                            *
!               Init-Number             - number.sqc                   *
!               Get-Language-Codes      - prcslng.sqc                  *
!                                                                      *
! Description:  Standard PeopleSoft initialization processing.         *
!                                                                      *
!***********************************************************************


begin-procedure Init-Processing


#ifdef debugy
    show 'IN PROCEDURE INIT-PROCESSING'
#end-if


#ifdef debugy
        show 'INIT-DATETIME'
#end-if
        do Init-Datetime                ! called from datetime.sqc


#ifdef debugy
        show 'GET-CURRENT-DATETIME'
#end-if
        do Get-Current-Datetime         ! called from prcsapi.sqc (curdttim.sqc)


#ifdef debugy
        show 'DEFINE-PRCS-VARS'
#end-if
        do Define-Prcs-Vars             ! called from prcsapi.sqc (prcsdef.sqc)


#ifdef debugy
        show 'GET-RUN-CONTROL-PARMS'
#end-if
        do Get-Run-Control-Parms        ! In prcsapi.sqc


#ifdef debugy
        show 'INIT-REPORT'
#end-if
        do Init-Report


#ifdef debugy
        show 'INIT-NUMBER'
#end-if
        do Init-Number                  ! called from number.sqc


#ifdef debugy
        show 'GET-LANGUAGE-CODES'
#end-if
        do Get-Language-Codes           ! called from prcslng.sqc


end-procedure !Init-Processing


!***********************************************************************
!                                                                      *
! Init-Report                                                          *
!                                                                      *
!                                                                      *
! Called By: Init-Processing                                           *
! Calls:     Init_Report_Translation    -   sqrtrans.sqc               *
!            Append_Report_Translation  -   sqrtrans.sqc               *
!            Define-Prcs-Vars                                          *
!            Get_Field_Information                                     *
!            Format-DateTime                                           *
!                                                                      *
! Description:  Initializes variables, defines values for variables    *
!               used in report header, date formatting, time           *
!               formatting, translations & strings tables retrievals.  *
!                                                                      *
!***********************************************************************

begin-procedure Init-Report


#ifdef debugy
    show 'IN PROCEDURE INIT-REPORT'
#end-if


    #define Col_10       1
    #define Col_20       15
    #define Col_25       20
    #define Col_27       23
    #define Col_30       28
    #define Col_35       35
    #define Col_40       42
    #define Col_50       52
    #define Col_60       62
    #define Col_70       72
    #define Col_80       82
    #define Col_82       84
    #define Col_100      100



!***********************************************************************
!                                                                      *
! Translations procedures & Strings Table retrievals.                  *
!                                                                      *
!***********************************************************************


    do Init_Report_Translation ($ReportID,$curr_language_cd)
    do Append_Report_Translation ('TLMAIN')


   do Get_Field_Information ('TLMAIN','EMPLOYEE',            $Employee_lbl,           #DW)
   do Get_Field_Information ('TLMAIN','EMPLOYEE_NAME',       $Employee_Name_lbl,      #DW)
   do Get_Field_Information ('TLMAIN','ID',                  $ID_lbl,                 #DW)
   do Get_Field_Information ('TLMAIN','RECORD#',             $RECORD#_lbl,            #DW)
   do Get_Field_Information ('TLMAIN','DATE_UNDER_REPORT1',  $Date_Under_Report1_lbl, #DW)
   do Get_Field_Information ('TLMAIN','DATE_UNDER_REPORT2',  $Date_Under_Report2_lbl, #DW)
   do Get_Field_Information ('TLMAIN','STATUS',              $Status_lbl,             #DW)
   do Get_Field_Information ('TLMAIN','TIME_RPTG_CODE1',     $Time_Rptg_Code1_lbl,    #DW)
   do Get_Field_Information ('TLMAIN','TIME_RPTG_CODE2',     $Time_Rptg_Code2_lbl,    #DW)
   do Get_Field_Information ('TLMAIN','DAY1',                $Day1_lbl,               #DW)
   do Get_Field_Information ('TLMAIN','TYPE',                $Type_lbl,               #DW)
do Get_Field_Information ('TLMAIN','TIMEZONE',                $TimeZone_lbl,               #DW)
   do Get_Field_Information ('TLMAIN','QUANTITY',            $Quantity_lbl,           #DW)
   do Get_Field_Information ('TLMAIN','DESCR',               $Descr_lbl,              #DW)
   do Get_Field_Information ('TLMAIN','FOR_THE_PERIOD',      $For_The_Period_lbl,     #DW)
   do Get_Field_Information ('TLMAIN','THROUGH',             $Through_lbl,            #DW)
   do Get_Field_Information ('TLMAIN','EMPLOYEE_ID',         $Employee_ID_lbl,        #DW)
   do Get_Field_Information ('TLMAIN','REPTD_PUNCH_DTL',     $Reptd_Punch_Dtl_lbl,    #DW)
   do Get_Field_Information ('TLMAIN','DATE_TIME',           $Date_Time_lbl,          #DW)
   do Get_Field_Information ('TLMAIN','NO_ROWS_FOUND',       $No_Rows_Found_lbl,      #DW)
   do Get_Field_Information ('TLMAIN','RPTD_ELAPSED_DTL',    $Rptd_Elapsed_Dtl_lbl,   #DW)
   do Get_Field_Information ('TLMAIN','PAYABLE_TIME',        $Payable_Time_lbl,       #DW)
   do Get_Field_Information ('TLMAIN','EE_OUTSTAND_EXCEP',   $EE_Outstand_Excep_lbl,  #DW)
   do Get_Field_Information ('TLMAIN','DATE',                $Date_lbl,               #DW)
   do Get_Field_Information ('TLMAIN','EXCEPTION',           $Exception_lbl,          #DW)
   do Get_Field_Information ('TLMAIN','EE_SIGNATURE',        $EE_Signature_lbl,       #DW)
   do Get_Field_Information ('TLMAIN','APPROV_SIGNATURE',    $Approv_Signature_lbl,   #DW)
   do Get_Field_Information ('TLMAIN','APPROV_NAME',         $Approv_Name_lbl,        #DW)
   do Get_Field_Information ('TLMAIN','PLZ_PRINT',           $Plz_Print_lbl,          #DW)
   do Get_Field_Information ('TLMAIN','SUNDAY',              $Sun_lbl,                #DW)
   do Get_Field_Information ('TLMAIN','MONDAY',              $Mon_lbl,                #DW)
   do Get_Field_Information ('TLMAIN','TUESDAY',             $Tue_lbl,                #DW)
   do Get_Field_Information ('TLMAIN','WEDNESDAY',           $Wed_lbl,                #DW)
   do Get_Field_Information ('TLMAIN','THURSDAY',            $Thu_lbl,                #DW)
   do Get_Field_Information ('TLMAIN','FRIDAY',              $Fri_lbl,                #DW)
   do Get_Field_Information ('TLMAIN','SATURDAY',            $Sat_lbl,                #DW)
   do Get_Field_Information ('TLMAIN','DAY',                 $Day_lbl,                #DW)
   do Get_Field_Information ('TLMAIN','JOB_TITLE',           $Job_Title_lbl,          #DW)
   do Get_Field_Information ('TLMAIN','DEPARTMENT',          $Dept_lbl,               #DW)
   do Get_Field_Information ('TLMAIN','TIMECARD_RPT_TITLE',  $Report_Title_lbl,       #DW)
   do Get_Field_Information ('TLMAIN','TOTAL_AMT',           $Total_Amt_lbl,          #DW)
   do Get_Field_Information ('TLMAIN','TOTAL_UNITS',         $Total_Units_lbl,        #DW)
   do Get_Field_Information ('TLMAIN','TOTAL_HOURS',         $Total_Hrs_lbl,          #DW)
   do Get_Field_Information ('TLMAIN','PAYABLE_STATUS',      $Payable_Status_lbl,     #DW)
   do Get_Field_Information ('TLMAIN','TOTAL_MISSING_TRC',   $Total_Oth_lbl,          #DW)

!***********************************************************************
!                                                                      *
! Dates:   All of Europe uses date format DD/MM/YYYY                   *
!          The US uses date format of MM/DD/YYYY                       *
!                                                                      *
! Numbers: The U.S. and the U.K. use NN,NNN.NN                         *
!          The rest of Europe uses NN.NNN,NN                           *
!                                                                      *
!***********************************************************************

    if $curr_language_cd      = 'ENG'
        let $ReportDateType   = '0'             ! resolved in datetime.sqc
    else
        let $ReportDateType   = '1'
    end-if

    if $curr_language_cd = 'ENG' or $curr_language_cd = 'INE'
        let $ReportSDecimal   = '.'
        let $ReportSThousand  = ','
    else
        let $ReportSDecimal   = ','             ! resolved in number.sqc
        let $ReportSThousand  = '.'             ! resolved in number.sqc
    end-if


!***********************************************************************
!                                                                      *
! Initialize time formatting.                                          *
!                                                                      *
!***********************************************************************

    let $_ReportTime24 = '0'


!***********************************************************************
!                                                                      *
! Initialize date formatting.                                          *
!                                                                      *
!***********************************************************************

    let $Date_Init = '1900-01-01 17:00:00.000'

    #ifdef ORACLE
       let $Date_Init = '01-NOV-1999'
    #end-if

    do Format-DateTime($Date_Init, $out999, {DEFDATE}, '', '')


#ifdef debugy
        show 'datetime   ' noline
        show $out999
#end-if

!***********************************************************************
!                                                                      *
! Report variables.                                                    *
!                                                                      *
!***********************************************************************


    let $ReportID               = 'TL002'
    let $ReportTitle            = $Report_Title_lbl
    let #Maxlines               = 80
    let $Records_Found          = 'N'
    let $Employee_FirstTimeThru = 'Y'


end-procedure !Init-Report


!***************************
begin-heading 9
!***************************

#include 'stdhdgtr.sqc'

#ifdef debugy
        show 'BEGIN-HEADING'
#end-if


    print $FOR_THE_PERIOD_lbl    (,{Col_10})
    print $HdgFromDt             (,+1)
    print $THROUGH_lbl           (,+1)
    print $HdgThruDt             (,+1)


end-heading


!***********************************************************************
!                                                                      *
! Get-Values                                                           *
!                                                                      *
!                                                                      *
! Called By: begin-report                                              *
! Calls:     Ask-Values         -   this program                       *
!            Select-Parameters  -   tlrnctl2.sqc                       *
!                                                                      *
! Description:  If process instance blank, prompt user for input       *
!               If populated, get values from run control              *
!               Format dates to print in header                        *
!                                                                      *
!***********************************************************************

begin-procedure Get-Values


#ifdef debugy
    show 'IN PROCEDURE GET-VALUES'
#end-if


    if $prcs_process_instance = ''
        do Ask-Values
    else
        do Select-Parameters
    end-if



#ifdef debugz
    display 'FromDate from run control:             ' noline
    display $FromDate
    display 'ThruDate from run control:             ' noline
    display $ThruDate
#end-if

    do Format-DateTime($FromDate,$HdgFromDt,{DEFDATE}, '', '')
    do Format-DateTime($ThruDate,$HdgThruDt,{DEFDATE}, '', '')

#ifdef debugz
    display 'FromDate to print in header:      ' noline
    display $HdgFromDt
    display 'ThruDate to print in header:      ' noline
    display $HdgThruDt
#end-if


end-procedure !Get-Values


!***********************************************************************
!                                                                      *
! Ask-Values                                                           *
!                                                                      *
!                                                                      *
! Called By: Get-Values                                                *
! Calls:     none                                                      *
!                                                                      *
! Description: Prompt user to input values                             *
!                                                                      *
!***********************************************************************

begin-procedure Ask-Values


#ifdef debugy
    show 'IN PROCEDURE ASK-VALUES'
#end-if


    input $FromDate         'Enter from date (format 01-01-1998)'      TYPE=date  maxlen=11
    input $ThruDate         'Enter through date (format 01-02-1998)'   TYPE=date  maxlen=11
    input $Run_Cntl_Emplid  'Enter one employee ID'                    TYPE=char  maxlen=10


end-procedure !Ask-Values


!***********************************************************************
!                                                                      *
! Process-Main                                                         *
!                                                                      *
!                                                                      *
! Called By: begin-report                                              *
! Calls:     Empl-Branch                                               *
!            Delete-Rows                                               *
!                                                                      *
!***********************************************************************

begin-procedure Process-Main


#ifdef debugy
    show 'IN PROCEDURE PROCESS-MAIN'
#end-if

    do Empl-Branch
    do Delete-Rows

end-procedure !Process-Main


!***********************************************************************
!                                                                      *
! Delete-Rows                                                          *
!                                                                      *
! Called By: Main                                                      *
! Calls:     none                                                      *
!                                                                      *
! Description:  Deletes rows used by the current process instance for  *
!               cleaning up purposes.                                  *
!                                                                      *
!***********************************************************************


begin-procedure Delete-Rows

#ifdef debugy
    show 'IN PROCEDURE Delete-Rows'
#end-if

#ifdef debugy
    show 'Process_Instance     ' noline
    show  #Process_Instance
#end-if

begin-SQL

DELETE FROM PS_TL_TIMECARD_RPT
WHERE PROCESS_INSTANCE = #Process_Instance

end-SQL

end-procedure Delete-Rows



!***********************************************************************
!                                                                      *
! Empl-Branch                                                          *
!                                                                      *
!                                                                      *
! Called By: Process-Main                                              *
! Calls:     Select-Punch                                              *
!            Select-Elapsed                                            *
!            Select-PayableTime                                        *
!            Select-Exceptions                                         *
!            Print-Signature-Line                                      *
!            Get-JobCodeDescr-Rel-Lang                                 *
!            Get-DeptDescr-Rel-Lang                                    *
!                                                                      *
! Description:  Select employees and associated information based on   *
!               group entered in run control.  If necessary, select    *
!               descriptions from related-language tables.  Call new   *
!               page on employee or employee record change.  Call      *
!               various select procedures for info in report body.     *
!                                                                      *
!***********************************************************************

begin-procedure Empl-Branch


#ifdef debugy
    show 'IN PROCEDURE EMPL-BRANCH'
#end-if


begin-SELECT


#ifdef debugy
    show 'IN SELECT, PROCEDURE EMPL-BRANCH'
#end-if



EMPLDATA2.EMPLID            &EMPLDATA2.EMPLID
EMPLDATA2.EMPL_RCD          &EMPLDATA2.EMPL_RCD
PERSDATA2.NAME              &PERSDATA2.NAME
JOB2.JOBCODE                &JOB2.JOBCODE
JOB2.SETID_JOBCODE          &JOB2.SETID_JOBCODE
JOB2.DEPTID                 &JOB2.DEPTID
JOBCODE2.DESCR              &JOBCODE2.DESCR
DEPT2.DESCR                 &DEPT2.DESCR


    let $Main_Select_Emplid = &EMPLDATA2.EMPLID
    let $EmpRec1            = &EMPLDATA2.EMPL_RCD
    let $Main_Select_EmpRec = substr($EmpRec1, 1, 1)
    let #Main_Select_EmpRec = $Main_Select_EmpRec
    let $Name               = &PERSDATA2.NAME
    let $DeptID             = &JOB2.DEPTID
    let $Dept_Descr         = &DEPT2.DESCR
    let $JobCode            = &JOB2.JOBCODE
    let $Setid_JobCode      = &JOB2.SETID_JOBCODE
    let $Job_Descr          = &JOBCODE2.DESCR


    if $curr_language_cd <> $Psoptions_Language_Cd
        let $Retrieve_Lang_JobCode_Descr = &JOBCODE2.DESCR
        let $Retrieve_Lang_Dept_Descr    = &DEPT2.DESCR

        do Get-JobCodeDescr-Rel-Lang
        do Get-DeptDescr-Rel-Lang
    end-if


    let #Printed_EE_Header  = 0    ! Reset for next EE w/mid-period change
                                   !   so elpased won't print header also
    let #Punch_First_Row    = 1    ! Variable to print header & col names for Punch EE

    let #Punch_Rows_Found   = 0    ! Variable to indicate whether or not Punch rows found for EE


    if $Employee_FirstTimeThru = 'N'
        if $Main_Select_Emplid <> $Prior_Main_Emplid
            new-page
        end-if
    end-if

    if $Employee_FirstTimeThru = 'N'
        if $Main_Select_Emplid = $Prior_Main_Emplid
            if $Main_Select_EmpRec <> $Prior_Main_EmpRec
                new-page
            end-if
        end-if
    end-if

    #ifdef ORACLE
       do Select-Punch-ORA
    #else
       do Select-Punch
    #end-if


    let $Employee_FirstTimeThru = 'N'

    let #Elapsed_First_Row      = 1     ! Variable to print header & col names for Elapsed EE

    let #Elapsed_Rows_Found     = 0     ! Variable to indicate whether or not Elapsed rows found for EE


        do Select-Elapsed




    let #Payable_Time_First_Row = 1     ! Variable to print header & col names for Payable Time Section

    let #Payable_Rows_Found     = 0     ! Variable to indicate whether or not Payable Time rows found for EE


        do Select-PayableTime


    let #Exceptions_First_Row   = 1

    let #Exceptions_Rows_Found  = 0



        do Select-Exceptions

        do Print-Signature-Line


    let $Prior_Main_Emplid = $Main_Select_Emplid
    let $Prior_Main_EmpRec = $Main_Select_EmpRec



   FROM PS_TL_TIMECARD_RPT  EMPLDATA2,
        PS_PERSONAL_DATA    PERSDATA2,
        PS_JOB              JOB2,
        PS_JOBCODE_TBL      JOBCODE2,
        PS_DEPT_TBL         DEPT2

   WHERE EMPLDATA2.EMPLID  = PERSDATA2.EMPLID
    AND EMPLDATA2.PROCESS_INSTANCE = #Process_Instance
    AND JOB2.EMPLID      = EMPLDATA2.EMPLID
    AND JOB2.EMPL_RCD    = EMPLDATA2.EMPL_RCD
    AND JOB2.EFFDT       = (SELECT MAX(EFFDT) FROM PS_JOB
                            WHERE EMPLID     = EMPLDATA2.EMPLID
                              AND EMPL_RCD   = EMPLDATA2.EMPL_RCD
                              AND EFFDT     <= $ThruDate)
    AND JOB2.EFFSEQ      = (SELECT MAX(EFFSEQ) FROM PS_JOB
                             WHERE EMPLID    = JOB2.EMPLID
                               AND EMPL_RCD  = JOB2.EMPL_RCD
                               AND EFFDT     = JOB2.EFFDT)
    AND JOBCODE2.SETID   = JOB2.SETID_JOBCODE
    AND JOBCODE2.JOBCODE = JOB2.JOBCODE
    AND JOBCODE2.EFFDT   = (SELECT MAX(EFFDT) FROM PS_JOBCODE_TBL
                            WHERE SETID      = JOB2.SETID_JOBCODE
                              AND JOBCODE    = JOB2.JOBCODE
                              AND EFFDT     <= $ThruDate
                              AND EFF_STATUS = 'A')
    AND DEPT2.DEPTID     = JOB2.DEPTID
    AND DEPT2.SETID      = JOB2.SETID_DEPT
    AND DEPT2.EFFDT      = (SELECT MAX(EFFDT) FROM PS_DEPT_TBL
                            WHERE DEPTID     = JOB2.DEPTID
                            AND SETID = DEPT2.SETID
                              AND EFFDT     <= $ThruDate
                              AND EFF_STATUS = 'A')


   ORDER BY EMPLDATA2.EMPLID


end-SELECT


end-procedure !Empl-Branch


!***********************************************************************
!                                                                      *
! Select-Punch                                                         *
!                                                                      *
!                                                                      *
! Called By: Group-Branch, Empl-Branch                                 *
! Calls:     Read-Translate-Table                                      *
!            Format-DateTime                                           *
!            dtu-dayofweek$                                            *
!            Print-Punch                                               *
!                                                                      *
! Description:  Selects punch entries for each employees.  Retrieves   *
!               translate values for punch type.  Formats date/time.   *
!               Converts date to day of the week.  Calls procedure to  *
!               print punch info.  Manages variables to control header *
!               printing.                                              *
!                                                                      *
!***********************************************************************

begin-procedure Select-Punch   !PunchTime Reporters


#ifdef debugy
    show 'IN PROCEDURE SELECT-PUNCH'
#end-if

do Convert-To-DTU-Date($ThruDate, $ThruDate_dtu)
do dtu-add-days($ThruDate_dtu, 1, $ThruDate_dtu)
do Convert-From-DTU-Date($ThruDate_dtu, $ThruDate_n)

Let $FromDateTime = $FromDate
Let $ThruDateTime = $ThruDate_n

#ifdef DB2ALL
Let $FromDateTime = $FromDate || '-00.00.00.000000'
Let $ThruDateTime = $ThruDate_n || '-00.00.00.000000'
#end-if

#ifdef INFORMIX
Let $FromDateTime = $FromDate || ' 00:00:00.000'
Let $ThruDateTime = $ThruDate_n || ' 00:00:00.000'
#end-if

begin-SELECT


#ifdef debugy
    show 'IN SELECT, PROCEDURE SELECT-PUNCH'
#end-if


PUNCH.EMPLID        &PUNCH.SELECT_PUNCH_EMPLID
PUNCH.EMPL_RCD      &PUNCH.SELECT_PUNCH_EMPL_RCD
PUNCH.PUNCH_DTTM    &PUNCH.PUNCH_DTTM
PUNCH.PUNCH_TYPE    &PUNCH.PUNCH_TYPE
PUNCH.TIMEZONE      &TIMEZONE


    let $FieldName  = 'PUNCH_TYPE'              ! Input into Read-Translate-Table
    let $FieldValue = &PUNCH.PUNCH_TYPE         ! Input into Read-Translate-Table
    do Read-Translate-Table                     ! Returns XlatShortName, XlatLongName


    let $Select_Punch_Emplid    = &PUNCH.SELECT_PUNCH_EMPLID
    let $EmpRec2                = &PUNCH.SELECT_PUNCH_EMPL_RCD
    let $Select_Punch_EmpRec    = substr($EmpRec2, 1, 1)
    let $Punch_DTTM_In          = &PUNCH.PUNCH_DTTM
    let $Punch_Type             = $XlatShortName
    let $TimeZone               = &TIMEZONE
    do FormatGlobalTime($Punch_DTTM_In, $BSE_TIMEZONE, $TimeZone, $Punch_DTTM_Out)

#ifdef debugy
    show '&PUNCH.PUNCH_DTTM        ' noline
    show  &PUNCH.PUNCH_DTTM
    show '$Punch_DTTM_Out           ' noline
    show  $Punch_DTTM_Out
#end-if

    do Format-DateTime($Punch_DTTM_Out, $Formatted_Punch_DTTM, {DEFDATE}, '', '')

    let $Day_Of_Week_In = $Punch_DTTM_Out
    do Convert-To-DTU-Date($Day_Of_Week_In, $dtu_date)
    do dtu-dayofweek$($dtu_date, $dtu_dayofweek)

    let $Punch_Time             = substr($Punch_DTTM_Out, 12, 5)

    let $Punch_DTTM   = $Formatted_Punch_DTTM || ' ' || $Punch_Time



#ifdef debugy
    show '$Punch_DTTM_In        ' noline
    show  $Punch_DTTM_In
    show '$Formatted_Punch_DTTM ' noline
    show  $Formatted_Punch_DTTM
    show '$Punch_Time           ' noline
    show  $Punch_Time
    show '$Punch_DTTM           ' noline
    show  $Punch_DTTM
    show '$dtu_dayofweek        ' noline
    show  $dtu_dayofweek
    display 'FromDateTime from run control:         ' noline
    display $FromDateTime
    display 'ThruDateTime from run control:         ' noline
    display $ThruDateTime
#end-if


    evaluate $dtu_dayofweek
        when = 'Sunday'
            let $Day_Of_Week = $Sun_lbl
            break
        when = 'Monday'
            let $Day_Of_Week = $Mon_lbl
            break
        when = 'Tuesday'
            let $Day_Of_Week = $Tue_lbl
            break
        when = 'Wednesday'
            let $Day_Of_Week = $Wed_lbl
            break
        when = 'Thursday'
            let $Day_Of_Week = $Thu_lbl
            break
        when = 'Friday'
            let $Day_Of_Week = $Fri_lbl
            break
        when = 'Saturday'
            let $Day_Of_Week = $Sat_lbl
            break
    end-evaluate


    do Print-Punch


    let #Punch_Rows_Found = 1


    let $Prior_Punch_Emplid = $Select_Punch_Emplid
    let $Prior_Punch_EmpRec = $Select_Punch_EmpRec


    FROM PS_TL_RPTD_TIME PUNCH
    WHERE PUNCH.EMPLID       = $Main_Select_Emplid
        AND PUNCH.EMPL_RCD   = #Main_Select_EmpRec 
        AND PUNCH.PUNCH_TYPE IN ('1','2','3','4','5')
        AND PUNCH.PUNCH_DTTM >= $FromDateTime
        AND PUNCH.PUNCH_DTTM <  $ThruDateTime      
    ORDER BY PUNCH.PUNCH_DTTM


end-SELECT


end-procedure !Select-Punch


!***********************************************************************
!                                                                      *
! Select-Punch-ORA                                                     *
!                                                                      *
!                                                                      *
! Called By: Group-Branch, Empl-Branch                                 *
! Calls:     Read-Translate-Table                                      *
!            Format-DateTime                                           *
!            dtu-dayofweek$                                            *
!            Print-Punch                                               *
!                                                                      *
! Description:  Selects punch entries for each employees.  Retrieves   *
!               translate values for punch type.  Formats date/time.   *
!               Converts date to day of the week.  Calls procedure to  *
!               print punch info.  Manages variables to control header *
!               printing.                                              *
!                                                                      *
!***********************************************************************

#ifdef ORACLE

begin-procedure Select-Punch-ORA   !PunchTime Reporters

begin-SELECT

PUNCH.EMPLID        &PUNCH.SELECT_PUNCH_EMPLID2
PUNCH.EMPL_RCD      &PUNCH.SELECT_PUNCH_EMPL_RCD2
TO_CHAR(PUNCH.PUNCH_DTTM,'DD-MON-YYYY_HH:MI:SS_AM')    &PUNCH.PUNCH_DTTM2
PUNCH.PUNCH_TYPE    &PUNCH.PUNCH_TYPE2
PUNCH.TIMEZONE      &TIMEZONE2

    let $FieldName  = 'PUNCH_TYPE'               ! Input into Read-Translate-Table
    let $FieldValue = &PUNCH.PUNCH_TYPE2         ! Input into Read-Translate-Table
    do Read-Translate-Table                      ! Returns XlatShortName, XlatLongName

    let $Select_Punch_Emplid    = &PUNCH.SELECT_PUNCH_EMPLID2
    let $EmpRec2                = &PUNCH.SELECT_PUNCH_EMPL_RCD2
    let $Select_Punch_EmpRec    = substr($EmpRec2, 1, 1)
    let $Punch_DTTM_In          = &PUNCH.PUNCH_DTTM2
    let $Punch_Type             = $XlatShortName
    let $TimeZone               = &TIMEZONE2

    do FormatGlobalTime($Punch_DTTM_In, $BSE_TIMEZONE, $TimeZone, $Punch_DTTM_Out)
    do Format-DateTime($Punch_DTTM_In, $Formatted_Punch_DTTM, {DEFDATE}, '', '')

    let $Day_Of_Week_In = $Punch_DTTM_Out
    do Convert-To-DTU-Date($Day_Of_Week_In, $dtu_date)
    do dtu-dayofweek$($dtu_date, $dtu_dayofweek)

    let $Punch_Time   = substr($Punch_DTTM_Out, 13, 5)

    let $Punch_DTTM   = $Formatted_Punch_DTTM || ' ' || $Punch_Time

    evaluate $dtu_dayofweek
        when = 'Sunday'
            let $Day_Of_Week = $Sun_lbl
            break
        when = 'Monday'
            let $Day_Of_Week = $Mon_lbl
            break
        when = 'Tuesday'
            let $Day_Of_Week = $Tue_lbl
            break
        when = 'Wednesday'
            let $Day_Of_Week = $Wed_lbl
            break
        when = 'Thursday'
            let $Day_Of_Week = $Thu_lbl
            break
        when = 'Friday'
            let $Day_Of_Week = $Fri_lbl
            break
        when = 'Saturday'
            let $Day_Of_Week = $Sat_lbl
            break
    end-evaluate

    do Print-Punch

    let #Punch_Rows_Found = 1
    let $Prior_Punch_Emplid = $Select_Punch_Emplid
    let $Prior_Punch_EmpRec = $Select_Punch_EmpRec

    FROM PS_TL_RPTD_TIME PUNCH
    WHERE PUNCH.EMPLID       = $Main_Select_Emplid
        AND PUNCH.EMPL_RCD   = #Main_Select_EmpRec
        AND PUNCH.PUNCH_TYPE IN ('1','2','3','4','5')
        AND PUNCH.PUNCH_DTTM BETWEEN $FromDate AND $ThruDate
    ORDER BY PUNCH.PUNCH_DTTM

end-SELECT

end-procedure !Select-Punch-ORA

#end-if

!***********************************************************************
!                                                                      *
! Select-Elapsed                                                       *
!                                                                      *
!                                                                      *
! Called By: Group-Branch, Empl-Branch                                 *
! Calls:     Read-Translate-Table                                      *
!            Format-DateTime                                           *
!            Get-TRC-Rel-Lang                                          *
!            Print-Elapsed                                             *
!            Add-To-Elapsed-Totals                                     *
!                                                                      *
! Description:  Selects elapsed time info for all employees.           *
!               Retrieves TRC type from Translate table.  Formats      *
!               date under report.  Retrieves TRC description from     *
!               related language table if necessary.  Calls procedure  *
!               to print elapsed info.  Calls procedure to add to      *
!               elapsed totals.  Manages variables which determine     *
!               printing of headers.                                   *
!                                                                      *
!***********************************************************************

begin-procedure Select-Elapsed  !Elapsed Time Reporters


#ifdef debugy
    show 'IN PROCEDURE SELECT-ELAPSED'
#end-if


begin-SELECT

ELAPSED.EMPLID          &ELAPSED.EMPLID
ELAPSED.EMPL_RCD        &ELAPSED.EMPL_RCD
ELAPSED.DUR             &ELAPSED.DUR
ELAPSED.SEQ_NBR         &ELAPSED.SEQNUM
ELAPSED.TL_QUANTITY     &ELAPSED.TL_QUANTITY
ELAPSED.TRC             &ELAPSED.TRC
TRC1.EFFDT              &TRC1.EFFDT
TRC1.DESCR              &TRC1.DESCR
TRC1.TRC_TYPE           &TRC1.TRC_TYPE

    If &Elapsed.TRC > ' '
       let $TRC_Type_Raw = &TRC1.TRC_TYPE            ! Input into Read-Translate-Table
       let $FieldName    = 'TRC_TYPE'                ! Input into Read-Translate-Table
       let $FieldValue   = &TRC1.TRC_TYPE            ! Input into Read-Translate-Table
       do Read-Translate-Table                     ! Returns XlatShortName, XlatLongName
    else
       let $TRC_Type_Raw = ' '
       let $FieldName    = ' '
       let $FieldValue   = ' '
    end-if

    let $DUR = &ELAPSED.DUR
    do Format-DateTime($DUR, $out, {DEFDATE}, '', '')


    If &Elapsed.TRC > ' '
       let $Elapsed_TRC_Descr = rtrim(&TRC1.DESCR,' ')


       if $curr_language_cd <> $Psoptions_Language_Cd
           let $Retrieve_Lang_TRC = &ELAPSED.TRC
           do Get-TRC-Rel-Lang
       end-if

       let $TRC                    = &ELAPSED.TRC
       let $TRC_Type               = $XlatShortName
    else
       let $TRC                    = ' '
       let $TRC_Type               = ' '
    end-if

    let $Select_Elapsed_Emplid  = &ELAPSED.EMPLID
    let $EmpRec3                = &ELAPSED.EMPL_RCD
    let $Select_Elapsed_EmpRec  = substr($EmpRec3, 1, 1)
    let $DUR                    = $out
    let #Qty                    = &ELAPSED.TL_QUANTITY


#ifdef debugz
    display '$Select_Elapsed_Emplid:    ' noline
    display $Select_Elapsed_Emplid
#end-if


    do Print-Elapsed


    let #Elapsed_Rows_Found = 1


    do Add-To-Elapsed-Totals



    FROM PS_TL_RPTD_TIME ELAPSED,
         PS_TL_TRC_TBL TRC1
    WHERE   ELAPSED.EMPLID   = $Main_Select_Emplid
        AND ELAPSED.EMPL_RCD = #Main_Select_EmpRec
        AND ELAPSED.PUNCH_TYPE = '0'
        AND ELAPSED.DUR      BETWEEN $FromDate AND $ThruDate
        AND TRC1.TRC         = ELAPSED.TRC
        AND TRC1.EFFDT       = (SELECT MAX(EFFDT) FROM PS_TL_TRC_TBL TRC2
                                   WHERE TRC2.TRC          = ELAPSED.TRC
                                       AND TRC2.EFFDT      <= $ThruDate
                                       AND TRC2.EFF_STATUS = 'A')

    UNION
    SELECT ELAPSED.EMPLID, ELAPSED.EMPL_RCD, ELAPSED.DUR, ELAPSED.SEQ_NBR, ELAPSED.TL_QUANTITY, ELAPSED.TRC, ELAPSED.DUR, ' ', ' '
    FROM PS_TL_RPTD_TIME ELAPSED
    WHERE   ELAPSED.EMPLID   = $Main_Select_Emplid
        AND ELAPSED.EMPL_RCD = #Main_Select_EmpRec
        AND ELAPSED.PUNCH_TYPE = '0'
        AND ELAPSED.DUR      >= $FromDate
        AND ELAPSED.DUR      <= $ThruDate
        AND ELAPSED.TRC      = ' '
    ORDER BY 3, 6, 4
  

end-SELECT


    if #Elapsed_Rows_Found = 1
        do Print-Elapsed-Totals
    end-if


end-procedure !Select-Elapsed


!***********************************************************************
!                                                                      *
! Get-TRC-Rel-Lang                                                     *
!                                                                      *
!                                                                      *
! Called By: Select-Elapsed, Select-PayableTime                        *
! Calls:     none                                                      *
!                                                                      *
! Description:  Retrieves related language description for TRC.        *
!                                                                      *
!***********************************************************************


begin-procedure Get-TRC-Rel-Lang


#ifdef debugy
    show 'IN PROCEDURE GET-TRC-REL-LANG'
#end-if


begin-SELECT


A.TRC
A.DESCR         &TRC_DESCR_LANG


    let $Elapsed_TRC_Descr  = rtrim(&TRC_DESCR_LANG,' ')
    let $Payable_TRC_Descr  = rtrim(&TRC_DESCR_LANG,' ')


    FROM PS_TL_TRC_LANG A
    WHERE A.TRC           = $Retrieve_Lang_TRC
        AND A.LANGUAGE_CD = $curr_language_cd
        AND A.EFFDT       = (SELECT MAX(EFFDT) FROM PS_TL_TRC_LANG
                                WHERE TRC           = $Retrieve_Lang_TRC
                                    AND LANGUAGE_CD = $curr_language_cd
                                    AND EFFDT       <= $ThruDate)

end-SELECT


end-procedure !Get-TRC-Rel-Lang


!***********************************************************************
!                                                                      *
! Get-DeptDescr-Rel-Lang                                               *
!                                                                      *
!                                                                      *
! Called By: Group-Branch, Empl-Branch                                 *
! Calls:     none                                                      *
!                                                                      *
! Description:  Retrieves related language description for department  *
!               description.                                           *
!                                                                      *
!***********************************************************************


begin-procedure Get-DeptDescr-Rel-Lang


#ifdef debugy
    show 'IN PROCEDURE GET-DEPTDESCR-REL-LANG'
#end-if


begin-SELECT


A.DEPTID
A.DESCR      &DEPT_DESCR_LANG


    let $Dept_Descr = rtrim(&DEPT_DESCR_LANG,' ')


    FROM PS_DEPT_TBL_LANG A
    WHERE A.DEPTID        = $DeptID
        AND A.LANGUAGE_CD = $curr_language_cd
        AND A.SETID       = $Setid_JobCode
        AND A.EFFDT       = (SELECT MAX(EFFDT) FROM PS_DEPT_TBL_LANG
                                WHERE DEPTID        = $DeptID
                                    AND LANGUAGE_CD = $curr_language_cd
                                    AND SETID       = $Setid_JobCode
                                    AND EFFDT       <= $ThruDate)


end-SELECT


end-procedure !Get-DeptDescr-Rel-Lang


!***********************************************************************
!                                                                      *
! Get-JobCodeDescr-Rel-Lang                                            *
!                                                                      *
!                                                                      *
! Called By: Group-Branch, Empl-Branch                                 *
! Calls:     none                                                      *
!                                                                      *
! Description:  Retrieves related language description for job code    *
!               description.                                           *
!                                                                      *
!***********************************************************************


begin-procedure Get-JobCodeDescr-Rel-Lang


#ifdef debugy
    show 'IN PROCEDURE GET-JOBCODEDESCR-REL-LANG'
#end-if


begin-SELECT

A.JOBCODE
A.DESCR      &JOBCODE_DESCR_LANG


    let $Job_Descr = rtrim(&JOBCODE_DESCR_LANG,' ')


    FROM PS_JOBCODE_LANG A
    WHERE A.JOBCODE       = $JobCode
        AND A.LANGUAGE_CD = $curr_language_cd
        AND A.SETID       = $Setid_JobCode
        AND A.EFFDT       = (SELECT MAX(EFFDT) FROM PS_JOBCODE_LANG
                                WHERE JOBCODE       = $JobCode
                                    AND LANGUAGE_CD = $curr_language_cd
                                    AND EFFDT       <= $ThruDate)


end-SELECT


end-procedure !Get-JobCodeDescr-Rel-Lang


!***********************************************************************
!                                                                      *
! Add-To-Elapsed-Totals                                                *
!                                                                      *
!                                                                      *
! Called By: Select-Elapsed                                            *
! Calls:     none                                                      *
!                                                                      *
! Description:  Adds to amount, units, hours sub-totals variables      *
!               for employees with elapsed time.                       *
!                                                                      *
!***********************************************************************


begin-procedure Add-To-Elapsed-Totals


#ifdef debugy
    show 'IN PROCEDURE ADD-TO-ELAPSED-TOTALS'
#end-if


   evaluate $TRC_Type_Raw
       when = 'A'
           let #Elapsed_Amt_Total   = #Elapsed_Amt_Total   + #Qty

       when = 'U'
           let #Elapsed_Units_Total = #Elapsed_Units_Total + #Qty

       when = 'H'
           let #Elapsed_Hrs_Total   = #Elapsed_Hrs_Total   + #Qty

       when = ' '
           let #Elapsed_Oth_Total   = #Elapsed_Oth_Total   + #Qty

   end-evaluate


end-procedure !Add-To-Elapsed-Totals


!***********************************************************************
!                                                                      *
! Print-Punch                                                          *
!                                                                      *
!                                                                      *
! Called By: Select-Punch                                              *
! Calls:     Print-Employee-Header                                     *
!            Print-Punch-Header                                        *
!                                                                      *
! Description:  Prints punchtime rows for each employee.  Manages      *
!               printing of employee header & punchtime section        *
!               header.  Manages page breaking.                        *
!                                                                      *
!                                                                      *
!***********************************************************************

begin-procedure Print-Punch


#ifdef debugy
    show 'IN PROCEDURE PRINT-PUNCH'
#end-if


    if #Printed_EE_Header = 0
        do Print-Employee-Header
        let #Printed_EE_Header = 1
    end-if


    if #current-line + 3 > #Maxlines
        new-page
        do Print-Employee-Header
        let #Punch_First_Row = 1
    end-if


    if #Punch_First_Row = 1                 ! Print header & column titles first time thru for EE
        do Print-Punch-Header
        let #Punch_First_Row = 0
    end-if


    print $Punch_DTTM                       (+1,{Col_10}
    print $Day_Of_Week                      (,{Col_30})
    print $Punch_Type                       (,{Col_40})
    print $TimeZone                         (,{Col_50})

end-procedure !Print-Punch


!***********************************************************************
!                                                                      *
! Print-Elapsed                                                        *
!                                                                      *
!                                                                      *
! Called By: Select-Elapsed                                            *
! Calls:     Print-Employee-Header                                     *
!            Print-Punch-Header                                        *
!            Print-Elapsed-Header                                      *
!                                                                      *
! Description:  Prints elapsed time rows for each employee.  Manages   *
!               printing of employee header & elapsed time section     *
!               header.  Manages page breaking.                        *
!                                                                      *
!                                                                      *
!***********************************************************************

begin-procedure Print-Elapsed

#ifdef debugy
    show 'IN PROCEDURE PRINT-ELAPSED'
#end-if


    if #Printed_EE_Header = 0
        do Print-Employee-Header
        let #Printed_EE_Header = 1
    end-if


    if #Punch_Rows_Found = 0
        if #Elapsed_First_Row = 1
            do Print-Punch-Header
            !TFprint $No_Rows_Found_lbl            (+1,{Col_10})
        end-if
    end-if


    if #current-line + 3 > #Maxlines
        new-page
        do Print-Employee-Header
        let #Elapsed_First_Row = 1
    end-if


    if #Elapsed_First_Row = 1
        do Print-Elapsed-Header
    end-if


    print $DUR                         (+1,{Col_10})
    print #Qty                         (,{Col_20}) edit 999999999999.999999

    if $TRC > ' '
       print $TRC_Type                    (,{Col_40})
       print $Elapsed_TRC_Descr           (,{Col_50})
       print $TRC                         (,{Col_80})
    end-if

    let #Elapsed_First_Row = 0


end-procedure !Print-Elapsed


!***********************************************************************
!                                                                      *
! Print-Elapsed-Header                                                 *
!                                                                      *
!                                                                      *
! Called By: Print-Elapsed                                             *
! Calls:     none                                                      *
!                                                                      *
! Description:  Prints elapsed section header info.                    *
!                                                                      *
!***********************************************************************


begin-procedure Print-Elapsed-Header


#ifdef debugy
    show 'IN PROCEDURE PRINT-ELAPSED-HEADER'
#end-if


        print $Rptd_Elapsed_Dtl_lbl         (+3,{Col_10})
        print $Date_Under_Report1_lbl       (+2,{Col_10}
        print $Time_Rptg_Code1_lbl          (,{Col_80}

        print $Date_Under_Report2_lbl       (+1,{Col_10}
        print $Quantity_lbl                 (,{Col_27})
        print $Type_lbl                     (,{Col_40})
        print $Descr_lbl                    (,{Col_50})
        print $Time_Rptg_Code2_lbl          (,{Col_80})


        graphic                             (, {Col_10}, 11) horz-line
        graphic                             (, {Col_20}, 23) horz-line
        graphic                             (, {Col_40}, 8)  horz-line
        graphic                             (, {Col_50}, 25) horz-line
        graphic                             (, {Col_80}, 10) horz-line


end-procedure !Print-Elapsed-Header


!***********************************************************************
!                                                                      *
! Print-Elapsed-Totals                                                 *
!                                                                      *
!                                                                      *
! Called By: Select-Elapsed                                            *
! Calls:     none                                                      *
!                                                                      *
! Description:  Prints elapsed section totals.  Resets variables for   *
!               subsequent employee.                                   *
!                                                                      *
!***********************************************************************

begin-procedure Print-Elapsed-Totals


#ifdef debugy
    show 'IN PROCEDURE PRINT-ELAPSED-TOTALS'
#end-if


        print $Total_Amt_lbl         (+2,{Col_10})
        print #Elapsed_Amt_Total     (,{Col_30})    edit 999999999999.999999
        print $Total_Units_lbl       (+1,{Col_10})
        print #Elapsed_Units_Total   (,{Col_30})    edit 999999999999.999999
        print $Total_Hrs_lbl         (+1,{Col_10})
        print #Elapsed_Hrs_Total     (,{Col_30})    edit 999999999999.999999
        print $Total_Oth_lbl         (+1,{Col_10})
        print #Elapsed_Oth_Total     (,{Col_30})    edit 999999999999.999999


        let #Elapsed_Amt_Total   = 0
        let #Elapsed_Units_Total = 0
        let #Elapsed_Hrs_Total   = 0
        let #Elapsed_Oth_Total   = 0


end-procedure !Print-Elapsed-Totals


!***********************************************************************
!                                                                      *
! Add-To-Payable-Totals                                                *
!                                                                      *
!                                                                      *
! Called By: Select-PayableTime                                        *
! Calls:     none                                                      *
!                                                                      *
! Description:  Adds to amount, units, hours sub-totals variables      *
!               for employees with payable time.                       *
!                                                                      *
!***********************************************************************


begin-procedure Add-To-Payable-Totals


#ifdef debugy
    show 'IN PROCEDURE ADD-TO-PAYABLE-TOTALS'
#end-if


   evaluate $TRC_Type_Raw
       when = 'A'
           let #Payable_Amt_Total   = #Payable_Amt_Total   + #Payable_Qty

       when = 'U'
           let #Payable_Units_Total = #Payable_Units_Total + #Payable_Qty

       when = 'H'
           let #Payable_Hrs_Total   = #Payable_Hrs_Total   + #Payable_Qty

   end-evaluate


end-procedure !Add-To-Payable-Totals


!***********************************************************************
!                                                                      *
! Print-Payable-Totals                                                 *
!                                                                      *
!                                                                      *
! Called By: Select-PayableTime                                        *
! Calls:     none                                                      *
!                                                                      *
! Description:  Prints payable section totals.  Resets variables for   *
!               subsequent employee.                                   *
!                                                                      *
!***********************************************************************


begin-procedure Print-Payable-Totals


        print $Total_Amt_lbl         (+2,{Col_10})
        print #Payable_Amt_Total     (,{Col_30})    edit 999999999999.999999
        print $Total_Units_lbl       (+1,{Col_10})
        print #Payable_Units_Total   (,{Col_30})    edit 999999999999.999999
        print $Total_Hrs_lbl         (+1,{Col_10})
        print #Payable_Hrs_Total     (,{Col_30})    edit 999999999999.999999


        let #Payable_Amt_Total   = 0
        let #Payable_Units_Total = 0
        let #Payable_Hrs_Total   = 0


end-procedure !Print-Payable-Totals


!***********************************************************************
!                                                                      *
! Print-Punch-Header                                                   *
!                                                                      *
!                                                                      *
! Called By: Print-Punch                                               *
!            Print-Elapsed                                             *
!            Print-Signature-Line                                      *
! Calls:     none                                                      *
!                                                                      *
! Description:  Prints punch time section header.                      *
!                                                                      *
!                                                                      *
!***********************************************************************


begin-procedure Print-Punch-Header


#ifdef debugy
    show 'IN PROCEDURE PRINT-PUNCH-HEADER'
#end-if


    print $Reptd_Punch_Dtl_lbl      (+3,{Col_10})
    print $Date_Time_lbl            (+2,{Col_10})
    print $Day_lbl                  (,{Col_30})
    print $Type_lbl                 (,{Col_40})
    print $TimeZone_lbl             (,{Col_50})


    graphic                         (, {Col_10}, 18) horz-line
    graphic                         (, {Col_30}, 9)  horz-line
    graphic                         (, {Col_40}, 9)  horz-line
    graphic                         (, {Col_50}, 9)  horz-line

end-procedure !Print-Punch-Header


!***********************************************************************
!                                                                      *
! Print-Employee-Header                                                *
!                                                                      *
!                                                                      *
! Called By: Print-Punch                                               *
!            Print-Elapsed                                             *
!            Print-Signature-Line                                      *
! Calls:     none                                                      *
!                                                                      *
! Description:  Prints employee information in page header.            *
!                                                                      *
!***********************************************************************


begin-procedure Print-Employee-Header


#ifdef debugy
    show 'IN PROCEDURE PRINT-EMPLOYEE-HEADER'
#end-if


        print $Employee_ID_lbl      (+1,{Col_10})
        print ':'                   (,)
        print $Main_Select_Emplid   (,{Col_25})
        print $Employee_Name_lbl    (+1,{Col_10})
        print ':'                   (,)
        print $Name                 (,{Col_25})
        print $Job_Title_lbl        (+1,{Col_10}
        print ':'                   (,)
        print $JobCode              (,{Col_25})
        print $Job_Descr            (,{Col_35})
        print $Dept_lbl             (+1,{Col_10}
        print ':'                   (,)
        print $DeptID               (,{Col_25})
        print $Dept_Descr           (,{Col_35})


end-procedure !Print-Employee-Header


!***********************************************************************
!                                                                      *
! Select-PayableTime                                                   *
!                                                                      *
!                                                                      *
! Called By: Group-Branch, Empl-Branch                                 *
! Calls:     Read-Translate-Table                                      *
!            Format-DateTime                                           *
!            Get-TRC-Rel-Lang                                          *
!            Print-PayableTime                                         *
!            Add-To-Payable-Totals                                     *
!                                                                      *
! Description:  Selects payable time info for all employees.           *
!               Retrieves TRC type from Translate table.  Formats      *
!               date under report.  Retrieves TRC description from     *
!               related language table if necessary.  Calls procedure  *
!               to print payable time info.  Calls procedure to add to *
!               payable time totals.  Manages variables which          *
!               determine printing of headers.                         *
!                                                                      *
!***********************************************************************


begin-procedure Select-PayableTime


#ifdef debugy
    show 'IN PROCEDURE SELECT-PAYABLETIME'
#end-if


begin-SELECT


#ifdef debugz
    show 'IN SELECT SELECT-PAYABLETIME'
#end-if


PAYABLE.EMPLID          &PAYABLE.EMPLID
PAYABLE.EMPL_RCD        &PAYABLE.EMPL_RCD
PAYABLE.DUR             &PAYABLE.DUR
PAYABLE.SEQ_NBR         &PAYABLE.SEQ_NBR
PAYABLE.TRC             &PAYABLE.TRC
PAYABLE.TL_QUANTITY     &PAYABLE.TL_QUANTITY
PAYABLE.PAYABLE_STATUS  &PAYABLE.PAYABLE_STATUS
TRC3.DESCR              &TRC3.DESCR
TRC3.TRC_TYPE           &TRC3.TRC_TYPE


    let $TRC_Type_Raw = &TRC3.TRC_TYPE
    let $FieldName    = 'TRC_TYPE'         ! Input into Read-Translate-Table
    let $FieldValue   = &TRC3.TRC_TYPE     ! Input into Read-Translate-Table
    do Read-Translate-Table                ! Returns XlatShortName, XlatLongName
    let $Payable_TRC_Type   = $XlatShortName

    let $FieldName    = 'PAYABLE_STATUS'         ! Input into Read-Translate-Table
    let $FieldValue   = &PAYABLE.PAYABLE_STATUS     ! Input into Read-Translate-Table
    do Read-Translate-Table                ! Returns XlatShortName, XlatLongName
    let $Payable_PayStatus  = $XlatShortName

    let $Payable_DUR = &PAYABLE.DUR
    do Format-DateTime($Payable_DUR, $out, {DEFDATE}, '', '')

    let $Payable_TRC_Descr  = rtrim(&TRC3.DESCR,' ')


    if $curr_language_cd <> $Psoptions_Language_Cd
        let $Retrieve_Lang_TRC = &PAYABLE.TRC
        do Get-TRC-Rel-Lang
    end-if

    let $Payable_Emplid     = &PAYABLE.EMPLID
    let $Payable_EmpRec     = &PAYABLE.EMPL_RCD
    let $Payable_DUR        = $out
    let $Payable_TRC        = &PAYABLE.TRC
    let #Payable_Qty        = &PAYABLE.TL_QUANTITY
    !let $Payable_PayStatus  = &PAYABLE.PAYABLE_STATUS



    do Print-PayableTime

    do Add-To-Payable-Totals

    let #Payable_Rows_Found = 1


    FROM PS_TL_PAYABLE_TIME PAYABLE,
        PS_TL_TRC_TBL TRC3
    WHERE   PAYABLE.EMPLID          = $Main_Select_Emplid
        AND PAYABLE.EMPL_RCD        = #Main_Select_EmpRec
        AND PAYABLE.DUR             BETWEEN $FromDate AND $ThruDate
        AND PAYABLE.PAYABLE_STATUS  IN ('AP', 'ES','NA','CL')
        AND PAYABLE.TRC             = TRC3.TRC
        AND TRC3.TRC                = PAYABLE.TRC
        AND TRC3.EFFDT              = (SELECT MAX(EFFDT) FROM PS_TL_TRC_TBL TRC4
                                        WHERE TRC4.TRC              = PAYABLE.TRC
                                                AND TRC4.EFFDT      <= $ThruDate
                                                AND TRC4.EFF_STATUS = 'A')
    ORDER BY PAYABLE.DUR, PAYABLE.SEQ_NBR


end-SELECT


    if #Payable_Rows_Found = 1
        do Print-Payable-Totals
    end-if


end-procedure !Select-PayableTime


!***********************************************************************
!                                                                      *
! Print-PayableTime                                                    *
!                                                                      *
!                                                                      *
! Called By: Select-PayableTime                                        *
! Calls:     Print-Elapsed-Header                                      *
!            Print-Payable-Header                                      *
!                                                                      *
! Description:  Prints payable time rows for each employee.  Manages   *
!               printing of employee header & payable time section     *
!               header.  Manages page breaking.                        *
!                                                                      *
!***********************************************************************

begin-procedure Print-PayableTime


#ifdef debugy
    show 'IN PROCEDURE PRINT-PAYABLETIME'
#end-if

    if #Printed_EE_Header = 0
        do Print-Employee-Header
        let #Printed_EE_Header = 1
    end-if

    if #Punch_Rows_Found = 0 and #Elapsed_Rows_Found = 0
      if #Payable_Time_First_Row = 1
        do Print-Punch-Header
        !TFprint $No_Rows_Found_lbl            (+1,{Col_10})
      end-if
    end-if

    if #Elapsed_Rows_Found = 0
      if #Payable_Time_First_Row = 1
        do Print-Elapsed-Header
        !TFprint $No_Rows_Found_lbl            (+1,{Col_10})
      end-if
    end-if


    if #current-line + 3 > #Maxlines
        new-page
        do Print-Employee-Header
        let #Payable_Time_First_Row = 1
    end-if


    if #Payable_Time_First_Row = 1
        do Print-Payable-Header
        let #Payable_Time_First_Row = 0
    end-if


        print $Payable_DUR             (+1,{Col_10})
        print #Payable_Qty             (,{Col_20})   edit 999999999999.999999
        print $Payable_TRC_Type        (,{Col_40})
        print $Payable_TRC_Descr       (,{Col_50})
!        print $Descr3                  (,{Col_50})
        print $Payable_TRC             (,{Col_80})
        print $Payable_PayStatus       (,{Col_100})

!   let #Payable_Time_First_Row = 0


end-procedure !Print-PayableTime


!***********************************************************************
!                                                                      *
! Print-Payable-Header                                                 *
!                                                                      *
!                                                                      *
! Called By: Print-PayableTime                                         *
!            Print-Exceptions                                          *
!            Print-Signature-Line                                      *
! Calls:     none                                                      *
!                                                                      *
! Description:  Prints payable section header info.                    *
!                                                                      *
!***********************************************************************


begin-procedure Print-Payable-Header


#ifdef debugy
    show 'IN PROCEDURE PRINT-PAYABLE-HEADER'
#end-if


        print $PAYABLE_TIME_lbl         (+3,{Col_10})
        print $Date_Under_Report1_lbl   (+2,{Col_10}
        print $Time_Rptg_Code1_lbl      (,{Col_80}

        print $Date_Under_Report2_lbl   (+1,{Col_10}
        print $Quantity_lbl             (,{Col_27})
        print $Type_lbl                 (,{Col_40})
        print $Descr_lbl                (,{Col_50})
        print $Time_Rptg_Code2_lbl      (,{Col_80})
        print $Payable_Status_lbl       (,{Col_100})


        graphic                         (, {Col_10}, 11) horz-line
        graphic                         (, {Col_20}, 23) horz-line
        graphic                         (, {Col_40}, 8)  horz-line
        graphic                         (, {Col_50}, 25) horz-line
        graphic                         (, {Col_80}, 10) horz-line
        graphic                         (, {Col_100}, 15) horz-line


end-procedure !Print-Payable-Header


!***********************************************************************
!                                                                      *
! Select-Exceptions                                                    *
!                                                                      *
!                                                                      *
! Called By: Group-Branch, Empl-Branch                                 *
! Calls:     Get-Except-Rel-Lang                                       *
!            Format-DateTime                                           *
!            Print-Exceptions                                          *
!                                                                      *
! Description:   Selects outstanding exceptions for each employee.     *
!                Retrieves related language table entry for exception  *
!                description when necessary.  Formats date-time.       *
!                Calls procedure to print exceptions.                  *
!                                                                      *
!***********************************************************************

begin-procedure Select-Exceptions


#ifdef debugy
    show 'IN PROCEDURE SELECT-EXCEPTIONS'
#end-if


begin-SELECT


EXCEPTBL.EMPLID         &EXCEPTBL.EMPLID
EXCEPTBL.EMPL_RCD       &EXCEPTBL.EMPL_RCD
EXCEPTBL.DUR            &EXCEPTBL.DUR
EXCEPTBL.EXCEPTION_ID   &EXCEPTBL.EXCEPTION_ID
EXCEPDEFN.EFFDT         &EXCEPDEFN.EFFDT
EXCEPDEFN.DESCR         &EXCEPDEFN.DESCR


    let $Exception_Descr = rtrim(&EXCEPDEFN.DESCR,' ')


     if $curr_language_cd <> $Psoptions_Language_Cd
        let $Retrieve_Lang_Except = &EXCEPTBL.EXCEPTION_ID
        do Get-Except-Rel-Lang
     end-if

    let $Exception_DUR = &EXCEPTBL.DUR
    do Format-DateTime($Exception_DUR, $out, {DEFDATE}, '', '')


    let $Exception_DUR  = $out
    let $Exception_ID   = &EXCEPTBL.EXCEPTION_ID


    do Print-Exceptions


    FROM PS_TL_EXCEPTION    EXCEPTBL,
         PS_TL_EXCEPT_DEFN  EXCEPDEFN
    WHERE EXCEPTBL.EMPLID              = $Main_Select_EmplID
        AND EXCEPTBL.EMPL_RCD          = #Main_Select_EmpRec
        AND EXCEPTBL.DUR               BETWEEN $FromDate AND $ThruDate
        AND EXCEPTBL.EXCEPTION_STATUS IN ('C', 'U')
        AND EXCEPDEFN.EXCEPTION_ID     = EXCEPTBL.EXCEPTION_ID
        AND EXCEPDEFN.EFFDT            = (SELECT MAX(EFFDT) FROM PS_TL_EXCEPT_DEFN
                                            WHERE EXCEPTION_ID = EXCEPTBL.EXCEPTION_ID
                                                AND EFFDT      <= $ThruDate)
    ORDER BY EXCEPTBL.DUR


end-SELECT


end-procedure !Select-Exceptions


!***********************************************************************
!                                                                      *
! Get-Except-Rel-Lang                                                  *
!                                                                      *
!                                                                      *
! Called By: Select-Exceptions                                         *
! Calls:     none                                                      *
!                                                                      *
! Description:  Retrieves related language description for exception.  *
!                                                                      *
!***********************************************************************


begin-procedure Get-Except-Rel-Lang


#ifdef debugy
    show 'IN PROCEDURE GET-EXCEPT-REL-LANG'
#end-if


begin-SELECT

A.EXCEPTION_ID
A.DESCR         &EXCEPT_DESCR_LANG


    let $Except_Descr = rtrim(&EXCEPT_DESCR_LANG,' ')


    FROM PS_TL_EXCP_DFN_LNG A
    WHERE A.EXCEPTION_ID  = $Retrieve_Lang_Except
        AND A.LANGUAGE_CD = $curr_language_cd
        AND A.EFFDT       = (SELECT MAX(EFFDT) FROM PS_TL_EXCP_DFN_LNG
                                WHERE EXCEPTION_ID  = $Retrieve_Lang_Except
                                    AND LANGUAGE_CD = $curr_language_cd
                                    AND EFFDT       <= $ThruDate)


end-SELECT


end-procedure !Get-Except-Rel-Lang


!***********************************************************************
!                                                                      *
! Print-Exceptions                                                     *
!                                                                      *
!                                                                      *
! Called By: Select-Exceptions                                         *
! Calls:     Print-Elapsed-Header                                      *
!            Print-Payable-Header                                      *
!            Print-Exceptions-Header                                   *
!                                                                      *
! Description:  Prints exceptions rows for each employee.  Manages     *
!               printing of employee header & exceptions section       *
!               header.  Manages page breaking.                        *
!                                                                      *
!***********************************************************************

begin-procedure Print-Exceptions


#ifdef debugy
    show 'IN PROCEDURE PRINT-EXCEPTIONS'
#end-if


    if #Printed_EE_Header = 0
            do Print-Employee-Header
            let #Printed_EE_Header = 1
        end-if

    if #Punch_Rows_Found = 0
     and #Elapsed_Rows_Found = 0
      and #Payable_Rows_Found = 0
       if #Exceptions_First_Row = 1
           do Print-Punch-Header
           !TFprint $No_Rows_Found_lbl            (+1,{Col_10})
       end-if
    end-if

    if #Elapsed_Rows_Found = 0
     and #Payable_Rows_Found = 0
        if #Exceptions_First_Row = 1
            do Print-Elapsed-Header
            !TFprint $No_Rows_Found_lbl            (+1,{Col_10})
    !        let #Elapsed_Rows_Found = 1
        end-if
    end-if


    if #Payable_Rows_Found = 0
        if #Exceptions_First_Row = 1
            do Print-Payable-Header
            !TFprint $No_Rows_Found_lbl                (+1,{Col_10}
   !         let #Payable_Rows_Found = 1
        end-if
    end-if


    if #current-line + 3 > #Maxlines
        new-page
        do Print-Employee-Header
        let #Exceptions_First_Row = 1
    end-if


    if #Exceptions_First_Row = 1
        do Print-Exceptions-Header
    end-if


    print $Exception_DUR          (+1,{Col_10}
    print $Exception_Descr        (,{Col_20})


    let #Exceptions_First_Row   = 0
    let #Exceptions_Rows_Found  = 1


end-procedure !Print-Exceptions


!***********************************************************************
!                                                                      *
! Print-Exceptions-Header                                              *
!                                                                      *
!                                                                      *
! Called By: Print-Exceptions                                          *
! Calls:     none                                                      *
!                                                                      *
! Description:  Prints exceptions section header info.                 *
!                                                                      *
!***********************************************************************

begin-procedure Print-Exceptions-Header


#ifdef debugy
    show 'IN PROCEDURE PRINT-EXCEPTIONS-HEADER'
#end-if


    if #current-line + 6 > #Maxlines
        new-page
    end-if


    print $EE_Outstand_Excep_lbl        (+3,{Col_10})
    print $Date_lbl                     (+2,{Col_10}
    print $EXCEPTION_lbl                (,{Col_20})

    graphic                             (, {Col_10}, 10) horz-line
    graphic                             (, {Col_20}, 30) horz-line


end-procedure !Print-Exceptions-Header


!***********************************************************************
!                                                                      *
! Print-Signature-Line                                                 *
!                                                                      *
!                                                                      *
! Called By: Group-Branch, Empl-Branch                                 *
! Calls:     Print-Employee-Header                                     *
!            Print-Punch-Header                                        *
!            Print-Elapsed-Header                                      *
!            Print-Payable-Header                                      *
!            Print-Exceptions-Header                                   *
!                                                                      *
!                                                                      *
! Description:  Prints signature line for each employee.               *
!               If change in payable status, print totals for old      *
!                   payable status before printing current row         *
!               If change in payable status, start new page            *
!                                                                      *
!***********************************************************************

begin-procedure Print-Signature-Line


#ifdef debugy
    show 'IN PROCEDURE PRINT-SIGNATURE-LINE'
#end-if

    if #current-line + 6 > #Maxlines
        new-page
        let #Printed_EE_Header = 0
    end-if

    if #Printed_EE_Header = 0
        do Print-Employee-Header
        let #Printed_EE_Header = 1
    end-if

    if #Punch_Rows_Found = 0
     and #Elapsed_Rows_Found = 0
      and #Payable_Rows_Found = 0
       if #Exceptions_First_Row = 1
           do Print-Punch-Header
           !TFprint $No_Rows_Found_lbl             (+1,{Col_10})
       end-if
    end-if

    if #Elapsed_Rows_Found = 0
     and #Payable_Rows_Found = 0
        if #Exceptions_First_Row = 1
            do Print-Elapsed-Header
            !TFprint $No_Rows_Found_lbl            (+1,{Col_10})
    !        let #Elapsed_Rows_Found = 1
        end-if
    end-if


    if #Payable_Rows_Found = 0
        if #Exceptions_First_Row = 1
            do Print-Payable-Header
            !TFprint $No_Rows_Found_lbl            (+1,{Col_10}
   !         let #Payable_Rows_Found = 1
        end-if
    end-if

    if #Exceptions_Rows_Found = 0
        do Print-Exceptions-Header
        !TFprint $No_Rows_Found_lbl                (+1,{Col_10}
    end-if


    print $EE_Signature_lbl                     (+3,{Col_10})
    print ':  ___________________________'      (,)
    print $Approv_Signature_lbl                 (+3,{Col_10})
    print ':  ___________________________'      (,)
    print $Approv_Name_lbl                      (,{Col_50})
    print ':  ___________________________'      (,)
    print '('                                   (+1,{Col_50})
    print $Plz_Print_lbl                        (,)
    print ')'                                   (,)


end-procedure !Print-Signature-Line


!***********************************************************************
!                                                                      *
! Additional SQCs included in the report                               *
!                                                                      *
!***********************************************************************

#include 'tlrnctl2.sqc'     !Get run control parameter values, specific to this report
#include 'curdttim.sqc'     !Get-Current-DateTime procedure
#include 'datemath.sqc'     !Date conversion procedures
#include 'sqrtrans.sqc'     !Translate SQR strings to given language
#include 'prcsapi.sqc'
#include 'prcslng.sqc'
#include 'prcsdef.sqc'
#include 'readxlat.sqc'     !Procedure to read values from xlattable
#include 'reset.sqc'        !Reset printer procedure
#include 'number.sqc'   !Routines to format numbers
#include 'datetime.sqc' !Routines for date and time formatting
