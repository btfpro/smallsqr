!***********************************************************************
!  BPCMP107:  Load Auto Salary Step Increments for Budget Planning     *
!***********************************************************************
!***********************************************************************
!                                                                      *
!               Confidentiality Information:                           *
!                                                                      *
! This module contains confidential and proprietary information        *
! of Oracle; it is not to be copied, reproduced, or transmitted        *
! in any form, by any means, in whole or in part, nor is it to         *
! be used for any purpose other than that for which it is              *
! expressly provided under the applicable license agreement.           *
!                                                                      *
! Copyright (C) 2006 Oracle. All Rights Reserved.                      *
!                                                                      *
!***********************************************************************
!                                                                      *
!          $Date:  2006/07/19:11:15:12                                 *
!       $Release:  HR9                                                 *
!      $Revision:  101                                                 *
!                                                                      *
!***********************************************************************
! This program is specific to HRMS for Public Sector.                  *
! Cloned from CMP107.sqr and changed to:                               *
! 1. Select and  Insert from BP_JOB instead of JOB                     *
! 2. Select and  Insert from BP_JOB_ERN_DIST instead of JOB_EARNS_DIST *
! 3. Prevent updates to all other tables and skip the following steps  *
!            if $Elig_For_increm_hours = 'Y'                           *
!              do Reset-Accum-Hours                                    *
!            end-if                                                    *
!            do Check-Audits                                           *
!            do Update-Empl-Increase-Dt                                *
!***********************************************************************

#include 'setenv.sqc'    !Set environment
#Include 'setup32.sqc'   !Printer and page-size initialization

!***********************************************************************
begin-report
!***********************************************************************

  do Init-DateTime
  do Init-Number
  do Get-Current-DateTime
  move 'BPCMP107' to $ReportID
  move 'Budgeting - Salary Step Increments' to $ReportTitle
  display $ReportTitle
  display 'Report Began at: ' noLine
  do Display-Time
  do Get-Calendar-Year-Id
  do Init-Report

  !Refresh PS_BP_JOB from PS_JOB based on Sal Admin Plan
  !If no Grade has been selected from Run Control

  #DEBUGY display 'setgrade:' NOLINE
  #DEBUGY display $SetGrade

  if $SetGrade <> 'Y'
    do Refresh-Job
    do Refresh-Job-Compensation
  end-if

  do Plan-Grade
  display 'Report Ended at: ' noline
  do display-time
  do Reset
  do Stdapi-Term

end-report


!***********************************************************************
begin-heading 7
!***********************************************************************
  #Include 'stdhdg01.sqc'
!#Include 'stdhdgtr.sqc'
  print $Process_Type                                         (-1) Center
  print 'Employee  Employee Name'                             (+3,1)
  print 'Status'                                              (0,34)
  print 'Plan/Grade  Prev Eff    Prev             Prev Rate'  (0,41)
  print 'New Eff     New  New          New Rate'              (0,93)
  print 'Messages'                                            (0,138)
  print 'ID'                                                  (+1,1)
  print 'Date        Step                        Date'        (0,53)
  print 'Step Grade'                                          (0,105)

end-heading

!***********************************************************************
begin-procedure Init-Report
!***********************************************************************

#DEBUGY   display 'init report'

  do Stdapi-Init

  if $prcs_process_instance = ''
     do Ask-BP-Salary-Step-Increments
  else
     do Select-Parameters
  end-if

  create-array name=StepData size=30 field=step:number               -
                                     field=hourly_rt:number          -
                                     field=daily_rt:number           -
                                     field=monthly_rt:number         -
                                     field=annual_rt:number          -
                                     field=increm_months:number      -
                                     field=increm_hours:number       -
                                     field=comp_begin_idx:number  -
                                     field=comp_end_idx:number    -
                                     field=currency_cd:char


  create-array name=StepData2 size=30 field=step:number               -
                                     field=hourly_rt:number          -
                                     field=daily_rt:number           -
                                     field=monthly_rt:number         -
                                     field=annual_rt:number          -
                                     field=increm_months:number      -
                                     field=increm_hours:number       -
                                     field=comp_begin_idx:number  -
                                     field=comp_end_idx:number    -
                                     field=currency_cd:char



    create-array name=StepComp size=150 field=sc_comp_effseq:number
                                        field=sc_comp_ratecd:char
                                        field=sc_currency_cd:char
                                        field=sc_comp_frequency:char
                                        field=sc_hourly_rt:number
                                        field=sc_monthly_rt:number
                                        field=sc_annual_rt:number
                                        field=sc_comp_rate_points:number
                                        field=sc_comp_pct:number
                                        field=sc_rate_code_group:char
                                        field=sc_comprate:number
                                        field=sc_daily_rt:number
                                        field=rc_comp_rate_type:char
                                        field=rc_comp_base_pay_sw:char

    create-array name=StepComp2 size=150 field=sc_comp_effseq:number
                                        field=sc_comp_ratecd:char
                                        field=sc_currency_cd:char
                                        field=sc_comp_frequency:char
                                        field=sc_hourly_rt:number
                                        field=sc_monthly_rt:number
                                        field=sc_annual_rt:number
                                        field=sc_comp_rate_points:number
                                        field=sc_comp_pct:number
                                        field=sc_rate_code_group:char
                                        field=sc_comprate:number
                                        field=sc_daily_rt:number
                                        field=rc_comp_rate_type:char
                                        field=rc_comp_base_pay_sw:char

    create-array name=CompArray size=50 field=cp_effseq:number
                                        field=cp_comp_effseq:number
                                        field=cp_comp_ratecd:char
                                        field=cp_comp_rate_points:number
                                        field=cp_comprate:number
                                        field=cp_comp_pct:number
                                        field=cp_comp_frequency:char
                                        field=cp_currency_cd:char
                                        field=cp_manual_sw:char
                                        field=cp_convert_comprt:number
                                        field=cp_rate_code_group:char
                                        field=cp_fte_indicator:char
                                        field=cp_cmp_src_ind:char
                                        field=cp_rate_code_class:char


    create-array name=CompArray2 size=50 field=cp_effseq:number
                                        field=cp_comp_effseq:number
                                        field=cp_comp_ratecd:char
                                        field=cp_comp_rate_points:number
                                        field=cp_comprate:number
                                        field=cp_comp_pct:number
                                        field=cp_comp_frequency:char
                                        field=cp_currency_cd:char
                                        field=cp_manual_sw:char
                                        field=cp_convert_comprt:number
                                        field=cp_rate_code_group:char
                                        field=cp_fte_indicator:char
                                        field=cp_cmp_src_ind:char
                                        field=cp_rate_code_class:char

  create-array name=Month_Array size=12 field=Days:Number
  put 31 into Month_Array(00) Days  !January
  put 28 into Month_Array(01) Days  !February (not leap year)
  put 31 into Month_Array(02) Days  !March
  put 30 into Month_Array(03) Days  !April
  put 31 into Month_Array(04) Days  !May
  put 30 into Month_Array(05) Days  !June
  put 31 into Month_Array(06) Days  !July
  put 31 into Month_Array(07) Days  !August
  put 30 into Month_Array(08) Days  !September
  put 31 into Month_Array(09) Days  !October
  put 30 into Month_Array(10) Days  !November
  put 31 into Month_Array(11) Days  !December

  !do REPORT-TRANSLATION      !do we need translations

end-procedure


!***********************************************************************
begin-procedure Get-Values
!***********************************************************************

#DEBUGY display 'get values'

  do Get-BPCMP107-Parameters
  move $JobEffdt to $New_Job_Effdt
  do Format-DateTime($StartDt, $StartDt, {DEFCMP}, '', '')   !PUBSEC
  do Format-DateTime($EndDt, $EndDt,  {DEFCMP}, '', '')      !PUBSEC

  if $Process = 'Y'                           !PUBSEC
     let $Process_Type = 'Report & Process'   !PUBSEC
  else                                        !PUBSEC
     let $Process_Type = 'Report Only'        !PUBSEC
  end-if                                      !PUBSEC

  if Substr($Grade_Parm, 2, 4) <> 'LIKE'
    let $SetGrade = 'Y'
  end-if

end-procedure

!***********************************************************************
! Procedure: PLAN-GRADE                                                *
! Descr:     For the Grade specified to be processed get the steps     *
!            and rate components for that grade, process employees     *
!            whose job rates are for that grade and qualify for a step *
!            increase.                                                 *
!                                                                      *
! Called by: MAIN-PROGRAM                                              *
!***********************************************************************

begin-procedure PLAN-GRADE

#DEBUGY display 'plan-grade:' NOLINE
#DEBUGY display $SalPlan NOLINE
#DEBUGY display '/' NOLINE
#DEBUGY display $Grade_Parm
#DEBUGY display $SET

begin-SELECT

Z.SAL_ADMIN_PLAN
Z.GRADE
Z.EFFDT
Z.STEP_INCREM_TYPE
Z.STEP_INCREM_ACCUM

  let $Step_Increm_Accum= rtrim(&Z.STEP_INCREM_ACCUM,' ')
  let $Step_Increm_type = rtrim(&Z.STEP_INCREM_TYPE,' ')

    #DEBUGY display 'found a grade'
    #DEBUGY display 'Z.EFFDT:' NOLINE
    #DEBUGY display &Z.EFFDT

  do Get-Steps
  do Process-Emps
  !next-listing skiplines = 1               !PUBSEC

FROM  PS_SAL_GRADE_TBL Z
WHERE Z.SETID = $SET                       !PUBSEC
 AND Z.SAL_ADMIN_PLAN = $SalPlan
 AND Z.GRADE [$Grade_Parm]
 AND Z.EFFDT = (SELECT MAX(EFFDT)
                FROM PS_SAL_GRADE_TBL
               WHERE SETID          = Z.SETID                 !PUBSEC
                 AND SAL_ADMIN_PLAN = Z.SAL_ADMIN_PLAN
                 AND GRADE          = Z.GRADE)
  AND Z.STEP_INCREM_TYPE <> 'M'
  AND Z.STEP_INCREM_TYPE <> ' '                               !PUBSEC
ORDER BY Z.GRADE
end-SELECT

end-procedure PLAN-GRADE

!***********************************************************************
! Procedure: GET-STEPS                                                 *
! Descr:     For the Grade specified to be processed get the steps     *
!            and rate components for that grade, store them in arrays  *
!            for later searches and processing                         *
!            increase.                                                 *
!                                                                      *
! Called by: PLAN-GRADE                                                *
!***********************************************************************
begin-procedure GET-STEPS
#DEBUGY display 'get-steps'

  move 0 to #idx
  move 0 to #SC_idx

begin-SELECT
Y.STEP
Y.HOURLY_RT
Y.DAILY_RT
Y.MONTHLY_RT
Y.ANNUAL_RT
Y.INCREM_MONTHS
Y.INCREM_HOURS
Y.CURRENCY_CD

  if #idx < 30
    PUT &Y.STEP          INTO STEPDATA(#IDX) STEP
    PUT &Y.HOURLY_RT     INTO STEPDATA(#IDX) hourly_rt
    PUT &Y.DAILY_RT      INTO stepdata(#idx) daily_rt
    PUT &Y.MONTHLY_RT    INTO STEPDATA(#IDX) monthly_rt
    PUT &Y.ANNUAL_RT     INTO STEPDATA(#IDX) annual_rt
    PUT &Y.INCREM_MONTHS INTO STEPDATA(#IDX) increm_months
    PUT &Y.INCREM_HOURS  INTO STEPDATA(#IDX) increm_hours
    PUT &Y.CURRENCY_CD   INTO stepdata(#idx) currency_cd


    #DEBUGY display 'found a step'
    #DEBUGY display &y.step

    do GET-COMPONENTS

    put #save_comp_begin INTO stepdata(#idx) comp_begin_idx
    put #save_comp_end   INTO stepdata(#idx) comp_end_idx

    add 1 to #idx
  else
    display '*** Array overflow; limited to 30 steps. ***'
  end-if

  let #Max_Step = &Y.Step

FROM  PS_SAL_STEP_TBL Y
WHERE Y.SETID          = $SET                         !PUBSEC
AND   Y.SAL_ADMIN_PLAN = &Z.Sal_Admin_Plan
AND   Y.GRADE          = &Z.Grade
AND   Y.EFFDT          = &Z.EffDt
ORDER BY Y.STEP ASC
end-SELECT
end-procedure

!***********************************************************************
! Procedure: GET-COMPONENTS                                            *
! Descr:     Reads application table for all pay components which      *
!            comprise the current pay step for the employee.  Reads    *
!            database table PS_SAL_RATECD_TBL.                         *
!                                                                      *
! Called by: GET-STEPS                                                 *
!***********************************************************************
begin-procedure GET-COMPONENTS

#DEBUGY display 'reached get-components'

   move 'Y' to $First_Pass_Sw

begin-SELECT
SC.COMP_EFFSEQ
SC.COMP_RATECD
SC.CURRENCY_CD
SC.COMP_FREQUENCY
SC.HOURLY_RT
SC.MONTHLY_RT
SC.ANNUAL_RT
SC.COMP_RATE_POINTS
SC.COMP_PCT
SC.RATE_CODE_GROUP
SC.COMPRATE
SC.DAILY_RT
RC.COMP_RATE_TYPE
RC.COMP_BASE_PAY_SW

  if #SC_idx < 150

      if $First_Pass_Sw ='Y'
         move #SC_idx to #save_comp_begin
         move 'N' to $First_Pass_Sw
      end-if

     #DEBUGY display 'inside get components loop- comprate: ' noline

      put &SC.COMP_EFFSEQ      INTO stepcomp(#SC_idx) sc_Comp_Effseq
      put &SC.COMP_RATECD      INTO stepcomp(#SC_idx) sc_Comp_Ratecd
      put &SC.CURRENCY_CD      INTO stepcomp(#SC_idx) sc_Currency_cd
      put &SC.COMP_FREQUENCY   INTO stepcomp(#SC_idx) sc_Comp_Frequency
      put &SC.HOURLY_RT        INTO stepcomp(#SC_idx) sc_Hourly_Rt
      put &SC.MONTHLY_RT       INTO stepcomp(#SC_idx) sc_Monthly_Rt
      put &SC.ANNUAL_RT        INTO stepcomp(#SC_idx) sc_Annual_Rt
      put &SC.COMP_RATE_POINTS INTO stepcomp(#SC_idx) sc_Comp_Rate_Points
      put &SC.COMP_PCT         INTO stepcomp(#SC_idx) sc_Comp_Pct
      put &SC.RATE_CODE_GROUP  INTO stepcomp(#SC_idx) sc_Rate_Code_Group
      put &SC.COMPRATE         INTO stepcomp(#SC_idx) sc_Comprate

   #DEBUGY display &SC.COMPRATE
   #DEBUGY display #SC_idx

      put &SC.DAILY_RT         INTO stepcomp(#SC_idx) sc_Daily_Rt
      put &RC.COMP_RATE_TYPE   INTO stepcomp(#SC_idx) rc_comp_rate_type
      put &RC.COMP_BASE_PAY_SW INTO stepcomp(#SC_idx) rc_comp_base_pay_sw

      move #SC_idx to #save_comp_end

      add 1 to #SC_idx
   else
 !       display $CMP107_OVERFLOW1                                      !F-LPARKER-125 (CAMI)
 !       display $CMP107_OVERFLOW2                                      !F-LPARKER-125 (CAMI)
 !      display '*** Array overflow; limited to 150 compensation ratecodes ***'
 !      display '***    for a single salary grade.                         ***'
   end-if

FROM  PS_SAL_RATECD_TBL SC
    , PS_COMP_RATECD_TBL RC
WHERE SC.SETID          = $SET                         !PUBSEC
AND   SC.SAL_ADMIN_PLAN = &Z.SAL_ADMIN_PLAN
AND   SC.GRADE          = &Z.GRADE
AND   SC.EFFDT          = &Z.EFFDT
AND   SC.STEP           = &Y.STEP
AND   RC.COMP_RATECD    = SC.COMP_RATECD
AND   RC.EFFDT          = (SELECT MAX (EFFDT)
                             FROM PS_COMP_RATECD_TBL RC1
                             WHERE RC1.COMP_RATECD = SC.COMP_RATECD AND
                             EFFDT <= &Z.EFFDT)
ORDER BY SC.COMP_EFFSEQ DESC, SC.COMP_RATECD ASC
end-SELECT

   if $First_Pass_sw = 'Y'
      move 1 to #save_comp_begin
      move 0 to #save_comp_end
   end-if

end-procedure !GET-COMPONENTS


!***********************************************************************
! Procedure: PROCESS-EMPS                                              *
! Descr:     For the Grade specified find all employees whose job is   *
!            defined as been in the specified grade. This procedure    *
!            determines if the job compensation is within the range to *
!            to qualify for a step increase.                           *
!* Only process employees who are within $0.01 of the Hourly rate, or  *
!*                                within $0.10 of the Daily rate, or   *
!*                                within $1.00 of the Monthly Rate, or *
!*                                within $1.00 of the Annual Rate      *
!                                                                      *
! Called by: PLAN_GRADE                                                *
!***********************************************************************
begin-procedure PROCESS-EMPS

#DEBUGY display 'reached process-emps'
#DEBUGY display 'JobEffdt:' NOLINE
#DEBUGY display $JobEffdt
#DEBUGY display 'prcs_oprid:' NOLINE
#DEBUGY display $prcs_oprid
#DEBUGY display 'prcs_run_cntl_id:' NOLINE
#DEBUGY display $prcs_run_cntl_id


  let #Prev-Step = 999
  let $Prev_Emplid = ''
  let #Prev_Empl_Rcd = 0

begin-SELECT
A.EMPLID
A.EMPL_RCD
{DateOut-Prefix}A.EFFDT{DateOut-Suffix}   &a.effdt
A.EFFSEQ
A.DEPTID
A.JOBCODE
A.POSITION_NBR
A.APPT_TYPE
A.MAIN_APPT_NUM_JPN
A.POSITION_OVERRIDE
A.POSN_CHANGE_RECORD
A.EMPL_STATUS
A.ACTION
A.ACTION_DT
A.ACTION_REASON
A.LOCATION
A.TAX_LOCATION_CD
{DateOut-Prefix}A.JOB_ENTRY_DT{DateOut-Suffix}        &A.JOB_ENTRY_DT
{DateOut-Prefix}A.DEPT_ENTRY_DT{DateOut-Suffix}       &A.DEPT_ENTRY_DT
{DateOut-Prefix}A.POSITION_ENTRY_DT{DateOut-Suffix}   &a.position_entry_dt
A.SHIFT
A.REG_TEMP
A.FULL_PART_TIME
A.COMPANY
A.PAYGROUP
A.BAS_GROUP_ID
A.ELIG_CONFIG1
A.ELIG_CONFIG2
A.ELIG_CONFIG3
A.ELIG_CONFIG4
A.ELIG_CONFIG5
A.ELIG_CONFIG6
A.ELIG_CONFIG7
A.ELIG_CONFIG8
A.ELIG_CONFIG9
A.BEN_STATUS
A.BAS_ACTION
A.COBRA_ACTION
A.EMPL_TYPE
A.HOLIDAY_SCHEDULE
A.STD_HOURS
A.STD_HRS_FREQUENCY
A.OFFICER_CD
A.EMPL_CLASS
A.SAL_ADMIN_PLAN
A.GRADE
{DateOut-Prefix}A.GRADE_ENTRY_DT{DateOut-Suffix}   &A.GRADE_ENTRY_DT
A.STEP
{DateOut-Prefix}A.STEP_ENTRY_DT{DateOut-Suffix}    &A.STEP_ENTRY_DT
A.GL_PAY_TYPE
A.ACCT_CD
A.EARNS_DIST_TYPE
A.COMP_FREQUENCY
A.COMPRATE
A.CHANGE_AMT
A.CHANGE_PCT
A.ANNUAL_RT
A.MONTHLY_RT
A.DAILY_RT
A.HOURLY_RT
A.ANNL_BENEF_BASE_RT
A.SHIFT_RT
A.SHIFT_FACTOR
A.CURRENCY_CD
A.BUSINESS_UNIT
A.SETID_DEPT
A.SETID_JOBCODE
A.SETID_LOCATION
A.SETID_SALARY
A.REG_REGION
A.DIRECTLY_TIPPED
A.FLSA_STATUS
A.EEO_CLASS
A.FUNCTION_CD
A.TARIFF_GER
A.TARIFF_AREA_GER
A.PERFORM_GROUP_GER
A.LABOR_TYPE_GER
A.SPK_COMM_ID_GER
A.HOURLY_RT_FRA
A.ACCDNT_CD_FRA
A.VALUE_1_FRA
A.VALUE_2_FRA
A.VALUE_3_FRA
A.VALUE_4_FRA
A.VALUE_5_FRA
A.CTG_RATE
A.PAID_HOURS
A.PAID_FTE
A.PAID_HRS_FREQUENCY
A.UNION_FULL_PART
A.UNION_POS
A.MATRICULA_NBR
A.SOC_SEC_RISK_CODE
A.UNION_FEE_AMOUNT
{DateOut-Prefix}A.UNION_FEE_START_DT{DateOut-Suffix}     &A.UNION_FEE_START_DT
{DateOut-Prefix}A.UNION_FEE_END_DT{DateOut-Suffix}       &A.UNION_FEE_END_DT
A.EXEMPT_JOB_LBR
A.EXEMPT_HOURS_MONTH
A.WRKS_CNCL_FUNCTION
A.INTERCTR_WRKS_CNCL
A.CURRENCY_CD1
A.PAY_UNION_FEE
A.UNION_CD
A.BARG_UNIT
{DateOut-Prefix}A.UNION_SENIORITY_DT{DateOut-Suffix}     &A.UNION_SENIORITY_DT
{DateOut-Prefix}A.ENTRY_DATE{DateOut-Suffix}             &A.ENTRY_DATE
A.LABOR_AGREEMENT
A.EMPL_CTG
A.EMPL_CTG_L1
A.EMPL_CTG_L2
A.SETID_LBR_AGRMNT
A.GP_PAYGROUP
A.GP_DFLT_ELIG_GRP
A.GP_ELIG_GRP
A.GP_DFLT_CURRTTYP
A.CUR_RT_TYPE
A.GP_DFLT_EXRTDT
A.GP_ASOF_DT_EXG_RT
A.ADDS_TO_FTE_ACTUAL
A.CLASS_INDC
A.ENCUMB_OVERRIDE
A.FICA_STATUS_EE
A.FTE
A.PRORATE_CNT_AMT
A.PAY_SYSTEM_FLG
A.BORDER_WALKER
A.LUMP_SUM_PAY
A.CONTRACT_NUM
A.JOB_INDICATOR
A.WRKS_CNCL_ROLE_CHE
A.BENEFIT_SYSTEM
A.WORK_DAY_HOURS
A.SUPERVISOR_ID
A.REPORTS_TO
{DateOut-Prefix}A.FORCE_PUBLISH{DateOut-Suffix}          &A.FORCE_PUBLISH
A.JOB_DATA_SRC_CD
A.ESTABID
B.NAME
P.COUNTRY
F.FREQUENCY_TYPE

  let $Curr_Emplid = &A.EMPLID
  let #Curr_Empl_Rcd = &A.EMPL_RCD

  if $Curr_Emplid <> $Prev_Emplid or #Curr_Empl_Rcd <> #Prev_Empl_Rcd
    let $JobRefresh = 'Y'
    let $Prev_Emplid = &A.EMPLID
    let #Prev_Empl_Rcd = &A.EMPL_RCD
  end-if

  #DEBUGY display 'process emplid: ' NOLINE
  #DEBUGY display &A.EMPLID
  #DEBUGY display &A.effdt
  #DEBUGY display $JobEffdt

  !Refresh PS_BP_JOB from PS_JOB per employee when only processing one grade
  !Do not select based on Grade - the system will process for other grades
  !if the current Job Grade matches Run Control
  if $SetGrade = 'Y'
    do Refresh-Employee
    do Refresh-Emp-Compensation
  end-if

  !Reset the flags for each employee
  !$Current flag is set to indicate if it's a current job row
  !or a future-dated job row
  let $First = 'Y'
  let $Future = 'N'
  let $Calc_Job_Dt = ' '
  let $New_EffDt = ' '
  let $Prev_Effdt = &A.EFFDT


  let #Accum_Hours = 0
  let $Project_Start_Dt = &A.EFFDT


  let #JobStep = &A.STEP


  !if #JobStep <> #Prev-Step
    let $Step_Found = 'N'
    do Find-Step
  !  let #Prev-Step  = #JobStep
  !end-if

  let #NewJobStep = #New_Step

  let $New_Grade = rtrim(&A.Grade,' ')

  if $Step_Found = 'Y'

    !* Retrieve the PS_BP_COMPENSATION records for the current job record.  For all
    !*   "base pay" rows (i.e. RATE_CODE_CLASS not in ('SENPAY', 'EDUPAY', 'GRPPAY')
    !*   and MANUAL_SW <> 'Y') use the parameters in the StepComp array to calc
    !*   annual, monthly, daily, and hourly rates of pay.

       move 'Y' to $Base_Only_Sw

   #DEBUGY DISPLAY 'get base compensation from process-emp'

        do GET-BASE-COMPENSATION

   !* Only process employees who are within $0.01 of the Hourly rate, or
   !*                                within $0.10 of the Daily rate, or
   !*                                within $1.00 of the Monthly Rate, or
   !*                                within $1.00 of the Annual Rate
   !*  of their current step.

      let #Adj_Hourly_Rt  = #Job_Hourly_Rt                                  !PUBSEC
      let #Adj_Daily_Rt   = #Job_Daily_Rt                                   !PUBSEC
      let #Adj_Monthly_Rt = #Job_Monthly_Rt                                 !PUBSEC
      let #Adj_Annual_Rt  = #Job_Annual_Rt                                  !PUBSEC
      move &A.Position_Entry_Dt to $Pos_Entry_Dt

  #DEBUGY display 'Adjusted Rates'
  #DEBUGY display #Adj_Hourly_Rt
  #DEBUGY display #Adj_Daily_Rt
  #DEBUGY display #Adj_Monthly_Rt
  #DEBUGY display #Adj_Annual_Rt

  if #JobStep = #Max_Step
      let $Error-Msg = 'Employee is at maximum Step for Grade'
      do Write-Report

    else
    !  if &A.FTE = 0 or &A.FTE = 1                                     !PUBSEC
    !    let #Calc-monthly_rt = &A.Monthly_Rt                          !PUBSEC
    !    let #Calc-annual_rt  = &A.Annual_Rt                           !PUBSEC
    !  else                                                            !PUBSEC
    !    let #Calc-monthly_rt = &A.Monthly_Rt / &A.FTE                 !PUBSEC
    !    let #Calc-annual_rt  = &A.Annual_Rt  / &A.FTE                 !PUBSEC
    !  end-if

      !Only process employees who are within the range of the Hourly rate or
      !within the range of either Monthly or Annual Rate, of their current step.


      if (#Adj_Hourly_Rt  >= #Low_Hr_Rt and #Adj_Hourly_Rt  <= #High_Hr_Rt)    !PUBSEC
      or (#Adj_Daily_Rt   >= #Low_Dy_Rt and #Adj_Daily_Rt   <= #High_Dy_Rt)    !PUBSEC
      or (#Adj_Monthly_Rt >= #Low_Mn_Rt and #Adj_Monthly_Rt <= #High_Mn_Rt)    !PUBSEC
      or (#Adj_Annual_Rt  >= #Low_An_Rt and #Adj_Annual_Rt  <= #High_An_Rt)    !PUBSEC

        #DEBUGY DISPLAY 'inside  min max loop'
        do Save-Current-Job-Fields

        do Format-DateTime(&A.EFFDT, $Date1, {DEFCMP}, '', '')
        do Format-DateTime($JobEffdt, $Date2, {DEFCMP}, '', '')

        !Set up for future dated Job - when employee effective date is more than as of date from run control

        #DEBUGY DISPLAY 'DATES 1 AND 2: ' NOLINE
        #DEBUGY DISPLAY $Date1 NOLINE
        #DEBUGY DISPLAY ' - ' NOLINE
        #DEBUGY DISPLAY $Date2

        if $Date1 > $Date2
          let $Future = 'Y'
          let $Project_Start_Dt = &A.EFFDT
        #DEBUGY DISPLAY 'Set up for future dated Job'
        end-if

        While 1

          move 'N' to $Elig-For-Increm-Date
          move 'N' to $Elig_For_increm_hours

          !For Increment Type Date Based or Either
          if $Step_Increm_type = 'D' or $Step_Increm_type = 'E'
            !Based on Step_Entry_Dt
            do Check-Date-Elig
          end-if

          !For Increment Type Hours Based or Either
          if $Elig-For-Increm-Date = 'N' and
            ($Step_Increm_type = 'H' or $Step_Increm_type = 'E')
            do Check-Hours-Elig
          end-if

          if $Elig-For-Increm-Date = 'Y' or $Elig_For_increm_hours = 'Y'
            do Get-New-Dates
            !Look for future-dated Jobs
            !Skip the Jobs with Action/Action_Reason specified on the Run Control
        #DEBUGY DISPLAY 'calling Check-Future-Job-Reset'
            do Check-Future-Job-Reset

            !If there is a future-dated job before the new step increment
            !stop incrementing on the current job
            if $Reset = 'Y'
        #DEBUGY DISPLAY 'reset = Y'
              let $Error-Msg = 'Future Job exists, no Increment performed'
              do Write-Report
              break
            else
              !Use the future-dated job to do the increment
              do Check-Future-Job-NoReset

              Evaluate $FutureJob

                let $Exit = 'N'

                When = 'Y'
               #DEBUGY DISPLAY 'Set up for future dated Job'
                  do Calc-New-Rates-B
                  let $Error-Msg = ' '
                  do Write-Report
                  let $First = 'N'
                  let $Step_Entry_Dt= $New_EffDt
                  let $Prev_Effdt = $New_EffDt

                  if $Process = 'Y'
                  !   ******  Insert New Job Record with new Rates for new STEP
                    do Insert-New-Job-Rec
                  !   ******  Insert New Job Junior Row associated with New Job Row
     !             do Proc-Job-Junior

                  !   ******  Insert New Compensation Components for JOB ************
                  !   ******  Compensation Components derived directly from RATECD set up for new GRADE/STEP *********
                    do Determine-New-Compensations                                   !PUBSEC

                    do Proc-Job-Erns-Dist
                  end-if

                  !Check for next step
                  if #NewJobStep = #Max_Step
                    let $Exit = 'Y'
                    break
                  else
                    let $Step_Found_F = 'N'
                    let #FutureJobStep = #NewJobStep
                    !  if $grade_step_found = 'Y'
                    !    do Find-Step
                    !  else
                        do Find-Future-Job-Step
                    !  end-if
                    !Find the rates for new step
                    if $Step_Found_F = 'Y'
                      !continue
                      let #NewJobStep = #New_Step_F
                    else
                      let $Exit = 'Y'
                      break
                    end-if
                  end-if

                  do Format-DateTime($New_EffDt, $Check_Dt, {DEFCMP}, '', '')
        !           if $Check-Effdt >= $EndDt
                    if $Check_Dt >= $EndDt
                    let $Exit = 'Y'
                    break
                  end-if

                When = 'N'

                  if $FutureJob_Error = 'Y'
                    let $Error-Msg = 'Future Job not eligible'
                    do Write-Report
                    let $Exit = 'Y'
                    break

                  else
                    !No future Job rows, keep incrementing based on current Job
                    if $First = 'Y'
                         let $first_compensation = 'Y'
                    #DEBUGY display 'fisrt-step-increment'
                      do Calc-New-Rates-A
                    else
                    #DEBUGY display 'projecting step increment:'
                    #DEBUGY display 'continued'
                        do Calc-New-Rates-B
                    end-if

                    let $Error-Msg = ' '
                    do Write-Report

                    let $First = 'N'
                    let $Step_Entry_Dt= $New_EffDt
                    let $Prev_Effdt = $New_EffDt

                    if $Process = 'Y'         ! 'Y' = Report & Process Increases  PUBSEC
                      do Insert-New-Job-Rec   ! 'N' = Report Only                 PUBSEC
                        if $first_compensation = 'Y'
                        #debugy display 'determine compensations for first run'
                            do Determine-New-Compensations
                            let $first_compensation = 'N'
                        else
                            do Determine-New-Compensations-F
                        end-if
                      do Proc-Job-Erns-Dist
                    #debugy display 'end statement inside process = Y'
                    end-if

                    !Check for next Step
                #debugy display 'newjobstep: ' noline
                #debugy display #newjobstep
                #debugy display 'Max_Step: ' noline
                #debugy display #Max_Step

                    if #NewJobStep = #Max_Step
                      let $Exit = 'Y'
                      break
                    else
                      let $Step_Found_F = 'N'
                      let #JobStep = #NewJobStep
                      let $Comp_flag = 'Y'
                      do Find-Step
                      !Find the rates for new step
                      if $Step_Found_F = 'Y'
                        !continue
                        let #NewJobStep = #New_Step_F
                      else
                        let $Exit = 'Y'
                        break
                      end-if
                    end-if


                   do Format-DateTime($New_EffDt, $Check_Dt, {DEFCMP}, '', '')
        !           if $Check-Effdt >= $EndDt

      #DEBUGY display 'Check_Dt: ' noline
      #DEBUGY display $Check_Dt
      #DEBUGY display 'EndDt: ' noline
      #DEBUGY display $EndDt

                    if $Check_Dt >= $EndDt
                        let $Exit = 'Y'
                      break
                    end-if
                  end-if
              end-Evaluate

              if $Exit = 'Y'
                break
              end-if

            end-if
          else
            if $Current = 'Y'
              let $Error-Msg = 'Not Eligible'
              do Write-Report
            end-if
            break
          end-if

        end-while

      else
        let $Error-Msg = 'Current Salary Not within Range'
        do Write-Report
      end-if
    end-if
  else
    let $Error-Msg = 'Step Not Found'
    do Write-Report
  end-if

FROM PS_JOB            A,
     PS_PERSONAL_DATA  B,
     PS_PAYGROUP_TBL   P,
     PS_FREQUENCY_TBL  F
WHERE A.SAL_ADMIN_PLAN = &Z.Sal_Admin_Plan
  AND A.GRADE          = &Z.Grade
  AND ((A.EFFDT  =   (SELECT MAX(C.EFFDT)
                       FROM PS_JOB C
                      WHERE C.EMPLID    = A.EMPLID
                        AND C.EMPL_RCD = A.EMPL_RCD
                        AND C.EFFDT    <= {DateIn-Prefix}$New_Job_Effdt{DateIn-suffix})
        AND A.EFFSEQ = (SELECT MAX(D.EFFSEQ)
                         FROM PS_JOB D
                        WHERE D.EMPLID    = A.EMPLID
                          AND D.EMPL_RCD = A.EMPL_RCD
                          AND D.EFFDT     = A.EFFDT))
    OR ((A.EFFDT   > {DateIn-Prefix}$New_Job_Effdt{DateIn-suffix}
        AND A.EFFSEQ  =  (SELECT MAX(E.EFFSEQ)
                            FROM PS_JOB E
                           WHERE E.EMPLID    = A.EMPLID
                             AND E.EMPL_RCD = A.EMPL_RCD
                             AND E.EFFDT     = A.EFFDT)
        AND NOT EXISTS
        (SELECT 'X'
         FROM PS_BP_RNCTL_CMP107 BPCMP107
         WHERE BPCMP107.OPRID         = $prcs_oprid
           AND BPCMP107.RUN_CNTL_ID   = $prcs_run_cntl_id
           AND BPCMP107.ACTION        = A.ACTION
           AND BPCMP107.ACTION_REASON = A.ACTION_REASON)))
  )
  AND A.EMPL_STATUS NOT IN ('D', 'R', 'T')
  AND A.STEP    <> 0
  AND A.EMPLID    = B.EMPLID
  AND A.PAYGROUP  = P.PAYGROUP
  AND A.COMPANY   = P.COMPANY
  AND P.EFFDT     = (SELECT MAX(PP.EFFDT)
                       FROM PS_PAYGROUP_TBL PP
                      WHERE PP.COMPANY   = P.COMPANY
                        AND PP.PAYGROUP  = P.PAYGROUP
                        AND PP.EFFDT    <= {DateIn-Prefix}$New_Job_Effdt{DateIn-suffix})
  AND NOT EXISTS
      (SELECT 'X'
       FROM PS_RUN_CNTL_CMP107 RC,
            PS_EP_APPR EP
       WHERE RC.OPRID         = $prcs_oprid
         AND RC.RUN_CNTL_ID   = $prcs_run_cntl_id
         AND EP.EMPLID              = A.EMPLID
         AND EP.EMPL_RCD            = A.EMPL_RCD
         AND EP.EP_REVIEW_STATUS    = 'CO'
         AND (EP.EP_APPROVAL_STATUS = 'APRV' OR EP.EP_APPROVAL_STATUS = 'NREQ')
         AND EP.EP_REVIEW_TYPE = RC.EP_REVIEW_TYPE
         AND EP.PERIOD_END_DT       = (SELECT MAX(EP1.PERIOD_END_DT)
                                         FROM PS_EP_APPR EP1
                                        WHERE EP1.EMPLID              = A.EMPLID
                                          AND EP1.EMPL_RCD            = A.EMPL_RCD
                                          AND EP1.EP_REVIEW_STATUS    = 'CO'
                                          AND (EP1.EP_APPROVAL_STATUS = 'APRV' OR EP1.EP_APPROVAL_STATUS = 'NREQ')
                                          AND EP1.EP_REVIEW_TYPE = RC.EP_REVIEW_TYPE
                                          AND EP1.PERIOD_END_DT <= {DateIn-Prefix}$New_Job_Effdt{DateIn-suffix})
         AND EP.EP_CALC_METHOD = 'A'
         AND EP.RATING_MODEL   = RC.RATING_MODEL
         AND EP.REVIEW_RATING  = RC.REVIEW_RATING)
  AND A.COMP_FREQUENCY   = F.FREQUENCY_ID
  AND F.EFF_STATUS       = 'A'
  AND F.EFFDT            =
    (SELECT MAX(F1.EFFDT)
       FROM PS_FREQUENCY_TBL F1
      WHERE F1.FREQUENCY_ID   = F.FREQUENCY_ID
        AND F1.EFF_STATUS     = F.EFF_STATUS
        AND F1.EFFDT         <= A.EFFDT)


ORDER BY A.GRADE, A.STEP, B.NAME, A.EMPLID,
         A.EMPL_RCD, A.EFFDT, A.EFFSEQ
end-SELECT

end-procedure


!***********************************************************************
! Procedure: GET-BASE-COMPENSATION                                     *
! Descr:     Reads the PS_BP_COMPENSATION rows associated with a part-    *
!            icular PS_JOB row.  For all "base pay" components, it     *
!            calls CONVERT-COMPONENT-COMPRATE to find applicable rates *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure GET-BASE-COMPENSATION

   move 'Y' to $Base_Comps_Only

   move 0.00 to #Job_Comprate
   move 0.00 to #Job_Annual_Rt
   move 0.00 to #Job_Monthly_Rt
   move 0.00 to #Job_Daily_Rt
   move 0.00 to #Job_Hourly_Rt

   move 0 to #cp_idx
   move 0 to #cp_cnt

begin-SELECT
CP.EFFSEQ
CP.COMP_EFFSEQ
CP.COMP_RATECD
CP.COMP_RATE_POINTS
CP.COMPRATE
CP.COMP_PCT
CP.COMP_FREQUENCY
CP.CURRENCY_CD
CP.MANUAL_SW
CP.CONVERT_COMPRT
CP.RATE_CODE_GROUP
CP.FTE_INDICATOR
CP.CMP_SRC_IND
CR.RATE_CODE_CLASS


   add 1 to #cp_idx
   put &CP.EFFSEQ            into CompArray (#cp_idx) cp_effseq
   put &CP.COMP_EFFSEQ       into CompArray (#cp_idx) cp_comp_effseq
   put &CP.COMP_RATECD       into CompArray (#cp_idx) cp_comp_ratecd
   put &CP.COMP_RATE_POINTS  into CompArray (#cp_idx) cp_comp_rate_points
   put &CP.COMPRATE          into CompArray (#cp_idx) cp_comprate

   put &CP.COMP_PCT          into CompArray (#cp_idx) cp_comp_pct
   put &CP.COMP_FREQUENCY    into CompArray (#cp_idx) cp_comp_frequency
   put &CP.CURRENCY_CD       into CompArray (#cp_idx) cp_currency_cd
   put &CP.MANUAL_SW         into CompArray (#cp_idx) cp_manual_sw
   put &CP.CONVERT_COMPRT    into CompArray (#cp_idx) cp_convert_comprt
   put &CP.RATE_CODE_GROUP   into CompArray (#cp_idx) cp_rate_code_group
   put &CP.FTE_INDICATOR     into CompArray (#cp_idx) cp_fte_indicator
   put &CP.CMP_SRC_IND       into CompArray (#cp_idx) cp_cmp_src_ind
   put &CR.RATE_CODE_CLASS   into CompArray (#cp_idx) cp_rate_code_class

   if &CR.Rate_Code_Class = 'SENPAY' ! or &CR.Rate_Code_Class = 'EDUPAY'  or  &CR.Rate_Code_Class = 'GRPPAY'
      or &CP.Manual_Sw = 'Y'


    #DEBUGY display 'inside get compensation loop'

      move 'N' to $Base_Comps_Only

      !***** This message is really useful if you do not know why people are not qualifying for increase
      !let $error-msg = &CR.Rate_Code_Class || ' bypassed in Base Compensation'
      !do write-report
      !let $error_msg = ' '

    #DEBUGY display 'base only sw:' noline
    #DEBUGY display $Base_Only_Sw

      if $Base_Only_Sw <> 'Y'

    #DEBUGY display 'base only sw inside:' noline
    #DEBUGY display $Base_Only_Sw

         do CONVERT-OLD-COMPONENT-COMPRATE
         add #Exc_Comprate   to #Job_Comprate
         add #Exc_Annual_Rt  to #Job_Annual_Rt
         add #Exc_Monthly_Rt to #Job_Monthly_Rt
         add #Exc_Daily_Rt   to #Job_Daily_Rt
         add #Exc_Hourly_Rt  to #Job_Hourly_Rt

      end-if
   else

    #DEBUGY display 'else statement in get compensation loop'

      do CONVERT-OLD-COMPONENT-COMPRATE
      add #Exc_Comprate   to #Job_Comprate
      add #Exc_Annual_Rt  to #Job_Annual_Rt
      add #Exc_Monthly_Rt to #Job_Monthly_Rt
      add #Exc_Daily_Rt   to #Job_Daily_Rt
      add #Exc_Hourly_Rt  to #Job_Hourly_Rt

   end-if

FROM PS_COMPENSATION CP
   , PS_COMP_RATECD_TBL CR
WHERE CP.EMPLID      = &A.EMPLID
  AND CP.EMPL_RCD    = &A.EMPL_RCD
  AND CP.EFFDT       = &A.EFFDT
  AND CP.EFFSEQ      = &A.EFFSEQ
  AND CP.COMP_RATECD = CR.COMP_RATECD
  AND CR.EFF_STATUS  = 'A'
  AND CR.EFFDT       = (SELECT MAX(CR1.EFFDT)
                          FROM PS_COMP_RATECD_TBL CR1
                         WHERE CR1.COMP_RATECD = CP.COMP_RATECD
                           AND CR1.EFFDT      <= &A.EFFDT)
end-SELECT

   move #cp_idx to #cp_cnt

   #DEBUGY display 'exit get compensation loop'

end-procedure GET-BASE-COMPENSATION

!***********************************************************************
! Procedure: CONVERT-OLD-COMPONENT-COMPRATE                            *
! Descr:     For each pay component, this module calls ConvertCurrency *
!            to calculate pay in the base currency for PS_JOB, then it *
!            converts the result based on the Pay Frequency parameters *
!            from PS_JOB.  Following this, the Annual, Monthly, Daily  *
!            and Hourly rates are calculated using called procedures.  *
!                                                                      *
! Called by: GET-BASE-COMPENSATION                                     *
!***********************************************************************
begin-procedure CONVERT-OLD-COMPONENT-COMPRATE

   #DEBUGY display 'convert comp rate'


   do CONVERTCURRENCY(&CP.COMPRATE,&CP.CURRENCY_CD,$Old_Step_Currency,
                      'OFFIC',&A.EFFDT,#Wrk_Comprate,'W')

   do CONVERT-FREQUENCY(&A.EFFDT,#Wrk_Comprate,&CP.COMP_FREQUENCY,'A',
                        &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Comprate)

   if &A.COMP_FREQUENCY = 'C'
      let $Monthly_Freq = ' '
      let $Daily_Freq = ' '
      do GET-PAYGROUP-FREQ-CNT(&A.EMPLID,&A.EMPL_RCD,&A.EFFDT,$Monthly_Freq,$Daily_Freq)
   else
      let $Monthly_Freq = 'M'
      let $Daily_Freq = 'D'
   end-if

   do DET-ANNUAL-RT(&A.EFFDT,#Exc_Comprate,'A',
                        &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Annual_Rt)

   do DET-MONTHLY-RT(&A.EFFDT,#Exc_Comprate,'A',$Monthly_Freq,
                        &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Monthly_Rt)

   do DET-DAILY-RT(&A.EFFDT,#Exc_Comprate,'A',$Daily_Freq,
                        &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_daily_rt)

   do DET-HOURLY-RT(&A.EFFDT,#Exc_Comprate,'A',
                        &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Hourly_rt)


   !*** Comprate does not reflect FTE
   !let #Exc_Comprate   = #Exc_Comprate
   !let #Exc_Annual_Rt  = #Exc_Annual_Rt
   !let #Exc_Monthly_Rt = #Exc_Monthly_Rt
   !let #Exc_Daily_Rt   = #Exc_Daily_Rt
   !let #Exc_Hourly_Rt  = #Exc_Hourly_Rt

   ! if &CP.FTE_INDICATOR = 'Y' and &A.FTE < 1
   !   let #Exc_Comprate   = #Exc_Comprate * &A.FTE
   !   let #Exc_Annual_Rt  = #Exc_Annual_Rt * &A.FTE
   !   let #Exc_Monthly_Rt = #Exc_Monthly_Rt * &A.FTE
   !   let #Exc_Daily_Rt   = #Exc_Daily_Rt * &A.FTE
   !   let #Exc_Hourly_Rt  = #Exc_Hourly_Rt * &A.FTE
   !end-if

end-procedure !CONVERT-COMPONENT-COMPRATE

!***********************************************************************
! Procedure: PROC-JOB-ERNS-DIST                                        *
! Descr:     Reads the BP_JOB_ERN_DIST rows associated with a part-  *
!            icular PS_BP_JOB row.  Inserts rows into PS_JOB_EARNS_DIST   *
!            for new PS_BP_JOB record.                                    *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure PROC-JOB-ERNS-DIST
#DEBUGY display 'proc-job-erns-dist'

  if $JobRefresh <> 'N'
    do Refresh-JobDist-Rec
  end-if

begin-SELECT
J.EMPLID
J.EMPL_RCD
J.EFFDT
J.EFFSEQ
J.DEPTID
J.JOBCODE
J.POSITION_NBR
J.GL_PAY_TYPE
J.ACCT_CD
J.SHIFT
J.LOCATION
J.ERNCD
J.COMPRATE
J.DIST_PCT
J.STD_HOURS
J.BUSINESS_UNIT

  do Insert-New-JobDist-Rec

FROM PS_BP_JOB_ERN_DIST J

WHERE J.EMPLID    = $EMPLID
  AND J.EMPL_RCD  = #EMPL_RCD
  AND J.EFFDT   =
                    (SELECT MAX(J1.EFFDT)
                       FROM PS_BP_JOB_ERN_DIST J1
                      WHERE J1.EMPLID    = J.EMPLID
                        AND J1.EMPL_RCD  = J.EMPL_RCD
                        AND J1.EFFDT     = {DateIn-Prefix}$EFFDT{DateIn-suffix})
  AND J.EFFSEQ    =
                    (SELECT MAX(J2.EFFSEQ)
                       FROM PS_BP_JOB_ERN_DIST J2
                      WHERE J2.EMPLID    = J.EMPLID
                        AND J2.EMPL_RCD = J.EMPL_RCD
                        AND J2.EFFDT     = J.EFFDT)

ORDER BY J.EMPL_RCD ASC,
         J.EFFDT ASC,
         J.EFFSEQ ASC
end-SELECT
end-procedure

!***********************************************************************
! Procedure: FIND-STEP                                                 *
! Descr:     While processing the employee's job using the step        *
!            find the existing rates for the grade and step.  Save for *
!            future the new rates and step if the employee qualifies   *
!            for a step increase.                                      *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure Find-Step
!***********************************************************************

#DEBUGY display 'find-step'
#DEBUGY DISPLAY 'step:' NOLINE
#DEBUGY DISPLAY #JobStep
#DEBUGY DISPLAY 'for fisrt Job: ' NOLINE
#DEBUGY DISPLAY $first

  move 0 to #idx

  while #idx <= 29
    get #Step from StepData(#idx) step

    if #JobStep = #Step

      if ($First ='Y' and $Future = 'N')

#DEBUGY DISPLAY 'first - Y and Furture - N'

        let $Step_Found = 'Y'
        get #increm_months    from StepData(#idx) increm_months
        get #increm_hours     from StepData(#idx) increm_hours
        get #Old_Step_Hr_Rate from StepData(#idx) hourly_rt       !PUBSEC
        get #Old_Step_Dy_Rate from Stepdata(#idx) daily_rt          !PUBSEC
        get #Old_Step_Mn_Rate from StepData(#idx) monthly_rt      !PUBSEC
        get #Old_Step_An_Rate from StepData(#idx) annual_rt       !PUBSEC
        get $Old_Step_Currency  from Stepdata(#idx) currency_cd
        get #Old_comp_begin_idx from Stepdata(#idx) comp_begin_idx
        get #Old_comp_end_idx   from Stepdata(#idx) comp_end_idx


      let #Low_Hr_Rt  = #Old_Step_Hr_Rate - .01                        !PUBSEC
      let #High_Hr_Rt = #Old_Step_Hr_Rate + .01                        !PUBSEC
      let #Low_Dy_Rt  = #Old_Step_Dy_Rate - .10                        !PUBSEC
      let #High_Dy_Rt = #Old_Step_Dy_Rate + .10                        !PUBSEC
      let #Low_Mn_Rt  = #Old_Step_Mn_Rate - 1                          !PUBSEC
      let #High_Mn_Rt = #Old_Step_Mn_Rate + 1                          !PUBSEC
      let #Low_An_Rt  = #Old_Step_An_Rate - 1                          !PUBSEC
      let #High_An_Rt = #Old_Step_An_Rate + 1                          !PUBSEC

      #DEBUGY display 'show low - high rates'
      #DEBUGY display #Low_Hr_Rt
      #DEBUGY display #High_Hr_Rt
      #DEBUGY display #Low_Dy_Rt
      #DEBUGY display #High_Dy_Rt
      #DEBUGY display #Low_Mn_Rt
      #DEBUGY display #High_Mn_Rt
      #DEBUGY display #Low_An_Rt
      #DEBUGY display #High_An_Rt


        add 1 to #idx

      get #New_Step            from Stepdata(#idx) step
      get #New_Step_Hourly_Rt  from Stepdata(#idx) hourly_rt
      get #New_Step_Daily_Rt   from Stepdata(#idx) daily_rt
      get #New_Step_Monthly_Rt from Stepdata(#idx) monthly_rt
      get #New_Step_Annual_Rt  from Stepdata(#idx) annual_rt
      get $New_Step_Currency   from Stepdata(#idx) currency_cd
      get #New_comp_begin_idx  from Stepdata(#idx) comp_begin_idx
      get #New_comp_end_idx    from Stepdata(#idx) comp_end_idx

        break

      else

#DEBUGY DISPLAY 'step found future - Y'
        let $Step_Found_F = 'Y'
        get #Old_Step_Hr_Rate_F from StepData(#idx) hourly_rt       !PUBSEC
        get #Old_Step_Dy_Rate_F from Stepdata(#idx) daily_rt          !PUBSEC
        get #Old_Step_Mn_Rate_F from StepData(#idx) monthly_rt      !PUBSEC
        get #Old_Step_An_Rate_F from StepData(#idx) annual_rt       !PUBSEC
        get $Old_Step_Currency_F  from Stepdata(#idx) currency_cd
        get #Old_comp_begin_idx_F from Stepdata(#idx) comp_begin_idx
        get #Old_comp_end_idx_F   from Stepdata(#idx) comp_end_idx

        let #Low_Hr_Rt_F  = #Old_Step_Hr_Rate_F - .01               !PUBSEC
        let #High_Hr_Rt_F = #Old_Step_Hr_Rate_F + .01               !PUBSEC
        let #Low_Dy_Rt_F  = #Old_Step_Dy_Rate_F - .10                        !PUBSEC
        let #High_Dy_Rt_F = #Old_Step_Dy_Rate_F + .10                        !PUBSEC
        let #Low_Mn_Rt_F  = #Old_Step_Mn_Rate_F - 1                 !PUBSEC
        let #High_Mn_Rt_F = #Old_Step_Mn_Rate_F + 1                 !PUBSEC
        let #Low_An_Rt_F  = #Old_Step_An_Rate_F - 1                 !PUBSEC
        let #High_An_Rt_F = #Old_Step_An_Rate_F + 1                 !PUBSEC



      #DEBUGY display 'show low - high rates'
      #DEBUGY display #Low_Hr_Rt_F
      #DEBUGY display #High_Hr_Rt_F
      #DEBUGY display #Low_Dy_Rt_F
      #DEBUGY display #High_Dy_Rt_F
      #DEBUGY display #Low_Mn_Rt_F
      #DEBUGY display #High_Mn_Rt_F
      #DEBUGY display #Low_An_Rt_F
      #DEBUGY display #High_An_Rt_F

        add 1 to #idx

        get #New_Step_F            from StepData(#idx) step
        get #New_Step_hourly_rt_F  from StepData(#idx) hourly_rt
        get #New_Step_Dy_rt_F      from Stepdata(#idx) daily_rt          !PUBSEC
        get #New_Step_monthly_rt_F from StepData(#idx) monthly_rt
        get #New_Step_annual_rt_F  from StepData(#idx) annual_rt
        get $New_Step_Currency_F   from Stepdata(#idx) currency_cd
        get #New_comp_begin_idx_F    from Stepdata(#idx) comp_begin_idx
        get #New_comp_end_idx_F      from Stepdata(#idx) comp_end_idx

 #DEBUGY DISPLAY  $new_JobRec_effdt
 #DEBUGY DISPLAY  #New_comp_begin_idx_F
 #DEBUGY DISPLAY  #New_comp_end_idx_F

       if $Comp_flag = 'Y'
          do GET-BASE-COMPENSATION-F1
       end-if

        break
      end-if
    end-if

    add 1 to #idx
  end-while
end-procedure

!***********************************************************************
begin-procedure Check-Date-Elig
!***********************************************************************

#DEBUGY display 'check-date-elig:'
#DEBUGY display 'Step_Entry_Dt: ' noline
#DEBUGY display $Step_Entry_Dt
#DEBUGY display 'Effdt: ' noline
#DEBUGY display $Effdt

  let $Date1 = $Step_Entry_Dt
  do  Format-DateTime($Date1, $Date1, {DEFCMP}, '', '')

  let #Year1        = to_number(substr($Date1, 1, 4))
  let #Month1       = to_number(substr($Date1, 5, 2))
  let #Day1         = to_number(substr($Date1, 7, 2))
  let #Total_Months = (#Year1 * 12) + #Month1 + #increm_months
  let #Year2        = trunc(#Total_Months / 12, 0)
  let #Month2       = mod(#Total_Months, 12)

  if #Month2 = 0
    let #Year2  = #Year2 - 1
    let #Month2 = 12
  end-if

  let #Day2      = #Day1
  let #Remainder = mod(#Year2, 4)

  if #Remainder <> 0 or #Year2 = 0          !if not leap year
    put 28 into Month_Array(1) Days
  else                                      !else if leap year
    put 29 into Month_Array(1) Days
  end-if

  let #Offset = #Month2 - 1
  get #Days from Month_Array(#Offset) Days  !get days in month

#DEBUGY   display 'start'
#DEBUGY   display #Year1
#DEBUGY   display #Month1
#DEBUGY   display #Day1
#DEBUGY   display #increm_months
#DEBUGY   display #Year2
#DEBUGY   display #MOnth2
#DEBUGY   display #Day2
#DEBUGY   display #Days


  if #Day2 > #Days                          !if fewer days in month
    let #Day2 = #Days
  end-if

  let $Date2 = lpad(to_char(#Year2),  2, '0') || '/' ||
               lpad(to_char(#Month2), 2, '0') || '/' ||
               lpad(to_char(#Day2),   2, '0')

  do Format-DateTime($Date2, $Date2, {DEFYMD}, '', {DEFDATE})
  do Format-DateTime($Date2, $Date2, {DEFCMP}, '', '')
  do Format-DateTime($Effdt, $EffdtCmp, {DEFCMP}, '', '')

  if $Date2 >= $EffdtCmp and $Date2 <= $EndDt 
#DEBUGY display 'eligeble for increment date'
    move 'Y' to $Elig-For-Increm-Date
  end-if

#debugy display 'Date2: ' noline
#debugy display $Date2

!  do Format-DateTime($Date2, $Calc_Job_Dt, {DEFCMP}, '', {DEFDATE})
!  do Format-DateTime($Date2, $Calc_Job_Dt, {DEFCMP}, '', {DEFCMP})

let $Calc_Job_Dt = $Date2

#debugy display 'Calc_Job_Dt: ' noline
#debugy display $Calc_Job_Dt

end-procedure

!***********************************************************************
begin-procedure Check-Hours-Elig
!***********************************************************************

#DEBUGY display 'check-hours-elig/first Job/future-dated row:'
#DEBUGY display $First NOLINE
#DEBUGY display $Future

  !Only get real accumulated hours the first time
  if ($First = 'Y' and $Future = 'N')
    do Get-Accum-Hours

    if #Accum_Hours >= #increm_hours and #Accum_Hours <> 0
!      do Format-DateTime($Project_Start_Dt, $Calc_Job_Dt, {DEFCMP}, '', {DEFDATE})
!      do Format-DateTime($Project_Start_Dt, $Calc_Job_Dt, {DEFCMP}, '', {DEFYMD})
      do Format-DateTime($Project_Start_Dt, $Calc_Job_Dt, {DEFCMP}, '','')
    #debugy display 'project start date: ' noline
    #debugy display $Project_Start_Dt
    #debugy display $Calc_Job_Dt
      move 'Y' to $Elig_For_increm_hours
      let #Accum_Hours = #increm_hours - #Accum_Hours
    end-if
  end-if

  if $Elig_For_increm_hours <> 'Y'
    do Check-Projected-Hours-Elig
  end-if

end-procedure

!***********************************************************************
begin-procedure Get-Accum-Hours
!***********************************************************************

#DEBUGY display 'get-accum-hours'

  if &P.COUNTRY = 'CAN'
     do Get-CAN-Accum-Hours
  else
     do Get-USA-Accum-Hours
  end-if


end-procedure

!***********************************************************************
Begin-Procedure Get-CAN-Accum-Hours
!***********************************************************************

#DEBUGY display 'get-canadian-accum-hours'

let $Get-Pay-Period = 'Y'

begin-SELECT
F.COMPANY
F.BALANCE_YEAR
F.BALANCE_ID
F.WAGE_LOSS_PLAN
F.PROVINCE
F.BALANCE_QTR
F.BALANCE_PERIOD
F.HRS_YTD

  add &F.Hrs_YTD to #Accum_Hours

  if $Get-Pay-Period = 'Y'
    !Get the pay-end-dt for the latest pay run posted to the earnings balance
    let #Balance_Year =  &F.Balance_Year
    let #Balance_Qtr  =  &F.Balance_Qtr
    let #Balance_Period =&F.Balance_Period
    let $Get-Pay-Period = 'N'
    DO Get-Last-Pay-End-Dt
  end-if


FROM  PS_CAN_ERN_BALANCE F
WHERE F.SPCL_BALANCE = 'Y'
AND   F.ERNCD        = $Step_Increm_Accum
AND   F.EMPLID       = &A.EmplID
AND   F.EMPL_RCD     = &A.Empl_Rcd
AND   F.BALANCE_PERIOD    =
                 (SELECT MAX(G.BALANCE_PERIOD)
                   FROM  PS_CAN_ERN_BALANCE G
                   WHERE G.EMPLID         = F.EMPLID
                    AND  G.EMPL_RCD       = F.EMPL_RCD
                    AND  G.COMPANY        = F.COMPANY
                    AND  G.ERNCD          = F.ERNCD             !PUBSEC
                    AND  G.BALANCE_YEAR   = F.BALANCE_YEAR
                    AND  G.BALANCE_ID     = F.BALANCE_ID
                    AND  G.WAGE_LOSS_PLAN = F.WAGE_LOSS_PLAN
                    AND  G.PROVINCE       = F.PROVINCE)
AND  F.BALANCE_ID = $Calendar_Year_Id
ORDER BY F.BALANCE_YEAR ASC, F.BALANCE_QTR ASC, F.BALANCE_PERIOD ASC
end-SELECT
end-procedure

!***********************************************************************
Begin-Procedure Get-USA-Accum-Hours
!***********************************************************************

#DEBUGY display 'get-usa-accum-hours'

let $Get-Pay-Period = 'Y'

begin-SELECT
BAL.COMPANY
BAL.BALANCE_YEAR
BAL.BALANCE_ID
BAL.BALANCE_QTR
BAL.BALANCE_PERIOD
BAL.HRS_YTD

  add &BAL.Hrs_YTD to #Accum_Hours

  if $Get-Pay-Period = 'Y'
    !Get the pay-end-dt for the latest pay run posted to the earnings balance
    let #Balance_Year =  &BAL.Balance_Year
    let #Balance_Qtr  =  &BAL.Balance_Qtr
    let #Balance_Period =&BAL.Balance_Period
    let $Get-Pay-Period = 'N'
    DO Get-Last-Pay-End-Dt
  end-if

FROM  PS_EARNINGS_BAL BAL
WHERE BAL.SPCL_BALANCE = 'Y'
AND   BAL.ERNCD        = $Step_Increm_Accum
AND   BAL.EMPLID       = &A.EmplID
AND   BAL.EMPL_RCD     = &A.Empl_Rcd
AND   BAL.BALANCE_PERIOD    =
                 (SELECT MAX(BAL1.BALANCE_PERIOD)
                   FROM  PS_EARNINGS_BAL BAL1
                   WHERE BAL1.EMPLID         = BAL.EMPLID
                    AND  BAL1.EMPL_RCD       = BAL.EMPL_RCD
                    AND  BAL1.COMPANY        = BAL.COMPANY
                    AND  BAL1.ERNCD          = BAL.ERNCD             !PUBSEC
                    AND  BAL1.BALANCE_YEAR   = BAL.BALANCE_YEAR
                    AND  BAL1.BALANCE_ID     = BAL.BALANCE_ID)

!AND  BAL.BALANCE_YEAR =  (SELECT MAX(BAL2.BALANCE_YEAR)
!                   FROM  PS_EARNINGS_BAL BAL2
!                   WHERE BAL2.EMPLID         = BAL.EMPLID
!                    AND  BAL2.COMPANY        = BAL.COMPANY
!                    AND  BAL2.ERNCD          = BAL.ERNCD             !PUBSEC
!                    AND  BAL2.BALANCE_ID     = BAL.BALANCE_ID)

AND  BAL.BALANCE_ID = $Calendar_Year_Id
ORDER BY BAL.BALANCE_YEAR DESC, BAL.BALANCE_QTR DESC, BAL.BALANCE_PERIOD DESC

end-SELECT
end-procedure


!***********************************************************************
begin-procedure Get-Last-Pay-End-Dt
!***********************************************************************
#DEBUGY display 'get-last-pay-end-dt'

begin-SELECT
ID.COMPANY
ID.PAYGROUP
{DateOut-Prefix}ID.PAY_END_DT{DateOut-suffix}   &ID.PAY_END_DT
ID.BALANCE_YEAR
ID.BALANCE_ID
ID.BALANCE_QTR
ID.BALANCE_PERIOD

    Let $Project_Start_Dt = &ID.PAY_END_DT

    #DEBUGY display 'Project_Start_Dt' noline
    #DEBUGY display $Project_Start_Dt


FROM PS_PAY_CAL_BAL_ID ID
WHERE ID.COMPANY  = $Company
  AND ID.PAYGROUP = $Paygroup
  AND ID.BALANCE_YEAR = #Balance_Year
  AND ID.BALANCE_ID = $Calendar_Year_Id
  AND ID.BALANCE_QTR = #Balance_Qtr
  AND ID.BALANCE_PERIOD = #Balance_Period
  AND ID.PAY_END_DT = (SELECT MAX(ID1.PAY_END_DT) FROM PS_PAY_CAL_BAL_ID ID1
                      WHERE ID1.COMPANY = ID.COMPANY
                        AND ID1.PAYGROUP = ID.PAYGROUP
                        AND ID1.BALANCE_YEAR = ID.BALANCE_YEAR
                        AND ID1.BALANCE_ID = ID.BALANCE_ID
                        AND ID1.BALANCE_QTR = ID.BALANCE_QTR
                        AND ID1.BALANCE_PERIOD = ID.BALANCE_PERIOD)
end-SELECT
end-procedure

!***********************************************************************
begin-procedure  Check-Projected-Hours-Elig
!***********************************************************************

#DEBUGY display 'check-projected-hours-elig from:'
#DEBUGY display $Project_Start_Dt
#DEBUGY display 'std hours: ' NOLINE
#DEBUGY display #STD_HOURS
#DEBUGY display 'hours to next step:' NOLINE
#DEBUGY display #increm_hours
#DEBUGY display 'hours accumulated: ' NOLINE
#DEBUGY display #Accum_Hours


  !Estimate new Job Effective Date based on EE Job Std Hrs
  !Convert to weeks for comparison

  if #STD_HOURS > 0
    Let #increm_hours-to-Week = (#increm_hours -#Accum_Hours) /#STD_HOURS

   !Use Pay_End_Dt from last confirmed pay run as the basis for date calc

    do Convert-To-DTU-Date($Project_Start_Dt, $dtu_date_in)
    do dtu-add-weeks($dtu_date_in, #increm_hours-to-Week, $dtu_date_out)
    do Convert-From-DTU-Date($dtu_date_out, $dtu_date_out)
    do Format-DateTime($dtu_date_out, $Increment-Dt, {DEFCMP}, '', '')

    !$Increment-Dt is always > $StartDt
    if  ($Increment-Dt <= $EndDt)
      let  $Calc_Job_Dt = $Increment-Dt
      move 'Y' to $Elig_For_increm_hours
    end-if

    !For projecting step increment, set the hours earned to 0
    let #Accum_Hours = 0

  end-if

end-procedure

!***********************************************************************
begin-Procedure Get-New-Dates
!***********************************************************************

#DEBUGY display 'get-new-dates'
#DEBUGY display 'Calc_Job_Dt: ' noline
#DEBUGY display $Calc_Job_Dt
#DEBUGY display 'Prev_Effdt:' NOLINE
#DEBUGY display $Prev_Effdt
  !Compare calculated Increment Date with current Job Effective Date

! do Format-DateTime($Prev_Effdt, $OldEffdt, {DEFCMP}, '', {DEFDATE})

 do Format-DateTime($Prev_Effdt, $OldEffdt, {DEFCMP}, '', '')

#DEBUGY display 'OldEffdt: ' noline
#DEBUGY display $OldEffdt

! do Format-DateTime($Calc_Job_Dt, $Calc_Job_Dt, {DEFCMP}, '', '')

#DEBUGY display 'Calc_Job_Dt: ' noline
#DEBUGY display $Calc_Job_Dt

  if $Calc_Job_Dt > $OldEffdt
    let $New_EffDt = $Calc_Job_Dt
    let #New_EffSeq = 0
  else
    let $New_EffDt  = $OldEffdt
    let #New_EffSeq = #EFFSEQ + 1
  end-if

!  do Format-DateTime($New_EffDt, $New_EffDt, {DEFCMP}, '', {DEFDATE})

  do Format-DateTime($New_EffDt, $New_EffDt, {DEFCMP}, '', {DEFCMP})
  let $Project_Start_Dt = $New_EffDt

  #DEBUGY display '$New_EffDt:' NOLINE
  #DEBUGY display $New_EffDt
  #DEBUGY display '#New_EffSeq:' NOLINE
  #DEBUGY display #New_EffSeq


end-procedure

!***********************************************************************
begin-procedure  Check-Future-Job-Reset
!***********************************************************************

#DEBUGY display 'check-future-job-reset'
#DEBUGY display 'Prev_Effdt:' NOLINE
#DEBUGY display $Prev_Effdt
#DEBUGY display 'New_EffDt: ' NOLINE
#DEBUGY display $New_EffDt


let $Reset = 'N'

begin-SELECT
A1.EMPLID
A1.EMPL_RCD
A1.EFFDT
A1.EFFSEQ
A1.ACTION
A1.ACTION_DT
A1.ACTION_REASON

     let $Reset = 'Y'
    #DEBUGY display 'check-future-job-reset inside'


FROM PS_JOB            A1,
     PS_PERSONAL_DATA  B1,
     PS_PAYGROUP_TBL   P1,
     PS_FREQUENCY_TBL  F1

WHERE A1.EMPLID = &A.EMPLID
  AND A1.EMPL_RCD = &A.EMPL_RCD
  AND A1.SAL_ADMIN_PLAN = &Z.Sal_Admin_Plan
  AND A1.EFFDT  =   (SELECT MAX(C1.EFFDT)
                       FROM PS_JOB C1
                      WHERE C1.EMPLID    = A1.EMPLID
                        AND C1.EMPL_RCD = A1.EMPL_RCD
                        AND C1.EFFDT    <= {DateIn-Prefix}$New_EffDt{DateIn-suffix})
  AND A1.EFFSEQ = (SELECT MAX(D1.EFFSEQ)
                         FROM PS_JOB D1
                        WHERE D1.EMPLID    = A1.EMPLID
                          AND D1.EMPL_RCD = A1.EMPL_RCD
                          AND D1.EFFDT     = A1.EFFDT)

  AND A1.EFFDT > {DateIn-Prefix}$Prev_Effdt{DateIn-suffix}
  !AND A1.EFFDT <> {DateIn-Prefix}&A.EFFDT{DateIn-suffix}
  AND A1.EMPL_STATUS NOT IN ('D', 'R', 'T')
  AND A1.STEP    <> 0
  AND A1.EMPLID    = B1.EMPLID
  AND A1.PAYGROUP  = P1.PAYGROUP
  AND A1.COMPANY   = P1.COMPANY
  AND P1.EFFDT     = (SELECT MAX(PP1.EFFDT)
                      FROM PS_PAYGROUP_TBL PP1
                      WHERE PP1.COMPANY   = P1.COMPANY
                        AND PP1.PAYGROUP  = P1.PAYGROUP
                        AND PP1.EFFDT    <= {DateIn-Prefix}$New_EffDt{DateIn-suffix})
  AND NOT EXISTS
        (SELECT 'X'
         FROM PS_BP_RNCTL_CMP107 BPCMP107
         WHERE BPCMP107.OPRID         = $prcs_oprid
           AND BPCMP107.RUN_CNTL_ID   = $prcs_run_cntl_id
           AND BPCMP107.ACTION        = A1.ACTION
           AND BPCMP107.ACTION_REASON = A1.ACTION_REASON)

  AND NOT EXISTS
    (SELECT 'X'
       FROM PS_RUN_CNTL_CMP107 RC,
            PS_EP_APPR EP
       WHERE RC.OPRID          = $prcs_oprid
         AND RC.RUN_CNTL_ID    = $prcs_run_cntl_id
         AND EP.EMPLID              = A1.EMPLID
         AND EP.EMPL_RCD            = A1.EMPL_RCD
         AND EP.EP_REVIEW_STATUS    = 'CO'
         AND (EP.EP_APPROVAL_STATUS = 'APRV' OR EP.EP_APPROVAL_STATUS = 'NREQ')
         AND EP.EP_REVIEW_TYPE = RC.EP_REVIEW_TYPE
         AND EP.PERIOD_END_DT       = (SELECT MAX(EP1.PERIOD_END_DT)
                                         FROM PS_EP_APPR EP1
                                        WHERE EP1.EMPLID              = A1.EMPLID
                                          AND EP1.EMPL_RCD            = A1.EMPL_RCD
                                          AND EP1.EP_REVIEW_STATUS    = 'CO'
                                          AND (EP1.EP_APPROVAL_STATUS = 'APRV' OR EP1.EP_APPROVAL_STATUS = 'NREQ')
                                          AND EP1.EP_REVIEW_TYPE = RC.EP_REVIEW_TYPE
                                          AND EP1.PERIOD_END_DT <= {DateIn-Prefix}$New_Job_Effdt{DateIn-suffix})
         AND EP.EP_CALC_METHOD = 'A'
         AND EP.RATING_MODEL   = RC.RATING_MODEL
         AND EP.REVIEW_RATING  = RC.REVIEW_RATING)

  AND A1.COMP_FREQUENCY   = F1.FREQUENCY_ID
  AND F1.EFF_STATUS       = 'A'
  AND F1.EFFDT            =
    (SELECT MAX(F11.EFFDT)
       FROM PS_FREQUENCY_TBL F11
      WHERE F11.FREQUENCY_ID   = F1.FREQUENCY_ID
        AND F11.EFFDT         <= A1.EFFDT)

end-SELECT
end-procedure

!***********************************************************************
begin-procedure Check-Future-Job-NoReset
!***********************************************************************

#DEBUGY display 'check-future-job-noReset'
#DEBUGY display 'Prev_Effdt:' NOLINE
#DEBUGY display $Prev_Effdt
#DEBUGY display 'New_EffDt: ' NOLINE
#DEBUGY display $New_EffDt
!IF $New_EffDt = '1994-09-23'
!LET $New_EffDt = '1996-08-23'
!END-IF
  let $FutureJob = 'N'
  !Set the flag to provide more information on the report
  let $FutureJob_Error = 'N'

begin-SELECT
A2.EMPLID
A2.EMPL_RCD
{DateOut-Prefix}A2.EFFDT{DateOut-Suffix}      &A2.EFFDT
A2.EFFSEQ
A2.DEPTID
A2.JOBCODE
A2.POSITION_NBR
A2.APPT_TYPE
A2.MAIN_APPT_NUM_JPN
A2.POSITION_OVERRIDE
A2.POSN_CHANGE_RECORD
A2.EMPL_STATUS
A2.ACTION
A2.ACTION_DT
A2.ACTION_REASON
A2.LOCATION
A2.TAX_LOCATION_CD
{DateOut-Prefix}A2.JOB_ENTRY_DT{DateOut-Suffix}      &A2.JOB_ENTRY_DT
{DateOut-Prefix}A2.DEPT_ENTRY_DT{DateOut-Suffix}      &A2.DEPT_ENTRY_DT
{DateOut-Prefix}A2.POSITION_ENTRY_DT{DateOut-Suffix}   &A2.POSITION_ENTRY_DT
A2.SHIFT
A2.REG_TEMP
A2.FULL_PART_TIME
A2.COMPANY
A2.PAYGROUP
A2.BAS_GROUP_ID
A2.ELIG_CONFIG1
A2.ELIG_CONFIG2
A2.ELIG_CONFIG3
A2.ELIG_CONFIG4
A2.ELIG_CONFIG5
A2.ELIG_CONFIG6
A2.ELIG_CONFIG7
A2.ELIG_CONFIG8
A2.ELIG_CONFIG9
A2.BEN_STATUS
A2.BAS_ACTION
A2.COBRA_ACTION
A2.EMPL_TYPE
A2.HOLIDAY_SCHEDULE
A2.STD_HOURS
A2.STD_HRS_FREQUENCY
A2.OFFICER_CD
A2.EMPL_CLASS
A2.SAL_ADMIN_PLAN
A2.GRADE
{DateOut-Prefix}A2.GRADE_ENTRY_DT{DateOut-Suffix}    &A2.GRADE_ENTRY_DT
A2.STEP
{DateOut-Prefix}A2.STEP_ENTRY_DT{DateOut-Suffix}      &A2.STEP_ENTRY_DT
A2.GL_PAY_TYPE
A2.ACCT_CD
A2.EARNS_DIST_TYPE
A2.COMP_FREQUENCY
A2.COMPRATE
A2.CHANGE_AMT
A2.CHANGE_PCT
A2.ANNUAL_RT
A2.MONTHLY_RT
A2.DAILY_RT
A2.HOURLY_RT
A2.ANNL_BENEF_BASE_RT
A2.SHIFT_RT
A2.SHIFT_FACTOR
A2.CURRENCY_CD
A2.BUSINESS_UNIT
A2.SETID_DEPT
A2.SETID_JOBCODE
A2.SETID_LOCATION
A2.SETID_SALARY
A2.REG_REGION
A2.DIRECTLY_TIPPED
A2.FLSA_STATUS
A2.EEO_CLASS
A2.FUNCTION_CD
A2.TARIFF_GER
A2.TARIFF_AREA_GER
A2.PERFORM_GROUP_GER
A2.LABOR_TYPE_GER
A2.SPK_COMM_ID_GER
A2.HOURLY_RT_FRA
A2.ACCDNT_CD_FRA
A2.VALUE_1_FRA
A2.VALUE_2_FRA
A2.VALUE_3_FRA
A2.VALUE_4_FRA
A2.VALUE_5_FRA
A2.CTG_RATE
A2.PAID_HOURS
A2.PAID_FTE
A2.PAID_HRS_FREQUENCY
A2.UNION_FULL_PART
A2.UNION_POS
A2.MATRICULA_NBR
A2.SOC_SEC_RISK_CODE
A2.UNION_FEE_AMOUNT
{DateOut-Prefix}A2.UNION_FEE_START_DT{DateOut-Suffix}     &A2.UNION_FEE_START_DT
{DateOut-Prefix}A2.UNION_FEE_END_DT{DateOut-Suffix}       &A2.UNION_FEE_END_DT
A2.EXEMPT_JOB_LBR
A2.EXEMPT_HOURS_MONTH
A2.WRKS_CNCL_FUNCTION
A2.INTERCTR_WRKS_CNCL
A2.CURRENCY_CD1
A2.PAY_UNION_FEE
A2.UNION_CD
A2.BARG_UNIT
{DateOut-Prefix}A2.UNION_SENIORITY_DT{DateOut-Suffix}     &A2.UNION_SENIORITY_DT
{DateOut-Prefix}A2.ENTRY_DATE{DateOut-Suffix}             &A2.ENTRY_DATE
A2.LABOR_AGREEMENT
A2.EMPL_CTG
A2.EMPL_CTG_L1
A2.EMPL_CTG_L2
A2.SETID_LBR_AGRMNT
A2.GP_PAYGROUP
A2.GP_DFLT_ELIG_GRP
A2.GP_ELIG_GRP
A2.GP_DFLT_CURRTTYP
A2.CUR_RT_TYPE
A2.GP_DFLT_EXRTDT
A2.GP_ASOF_DT_EXG_RT
A2.ADDS_TO_FTE_ACTUAL
A2.CLASS_INDC
A2.ENCUMB_OVERRIDE
A2.FICA_STATUS_EE
A2.FTE
A2.PRORATE_CNT_AMT
A2.PAY_SYSTEM_FLG
A2.BORDER_WALKER
A2.LUMP_SUM_PAY
A2.CONTRACT_NUM
A2.JOB_INDICATOR
A2.WRKS_CNCL_ROLE_CHE
A2.BENEFIT_SYSTEM
A2.WORK_DAY_HOURS
A2.SUPERVISOR_ID
A2.REPORTS_TO
{DateOut-Prefix}A2.FORCE_PUBLISH{DateOut-Suffix}          &A2.FORCE_PUBLISH
A2.JOB_DATA_SRC_CD
A2.ESTABID
B2.NAME
P2.COUNTRY
F2.FREQUENCY_TYPE


      #debugy display 'inside check future no reset'

      let  #FutureJobStep = &A2.Step
      #debugy display 'FutureJobStep: ' noline
      #debugy display #FutureJobStep
      #debugy display 'JobStep: ' noline
      #debugy display #JobStep
      #debugy display 'New_Step_F: ' noline
      #debugy display #New_Step_F
      #debugy display 'Employee effdt: ' noline
      #debugy display &A2.EFFDT


   !  let $grade_step_found = 'N'
   !  Evaluate &A2.GRADE

   !    when = &A.Grade
   !   #debugy display 'inside check future no reset - evaluate = A.Grade'
   !      if #FutureJobStep <> #JobStep
   !        let $Future = 'Y'
   !        let $Step_Found_F ='N'
   !        let $Comp_flag = 'N'
   !        do Find-Step
   !        let #NewJobStep = #New_Step_F

   !        if ($Step_Found_F = 'Y' and #FutureJobStep <> #Max_Step_F)
   !          let $FutureJob = 'Y'
   !        else
   !          let $FutureJob_Error = 'Y'
   !        end-if
   !      else
   !        let $FutureJob = 'Y'
   !   #debugy display 'inside check future no reset - evaluate = A.Grade and inside else statement'

   !      end-if
   !      if $FutureJob = 'Y'
   !          let $grade_step_found = 'Y'
   !      end-if
   !      break

   !    when-Other

   !   #debugy display 'inside check future no reset - evaluate = other'

   !      if &A2.Grade <> $New_Grade
           do Check-Different-Grade
   !      end-if

      #debugy display 'FutureJobStep after check-different-grade ' noline
      #debugy display #FutureJobStep

         let $Step_Found_F ='N'
         do Find-Future-Job-Step
         let #NewJobStep = #New_Step_F
         if ($Step_Found_F = 'Y' and #FutureJobStep <> #Max_Step_F)
           let $FutureJob = 'Y'
         else
           let $FutureJob_Error = 'Y'
         end-if

    ! End-Evaluate


     if $FutureJob = 'Y' and $FutureJob_Error = 'N'


       move 'Y' to $Base_Only_Sw

       do GET-BASE-COMPENSATION-F

      let #Adj_Hourly_Rt_F  = #Job_Hourly_Rt_F                                  !PUBSEC
      let #Adj_Daily_Rt_F   = #Job_Daily_Rt_F                                   !PUBSEC
      let #Adj_Monthly_Rt_F = #Job_Monthly_Rt_F                                 !PUBSEC
      let #Adj_Annual_Rt_F  = #Job_Annual_Rt_F                                  !PUBSEC

      move &A2.Position_Entry_Dt to $Pos_Entry_Dt_F

       !Only process employees who are within the range of the Hourly rate or
       !within the range of either Monthly or Annual Rate, of their current step.
       !Only check for the first Step Increment

      ! if &A2.FTE = 0 or &A2.FTE = 1
      !   let #Calc-monthly_rt = &A2.Monthly_Rt
      !   let #Calc-annual_rt  = &A2.Annual_Rt
      ! else
      !   let #Calc-monthly_rt = &A2.Monthly_Rt / &A2.FTE
      !   let #Calc-annual_rt  = &A2.Annual_Rt  / &A2.FTE
      ! end-if

       #DEBUGY display 'check-future-job-noreset/ low high rates '
       #DEBUGY display #Low_Hr_Rt_F
       #DEBUGY display #High_Hr_Rt_F
       #DEBUGY display #Low_Mn_Rt_F
       #DEBUGY display #High_Mn_Rt_F
       #DEBUGY display #Low_An_Rt_F
       #DEBUGY display #High_An_Rt_F

       #DEBUGY display 'check-future-job-noreset/ Adjusted rates '

       #DEBUGY display #Adj_Hourly_Rt_F
       #DEBUGY display #Adj_Daily_Rt_F
       #DEBUGY display #Adj_Monthly_Rt_F
       #DEBUGY display #Adj_Annual_Rt_F

       !if (&A2.Hourly_Rt >= #Low_Hr_Rt_F and &A2.Hourly_Rt <= #High_Hr_Rt_F)
       !  or (#Calc-monthly_rt >= #Low_Mn_Rt_F and #Calc-monthly_rt <= #High_Mn_Rt_F)
       !    or (#Calc-annual_rt >= #Low_An_Rt_F and #Calc-annual_rt <= #High_An_Rt_F)

       if (#Adj_Hourly_Rt_F  >= #Low_Hr_Rt_F and #Adj_Hourly_Rt_F  <= #High_Hr_Rt_F)    !PUBSEC
             or (#Adj_Daily_Rt_F   >= #Low_Dy_Rt_F and #Adj_Daily_Rt_F   <= #High_Dy_Rt_F)    !PUBSEC
             or (#Adj_Monthly_Rt_F >= #Low_Mn_Rt_F and #Adj_Monthly_Rt_F <= #High_Mn_Rt_F)    !PUBSEC
             or (#Adj_Annual_Rt_F  >= #Low_An_Rt_F and #Adj_Annual_Rt_F  <= #High_An_Rt_F)    !PUBSEC

     #DEBUGY DISPLAY 'there is a future job - :)'
       else
         let $FutureJob = 'N'
         let $FutureJob_Error = 'Y'
       end-if
     end-if
     #DEBUGY DISPLAY 'future job and error: ' noline
     #DEBUGY DISPLAY $FutureJob noline
     #DEBUGY DISPLAY ' - ' noline
     #DEBUGY DISPLAY $FutureJob_Error


     if $FutureJob = 'Y' and $FutureJob_Error = 'N'
     #DEBUGY DISPLAY 'Save-Future-Job-Fields'
       do Save-Future-Job-Fields
       let $New_Grade = rtrim(&A2.GRADE,' ')
     end-if


FROM PS_JOB            A2,
     PS_PERSONAL_DATA  B2,
     PS_PAYGROUP_TBL   P2,
     PS_FREQUENCY_TBL  F2

WHERE A2.EMPLID = &A.EMPLID
  AND A2.EMPL_RCD = &A.EMPL_RCD
  AND A2.SAL_ADMIN_PLAN = $SalPlan
  AND A2.EFFDT  =   (SELECT MAX(C2.EFFDT)
                       FROM PS_BP_JOB C2
                      WHERE C2.EMPLID    = A2.EMPLID
                        AND C2.EMPL_RCD = A2.EMPL_RCD
                        AND C2.EFFDT    <= {DateIn-Prefix}$New_EffDt{DateIn-suffix})
  AND A2.EFFSEQ = (SELECT MAX(D2.EFFSEQ)
                         FROM PS_BP_JOB D2
                        WHERE D2.EMPLID    = A2.EMPLID
                          AND D2.EMPL_RCD = A2.EMPL_RCD
                          AND D2.EFFDT     = A2.EFFDT)
 !AND A2.EFFDT <> {DateIn-Prefix}&A.EFFDT{DateIn-suffix}
  AND A2.EFFDT > {DateIn-Prefix}$Prev_Effdt{DateIn-suffix}
  AND A2.EMPL_STATUS NOT IN ('D', 'R', 'T')
  AND A2.STEP    <> 0
  AND A2.EMPLID    = B2.EMPLID
  AND A2.PAYGROUP  = P2.PAYGROUP
  AND A2.COMPANY   = P2.COMPANY
  AND P2.EFFDT     = (SELECT MAX(PP2.EFFDT)
                       FROM PS_PAYGROUP_TBL PP2
                      WHERE PP2.COMPANY   = P2.COMPANY
                        AND PP2.PAYGROUP  = P2.PAYGROUP
                        AND PP2.EFFDT    <= {DateIn-Prefix}$New_EffDt{DateIn-suffix})
  AND EXISTS
        (SELECT 'X'
         FROM PS_BP_RNCTL_CMP107 BPCMP107
         WHERE BPCMP107.OPRID         = $prcs_oprid
           AND BPCMP107.RUN_CNTL_ID   = $prcs_run_cntl_id
           AND BPCMP107.ACTION        = A2.ACTION
           AND BPCMP107.ACTION_REASON = A2.ACTION_REASON)

  AND NOT EXISTS
        (SELECT 'X'
       FROM PS_RUN_CNTL_CMP107 RC,
            PS_EP_APPR EP
       WHERE RC.OPRID          = $prcs_oprid
         AND RC.RUN_CNTL_ID    = $prcs_run_cntl_id
         AND EP.EMPLID              = A2.EMPLID
         AND EP.EMPL_RCD            = A2.EMPL_RCD
         AND EP.EP_REVIEW_STATUS    = 'CO'
         AND (EP.EP_APPROVAL_STATUS = 'APRV' OR EP.EP_APPROVAL_STATUS = 'NREQ')
         AND EP.EP_REVIEW_TYPE = RC.EP_REVIEW_TYPE
         AND EP.PERIOD_END_DT       = (SELECT MAX(EP1.PERIOD_END_DT)
                                         FROM PS_EP_APPR EP1
                                        WHERE EP1.EMPLID              = A2.EMPLID
                                          AND EP1.EMPL_RCD            = A2.EMPL_RCD
                                          AND EP1.EP_REVIEW_STATUS    = 'CO'
                                          AND (EP1.EP_APPROVAL_STATUS = 'APRV' OR EP1.EP_APPROVAL_STATUS = 'NREQ')
                                          AND EP1.EP_REVIEW_TYPE = RC.EP_REVIEW_TYPE
                                          AND EP1.PERIOD_END_DT <= $New_Job_Effdt)
         AND EP.EP_CALC_METHOD = 'A'
         AND EP.RATING_MODEL   = RC.RATING_MODEL
         AND EP.REVIEW_RATING  = RC.REVIEW_RATING)

  AND A2.COMP_FREQUENCY   = F2.FREQUENCY_ID
  AND F2.EFF_STATUS       = 'A'
  AND F2.EFFDT            =
    (SELECT MAX(F21.EFFDT)
       FROM PS_FREQUENCY_TBL F21
      WHERE F21.FREQUENCY_ID   = F2.FREQUENCY_ID
        AND F21.EFF_STATUS     = F2.EFF_STATUS
        AND F21.EFFDT         <= A2.EFFDT)


end-SELECT
end-procedure




!***********************************************************************
begin-procedure Write-Report
!***********************************************************************

#DEBUGY display 'write-report for: ' NOLINE
#DEBUGY display &A.EMPLID

  if $PrevGrade <> &A.Grade
    print ' '                          (+1,1)
  end-if

  if ($PrevEmpId <> &A.EMPLID) or ($Preveffectdt <> &A.EFFDT)
    print &A.EmplID                    (+1,1)
    print &B.Name                      (0,11,26)
    print &A.Empl_Status               (0,39)                     !PUBSEC
    print &A.Sal_Admin_Plan            (0,41)
    print &A.Grade                     (0,46)
    do Format-DateTime(&A.EFFDT, $out, {DEFDATE}, '', '')
    print $out                         (0,53,10)
    do Format-Number(&A.Step, $out, '99')
    print $out                         (0,65)
    do Format-Number(&A.COMPRATE, $out, '9,999,999,999.999999')   !PUBSEC
    print $out                         (0,69)
    print '/'                          (0,89)                     !PUBSEC
    print &A.Comp_Frequency            (0,90)                     !PUBSEC

    let $PrevEmpId = &A.EMPLID
    let $PrevGrade = &A.Grade
    let $Preveffectdt  = &A.EFFDT

  else
    print ' '                          (+1,1)
  end-if

  if $Error-Msg = ' '
    do Format-DateTime($New_EffDt, $out, {DEFDATE}, '', '')
    print $out                       (0,93,10)
    do Format-Number(#NewJobStep, $out, '99')
    print $out                       (0,105)
    print $New_Grade                 (0,108)
    do Format-Number(#New_Comprate, $out, '9,999,999,999.999999') !PUBSEC
    print $out                       (0,111)
    print '/'                        (0,131)
    print &A.COMP_FREQUENCY          (0,132)
  else
    print $Error-Msg                 (0,136,38)                    !PUBSEC
  end-if

  let $Error-Msg = ' '
end-procedure

!**************************************************************************
Begin-Procedure Check-Different-Grade
!**************************************************************************

#DEBUGY display 'check-different-grade: ' NOLINE
#DEBUGY display &A2.GRADE


begin-SELECT
Z1.SAL_ADMIN_PLAN
Z1.GRADE
Z1.EFFDT
Z1.STEP_INCREM_TYPE
Z1.STEP_INCREM_ACCUM

  let $Step_Increm_Accum = rtrim(&Z1.STEP_INCREM_ACCUM,' ')
  let $Step_Increm_type = rtrim(&Z1.STEP_INCREM_TYPE,' ')

  do Get-Future-Job-Steps


FROM  PS_SAL_GRADE_TBL Z1
WHERE Z1.SETID = $SET
 AND Z1.SAL_ADMIN_PLAN = $SalPlan
 AND Z1.GRADE = &A2.GRADE
 AND Z1.EFFDT = (SELECT MAX(Z2.EFFDT)
                FROM PS_SAL_GRADE_TBL Z2
               WHERE Z2.SETID          = Z1.SETID
                 AND Z2.SAL_ADMIN_PLAN = Z1.SAL_ADMIN_PLAN
                 AND Z2.GRADE          = Z1.GRADE
                 AND Z2.EFFDT          < &A2.EFFDT)

  AND Z1.STEP_INCREM_TYPE = &Z.Step_Increm_Type
ORDER BY Z1.GRADE

end-SELECT
end-procedure

!**************************************************************************
Begin-Procedure Get-Future-Job-Steps
!**************************************************************************

  move 0 to #idx2
  move 0 to #SC2_idx


begin-SELECT
Y1.STEP
Y1.HOURLY_RT
Y1.DAILY_RT
Y1.MONTHLY_RT
Y1.ANNUAL_RT
Y1.INCREM_MONTHS
Y1.INCREM_HOURS
Y1.CURRENCY_CD

  if #idx2 < 29
    PUT &Y1.Step          INTO STEPDATA2(#IDX2) STEP
    PUT &Y1.Hourly_Rt     INTO STEPDATA2(#IDX2) hourly_rt
    PUT &Y1.DAILY_RT      INTO STEPDATA2(#IDX2) daily_rt
    PUT &Y1.Monthly_Rt    INTO STEPDATA2(#IDX2) monthly_rt
    PUT &Y1.Annual_Rt     INTO STEPDATA2(#IDX2) annual_rt
    PUT &Y1.Increm_Months INTO STEPDATA2(#IDX2) increm_months
    PUT &Y1.Increm_Hours  INTO STEPDATA2(#IDX2) increm_hours
    PUT &Y1.CURRENCY_CD   INTO STEPDATA2(#IDX2) currency_cd

  #DEBUGY display 'inside get-future-job-step'

  !if #idx2 = 0
  !  let #FutureJobStep = &Y1.Step
  !#DEBUGY display '#FutureJobStep' noline
  !#DEBUGY display #FutureJobStep
  !end-if

    do GET-COMPONENTS-F

  #DEBUGY display #idx2
  #DEBUGY display #save_comp_begin_F
  #DEBUGY display #save_comp_end_F

    put #save_comp_begin_F INTO STEPDATA2(#IDX2) comp_begin_idx
    put #save_comp_end_F   INTO STEPDATA2(#IDX2) comp_end_idx

    add 1 to #idx2
  else
    display '*** Array overflow; limited to 15 steps. ***'
  end-if

  let #Max_Step_F = &Y1.Step

FROM  PS_SAL_STEP_TBL Y1
WHERE Y1.SETID          = $SET                         !PUBSEC
AND   Y1.SAL_ADMIN_PLAN = &Z1.Sal_Admin_Plan
AND   Y1.GRADE          = &Z1.Grade
AND   Y1.EFFDT          = &Z1.EffDt
!AND   Y1.STEP           > #FutureJobStep

ORDER BY Y1.STEP ASC
end-SELECT

#DEBUGY display 'end of get-future-job-step '
#DEBUGY display 'max step: ' NOLINE
#DEBUGY display #Max_Step_F

end-procedure

!***********************************************************************
! Procedure: GET-COMPONENTS-F                                            *
! DeSC2r:     Reads application table for all pay components which      *
!            comprise the current pay step for the employee.  Reads    *
!            database table PS_SAL_RATECD_TBL.                         *
!                                                                      *
! Called by:                                                 *
!***********************************************************************
begin-procedure GET-COMPONENTS-F

#DEBUGY display 'entering get-components-f'

   move 'Y' to $First_Pass_Sw

begin-SELECT
SC2.COMP_EFFSEQ
SC2.COMP_RATECD
SC2.CURRENCY_CD
SC2.COMP_FREQUENCY
SC2.HOURLY_RT
SC2.MONTHLY_RT
SC2.ANNUAL_RT
SC2.COMP_RATE_POINTS
SC2.COMP_PCT
SC2.RATE_CODE_GROUP
SC2.COMPRATE
SC2.DAILY_RT
RC2.COMP_RATE_TYPE
RC2.COMP_BASE_PAY_SW

  if #SC2_idx < 150

      if $First_Pass_Sw ='Y'
         move #SC2_idx to #save_comp_begin_F
         move 'N' to $First_Pass_Sw
      end-if

      put &SC2.COMP_EFFSEQ      INTO stepcomp2(#SC2_idx) SC_Comp_Effseq
      put &SC2.COMP_RATECD      INTO stepcomp2(#SC2_idx) SC_Comp_Ratecd
      put &SC2.CURRENCY_CD      INTO stepcomp2(#SC2_idx) SC_Currency_cd
      put &SC2.COMP_FREQUENCY   INTO stepcomp2(#SC2_idx) SC_Comp_Frequency
      put &SC2.HOURLY_RT        INTO stepcomp2(#SC2_idx) SC_Hourly_Rt
      put &SC2.MONTHLY_RT       INTO stepcomp2(#SC2_idx) SC_Monthly_Rt
      put &SC2.ANNUAL_RT        INTO stepcomp2(#SC2_idx) SC_Annual_Rt
      put &SC2.COMP_RATE_POINTS INTO stepcomp2(#SC2_idx) SC_Comp_Rate_Points
      put &SC2.COMP_PCT         INTO stepcomp2(#SC2_idx) SC_Comp_Pct
      put &SC2.RATE_CODE_GROUP  INTO stepcomp2(#SC2_idx) SC_Rate_Code_Group
      put &SC2.COMPRATE         INTO stepcomp2(#SC2_idx) SC_Comprate
      put &SC2.DAILY_RT         INTO stepcomp2(#SC2_idx) SC_Daily_Rt
      put &RC2.COMP_RATE_TYPE   INTO stepcomp2(#SC2_idx) RC_comp_rate_type
      put &RC2.COMP_BASE_PAY_SW INTO stepcomp2(#SC2_idx) RC_comp_base_pay_sw


    #DEBUGY display 'inside get-components-f'
    #DEBUGY display #SC2_idx
    #DEBUGY display &SC2.COMPRATE
    #DEBUGY display #save_comp_begin_F

      move #SC2_idx to #save_comp_end_F

    #DEBUGY display #save_comp_end_F

      add 1 to #SC2_idx
   else
 !       display $CMP107_OVERFLOW1                                      !F-LPARKER-125 (CAMI)
 !       display $CMP107_OVERFLOW2                                      !F-LPARKER-125 (CAMI)
 !      display '*** Array overflow; limited to 150 compensation ratecodes ***'
 !      display '***    for a single salary grade.                         ***'
   end-if

FROM  PS_SAL_RATECD_TBL SC2
    , PS_COMP_RATECD_TBL RC2
WHERE SC2.SETID          = $SET                         !PUBSEC
AND   SC2.SAL_ADMIN_PLAN = &Z1.SAL_ADMIN_PLAN
AND   SC2.GRADE          = &Z1.GRADE
AND   SC2.EFFDT          = &Z1.EFFDT
AND   SC2.STEP           = &Y1.STEP
AND   RC2.COMP_RATECD    = SC2.COMP_RATECD
AND   RC2.EFFDT          = (SELECT MAX (EFFDT)
                             FROM PS_COMP_RATECD_TBL RC21
                             WHERE RC21.COMP_RATECD = SC2.COMP_RATECD AND
                             EFFDT <= &Z1.EFFDT)
ORDER BY SC2.COMP_EFFSEQ DESC, SC2.COMP_RATECD ASC
end-SELECT

   if $First_Pass_sw = 'Y'
      move 1 to #save_comp_begin_F
      move 0 to #save_comp_end_F
   end-if

#DEBUGY display 'exiting get-components-f'

end-procedure !GET-COMPONENTS-F
!***********************************************************************
! Procedure: GET-BASE-COMPENSATION-F                                     *
!***********************************************************************
begin-procedure GET-BASE-COMPENSATION-F

#DEBUGY display 'entering get-base-compensation-f'

   move 'Y' to $Base_Comps_Only

   move 0.00 to #Job_Comprate_F
   move 0.00 to #Job_Annual_Rt_F
   move 0.00 to #Job_Monthly_Rt_F
   move 0.00 to #Job_Daily_Rt_F
   move 0.00 to #Job_Hourly_Rt_F

   move 0 to #cp2_idx
   move 0 to #cp2_cnt

begin-SELECT
CP2.EFFSEQ
CP2.COMP_EFFSEQ
CP2.COMP_RATECD
CP2.COMP_RATE_POINTS
CP2.COMPRATE
CP2.COMP_PCT
CP2.COMP_FREQUENCY
CP2.CURRENCY_CD
CP2.MANUAL_SW
CP2.CONVERT_COMPRT
CP2.RATE_CODE_GROUP
CP2.FTE_INDICATOR
CP2.CMP_SRC_IND
CR2.RATE_CODE_CLASS


   add 1 to #cp2_idx
   put &CP2.EFFSEQ            into CompArray2 (#cp2_idx) cp_effseq
   put &CP2.COMP_EFFSEQ       into CompArray2 (#cp2_idx) cp_comp_effseq
   put &CP2.COMP_RATECD       into CompArray2 (#cp2_idx) cp_comp_ratecd
   put &CP2.COMP_RATE_POINTS  into CompArray2 (#cp2_idx) cp_comp_rate_points
   put &CP2.COMPRATE          into CompArray2 (#cp2_idx) cp_comprate

   put &CP2.COMP_PCT          into CompArray2 (#cp2_idx) cp_comp_pct
   put &CP2.COMP_FREQUENCY    into CompArray2 (#cp2_idx) cp_comp_frequency
   put &CP2.CURRENCY_CD       into CompArray2 (#cp2_idx) cp_currency_cd
   put &CP2.MANUAL_SW         into CompArray2 (#cp2_idx) cp_manual_sw
   put &CP2.CONVERT_COMPRT    into CompArray2 (#cp2_idx) cp_convert_comprt
   put &CP2.RATE_CODE_GROUP   into CompArray2 (#cp2_idx) cp_rate_code_group
   put &CP2.FTE_INDICATOR     into CompArray2 (#cp2_idx) cp_fte_indicator
   put &CP2.CMP_SRC_IND       into CompArray2 (#cp2_idx) cp_cmp_src_ind
   put &CR2.RATE_CODE_CLASS   into CompArray2 (#cp2_idx) cp_rate_code_class

   #DEBUGY display 'inside get-base-compensation-f'
   #DEBUGY display #cp2_idx
   #DEBUGY display 'MANUAL_SW: ' noline
   #DEBUGY display &CP2.MANUAL_SW
   #DEBUGY display 'COMPRATE : ' noline
   #DEBUGY display &CP2.COMPRATE

   if &CR2.Rate_Code_Class = 'SENPAY' ! or &CR2.Rate_Code_Class = 'EDUPAY'  or  &CR2.Rate_Code_Class = 'GRPPAY'
      or &CP2.Manual_Sw = 'Y'

      move 'N' to $Base_Comps_Only

      !***** This message is really useful if you do not know why people are not qualifying for increase
      !let $error-msg = &CR2.Rate_Code_Class || ' bypassed in Base Compensation'
      !do write-report
      !let $error_msg = ' '

      if $Base_Only_Sw <> 'Y'

         do CONVERT-OLD-COMPONENT-COMPRATE-F
         add #Exc_Comprate_F   to #Job_Comprate_F
         add #Exc_Annual_Rt_F  to #Job_Annual_Rt_F
         add #Exc_Monthly_Rt_F to #Job_Monthly_Rt_F
         add #Exc_Daily_Rt_F   to #Job_Daily_Rt_F
         add #Exc_Hourly_Rt_F  to #Job_Hourly_Rt_F

      end-if
   else

      do CONVERT-OLD-COMPONENT-COMPRATE-F
      add #Exc_Comprate_F   to #Job_Comprate_F
      add #Exc_Annual_Rt_F  to #Job_Annual_Rt_F
      add #Exc_Monthly_Rt_F to #Job_Monthly_Rt_F
      add #Exc_Daily_Rt_F   to #Job_Daily_Rt_F
      add #Exc_Hourly_Rt_F  to #Job_Hourly_Rt_F

   end-if

FROM PS_BP_COMPENSATION CP2
   , PS_COMP_RATECD_TBL CR2
WHERE CP2.EMPLID      = &A2.EMPLID
  AND CP2.EMPL_RCD    = &A2.EMPL_RCD
  AND CP2.EFFDT       = &A2.EFFDT
  AND CP2.EFFSEQ      = &A2.EFFSEQ
  AND CP2.COMP_RATECD = CR2.COMP_RATECD
  AND CR2.EFF_STATUS  = 'A'
  AND CR2.EFFDT       = (SELECT MAX(CR21.EFFDT)
                          FROM PS_COMP_RATECD_TBL CR21
                         WHERE CR21.COMP_RATECD = CP2.COMP_RATECD
                           AND CR21.EFFDT      <= &A2.EFFDT)
end-SELECT

   move #cp2_idx to #cp2_cnt

    #debugy display 'cp2_cnt: ' noline
    #debugy display #cp2_cnt
    #DEBUGY display 'exiting get-base-compensation-f'

end-procedure GET-BASE-COMPENSATION-F

!***********************************************************************
! Procedure: GET-BASE-COMPENSATION-F1                                     *
!***********************************************************************
begin-procedure GET-BASE-COMPENSATION-F1

#DEBUGY display 'entering get-base-compensation-f1'

   move 'Y' to $Base_Comps_Only

   move 0.00 to #Job_Comprate_F
   move 0.00 to #Job_Annual_Rt_F
   move 0.00 to #Job_Monthly_Rt_F
   move 0.00 to #Job_Daily_Rt_F
   move 0.00 to #Job_Hourly_Rt_F

   move 0 to #cp2_idx
   move 0 to #cp2_cnt

begin-SELECT
CP21.EFFSEQ
CP21.COMP_EFFSEQ
CP21.COMP_RATECD
CP21.COMP_RATE_POINTS
CP21.COMPRATE
CP21.COMP_PCT
CP21.COMP_FREQUENCY
CP21.CURRENCY_CD
CP21.MANUAL_SW
CP21.CONVERT_COMPRT
CP21.RATE_CODE_GROUP
CP21.FTE_INDICATOR
CP21.CMP_SRC_IND
CR21.RATE_CODE_CLASS


   add 1 to #cp2_idx
   put &CP21.EFFSEQ            into CompArray2 (#cp2_idx) cp_effseq
   put &CP21.COMP_EFFSEQ       into CompArray2 (#cp2_idx) cp_comp_effseq
   put &CP21.COMP_RATECD       into CompArray2 (#cp2_idx) cp_comp_ratecd
   put &CP21.COMP_RATE_POINTS  into CompArray2 (#cp2_idx) cp_comp_rate_points
   put &CP21.COMPRATE          into CompArray2 (#cp2_idx) cp_comprate

   put &CP21.COMP_PCT          into CompArray2 (#cp2_idx) cp_comp_pct
   put &CP21.COMP_FREQUENCY    into CompArray2 (#cp2_idx) cp_comp_frequency
   put &CP21.CURRENCY_CD       into CompArray2 (#cp2_idx) cp_currency_cd
   put &CP21.MANUAL_SW         into CompArray2 (#cp2_idx) cp_manual_sw
   put &CP21.CONVERT_COMPRT    into CompArray2 (#cp2_idx) cp_convert_comprt
   put &CP21.RATE_CODE_GROUP   into CompArray2 (#cp2_idx) cp_rate_code_group
   put &CP21.FTE_INDICATOR     into CompArray2 (#cp2_idx) cp_fte_indicator
   put &CP21.CMP_SRC_IND       into CompArray2 (#cp2_idx) cp_cmp_src_ind
   put &CR21.RATE_CODE_CLASS   into CompArray2 (#cp2_idx) cp_rate_code_class


   #DEBUGY display 'inside get-base-compensation-f1'
   #DEBUGY display #cp2_idx
   #DEBUGY display 'MANUAL_SW: ' noline
   #DEBUGY display &CP21.MANUAL_SW
   #DEBUGY display 'COMPRATE-F1 : ' noline
   #DEBUGY display &CP21.COMPRATE

   if &CR21.Rate_Code_Class = 'SENPAY' ! or &CR21.Rate_Code_Class = 'EDUPAY'  or  &CR21.Rate_Code_Class = 'GRPPAY'
      or &CP21.Manual_Sw = 'Y'

      move 'N' to $Base_Comps_Only

      !***** This message is really useful if you do not know why people are not qualifying for increase
      !let $error-msg = &CR2.Rate_Code_Class || ' bypassed in Base Compensation'
      !do write-report
      !let $error_msg = ' '

      if $Base_Only_Sw <> 'Y'

         do CONVERT-OLD-COMPONENT-COMPRATE-F1
         add #Exc_Comprate_F   to #Job_Comprate_F
         add #Exc_Annual_Rt_F  to #Job_Annual_Rt_F
         add #Exc_Monthly_Rt_F to #Job_Monthly_Rt_F
         add #Exc_Daily_Rt_F   to #Job_Daily_Rt_F
         add #Exc_Hourly_Rt_F  to #Job_Hourly_Rt_F

      end-if
   else

      do CONVERT-OLD-COMPONENT-COMPRATE-F1
      add #Exc_Comprate_F   to #Job_Comprate_F
      add #Exc_Annual_Rt_F  to #Job_Annual_Rt_F
      add #Exc_Monthly_Rt_F to #Job_Monthly_Rt_F
      add #Exc_Daily_Rt_F   to #Job_Daily_Rt_F
      add #Exc_Hourly_Rt_F  to #Job_Hourly_Rt_F

   end-if

FROM PS_BP_COMPENSATION CP21
   , PS_COMP_RATECD_TBL CR21
WHERE CP21.EMPLID      = $EMPLID
  AND CP21.EMPL_RCD    = #EMPL_RCD
  AND CP21.EFFDT       = $new_JobRec_effdt
  AND CP21.EFFSEQ      = #new_JobRec_effseq
  AND CP21.COMP_RATECD = CR21.COMP_RATECD
  AND CR21.EFF_STATUS  = 'A'
  AND CR21.EFFDT       = (SELECT MAX(CR211.EFFDT)
                          FROM PS_COMP_RATECD_TBL CR211
                         WHERE CR211.COMP_RATECD = CP21.COMP_RATECD
                           AND CR211.EFFDT      <= $new_JobRec_effdt)
end-SELECT

   move #cp2_idx to #cp2_cnt

   #debugy display 'cp2_cnt: ' noline
   #debugy display #cp2_cnt
   #DEBUGY display 'exiting get-base-compensation-f1'

end-procedure GET-BASE-COMPENSATION-F1


!***********************************************************************
! Procedure: CONVERT-OLD-COMPONENT-COMPRATE-F                            *
!***********************************************************************
begin-procedure CONVERT-OLD-COMPONENT-COMPRATE-F

   #DEBUGY display 'entering convert-old-component-comprate-f'

   do CONVERTCURRENCY(&CP2.COMPRATE,&CP2.CURRENCY_CD,$Old_Step_Currency_F,
                      'OFFIC',&A2.EFFDT,#Wrk_Comprate,'W')

   do CONVERT-FREQUENCY(&A2.EFFDT,#Wrk_Comprate,&CP2.COMP_FREQUENCY,'A',
                        &A2.STD_HOURS,&A2.STD_HRS_FREQUENCY,#Exc_Comprate_F)

   if &A2.COMP_FREQUENCY = 'C'
      let $Monthly_Freq_F = ' '
      let $Daily_Freq_F = ' '
      do GET-PAYGROUP-FREQ-CNT(&A2.EMPLID,&A2.EMPL_RCD,&A2.EFFDT,$Monthly_Freq_F,$Daily_Freq_F)
   else
      let $Monthly_Freq_F = 'M'
      let $Daily_Freq_F = 'D'
   end-if

   do DET-ANNUAL-RT(&A2.EFFDT,#Exc_Comprate_F,'A',
                        &A2.STD_HOURS,&A2.STD_HRS_FREQUENCY,#Exc_Annual_Rt_F)

   do DET-MONTHLY-RT(&A2.EFFDT,#Exc_Comprate_F,'A',$Monthly_Freq_F,
                        &A2.STD_HOURS,&A2.STD_HRS_FREQUENCY,#Exc_Monthly_Rt_F)

   do DET-DAILY-RT(&A2.EFFDT,#Exc_Comprate_F,'A',$Daily_Freq_F,
                        &A2.STD_HOURS,&A2.STD_HRS_FREQUENCY,#Exc_daily_rt_F)

   do DET-HOURLY-RT(&A2.EFFDT,#Exc_Comprate_F,'A',
                        &A2.STD_HOURS,&A2.STD_HRS_FREQUENCY,#Exc_Hourly_rt_F)


   !*** Comprate does not reflect FTE
   let #Exc_Comprate_F   = #Exc_Comprate_F
   let #Exc_Annual_Rt_F  = #Exc_Annual_Rt_F
   let #Exc_Monthly_Rt_F = #Exc_Monthly_Rt_F
   let #Exc_Daily_Rt_F   = #Exc_Daily_Rt_F
   let #Exc_Hourly_Rt_F  = #Exc_Hourly_Rt_F


end-procedure !CONVERT-COMPONENT-COMPRATE-F


!***********************************************************************
! Procedure: CONVERT-OLD-COMPONENT-COMPRATE-F1                            *
!***********************************************************************
begin-procedure CONVERT-OLD-COMPONENT-COMPRATE-F1

   #DEBUGY display 'entering convert-old-component-comprate-f1'
#DEBUGY display &CP21.CURRENCY_CD
#DEBUGY display $Old_Step_Currency_F

   do CONVERTCURRENCY(&CP21.COMPRATE,&CP21.CURRENCY_CD,$Old_Step_Currency_F,
                      'OFFIC',$new_JobRec_effdt,#Wrk_Comprate,'W')

   do CONVERT-FREQUENCY($new_JobRec_effdt,#Wrk_Comprate,&CP21.COMP_FREQUENCY,'A',
                        #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_Comprate_F)

   if $COMP_FREQUENCY = 'C'
      let $Monthly_Freq_F = ' '
      let $Daily_Freq_F = ' '
      do GET-PAYGROUP-FREQ-CNT($EMPLID,#EMPL_RCD,$new_JobRec_effdt,$Monthly_Freq_F,$Daily_Freq_F)
   else
      let $Monthly_Freq_F = 'M'
      let $Daily_Freq_F = 'D'
   end-if

   do DET-ANNUAL-RT($new_JobRec_effdt,#Exc_Comprate_F,'A',
                        #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_Annual_Rt_F)

   do DET-MONTHLY-RT($new_JobRec_effdt,#Exc_Comprate_F,'A',$Monthly_Freq_F,
                        #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_Monthly_Rt_F)

   do DET-DAILY-RT($new_JobRec_effdt,#Exc_Comprate_F,'A',$Daily_Freq_F,
                        #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_daily_rt_F)

   do DET-HOURLY-RT($new_JobRec_effdt,#Exc_Comprate_F,'A',
                        #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_Hourly_rt_F)


   !*** Comprate does not reflect FTE
   let #Exc_Comprate_F   = #Exc_Comprate_F
   let #Exc_Annual_Rt_F  = #Exc_Annual_Rt_F
   let #Exc_Monthly_Rt_F = #Exc_Monthly_Rt_F
   let #Exc_Daily_Rt_F   = #Exc_Daily_Rt_F
   let #Exc_Hourly_Rt_F  = #Exc_Hourly_Rt_F


end-procedure !CONVERT-COMPONENT-COMPRATE-F1


!**************************************************************************
begin-procedure Find-Future-Job-Step
!**************************************************************************

  move 0 to #idx2

  while #idx2 <= 29

    get #Step2 from StepData2(#idx2) step

    if #FutureJobStep = #Step2
      let $Step_Found_F = 'Y'
      get #increm_months_F    from StepData2(#idx2) increm_months
      get #increm_hours_F     from StepData2(#idx2) increm_hours
      get #Old_Step_Hr_Rate_F from StepData2(#idx2) hourly_rt       !PUBSEC
      get #Old_Step_Dy_Rate_F from Stepdata2(#idx2) daily_rt          !PUBSEC
      get #Old_Step_Mn_Rate_F from StepData2(#idx2) monthly_rt      !PUBSEC
      get #Old_Step_An_Rate_F from StepData2(#idx2) annual_rt       !PUBSEC
      get $Old_Step_Currency_F  from Stepdata2(#idx2) currency_cd
      get #Old_comp_begin_idx_F from Stepdata2(#idx2) comp_begin_idx
      get #Old_comp_end_idx_F   from Stepdata2(#idx2) comp_end_idx


      let #Low_Hr_Rt_F  = #Old_Step_Hr_Rate_F - .01                 !PUBSEC
      let #High_Hr_Rt_F = #Old_Step_Hr_Rate_F + .01                 !PUBSEC
      let #Low_Dy_Rt_F  = #Old_Step_Dy_Rate_F - .10                        !PUBSEC
      let #High_Dy_Rt_F = #Old_Step_Dy_Rate_F + .10                        !PUBSEC
      let #Low_Mn_Rt_F  = #Old_Step_Mn_Rate_F - 1                   !PUBSEC
      let #High_Mn_Rt_F = #Old_Step_Mn_Rate_F + 1                   !PUBSEC
      let #Low_An_Rt_F  = #Old_Step_An_Rate_F - 1                   !PUBSEC
      let #High_An_Rt_F = #Old_Step_An_Rate_F + 1                   !PUBSEC

      add 1 to #idx2

      get #New_Step_F            from StepData2(#idx2) step
      get #New_Step_hourly_rt_F  from StepData2(#idx2) hourly_rt
      get #New_Step_Dy_rt_F      from Stepdata2(#idx2) daily_rt          !PUBSEC
      get #New_Step_monthly_rt_F from StepData2(#idx2) monthly_rt
      get #New_Step_annual_rt_F  from StepData2(#idx2) annual_rt
      get $New_Step_Currency_F   from Stepdata2(#idx2) currency_cd
      get #New_comp_begin_idx_F    from Stepdata2(#idx2) comp_begin_idx
      get #New_comp_end_idx_F      from Stepdata2(#idx2) comp_end_idx

      break
    end-if
      add 1 to #idx2
    end-while

#DEBUGY display 'find-future-job-step: ' NOLINE
#DEBUGY display #FutureJobStep
#DEBUGY display 'Step_Found_F: '  NOLINE
#DEBUGY display $Step_Found_F
#DEBUGY display 'New_comp_end_idx_F: '  NOLINE
#DEBUGY display #New_comp_end_idx_F
#DEBUGY display 'New_comp_begin_idx_F: '  NOLINE
#DEBUGY display #New_comp_begin_idx_F



end-procedure

!***********************************************************************
! Procedure: Calc-New-Rates-A                                          *
! Descr:     Calculates the new rates and fields for the new JOB       *
!            row that will result from the step increase. This         *
!            procedure only does JOB not the compensations for the     *
!            JOB. The new field values are saved for the actual insert *
!            for the insert of the new JOB row                         *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure Calc-New-Rates-A

#DEBUGY display 'calc-new-rates-a'

  !For current Jobs only

 ! evaluate &A.Comp_Frequency
 !   when = 'H'                      !Hourly
 !     let #New_Comprate  = #New_Step_hourly_rt
 !     let #New_annual_rt = round(#New_Comprate * &A.Std_Hours * 52, 2)
 !     break
 !   when = 'A'                      !Annual
 !     if &A.FTE = 0 or &A.FTE = 1                          !PUBSEC
 !       let #New_Comprate  = #New_Step_annual_rt           !PUBSEC
 !     else                                                 !PUBSEC
 !       let #New_Comprate  = #New_Step_annual_rt * &A.FTE  !PUBSEC
 !     end-if                                               !PUBSEC
 !     let #New_annual_rt = #New_Comprate
 !     break
 !   when = 'D'
 !     if &A.FTE = 0 or &A.FTE = 1                          !PUBSEC
 !       let #New_annual_rt = #New_Step_annual_rt           !PUBSEC
 !     else                                                 !PUBSEC
 !       let #New_annual_rt = #New_Step_annual_rt * &A.FTE  !PUBSEC
 !     end-if                                               !PUBSEC
 !     let #New_Comprate  = round(#New_annual_rt / 365, 2)
 !     break
 !   when = 'W'
 !     if &A.FTE = 0 or &A.FTE = 1                          !PUBSEC
 !       let #New_annual_rt = #New_Step_annual_rt           !PUBSEC
 !     else                                                 !PUBSEC
 !       let #New_annual_rt = #New_Step_annual_rt * &A.FTE  !PUBSEC
 !    end-if                                               !PUBSEC
 !     let #New_Comprate  = round(#New_annual_rt / 52, 2)
 !     break
 !   when = 'B'
 !     if &A.FTE = 0 or &A.FTE = 1                          !PUBSEC
 !       let #New_annual_rt = #New_Step_annual_rt           !PUBSEC
 !     else                                                 !PUBSEC
 !       let #New_annual_rt = #New_Step_annual_rt * &A.FTE  !PUBSEC
 !     end-if                                               !PUBSEC
 !     let #New_Comprate  = round(#New_annual_rt / 26, 2)
 !     break
 !   when = 'S'
 !     if &A.FTE = 0 or &A.FTE = 1                          !PUBSEC
 !       let #New_annual_rt = #New_Step_annual_rt           !PUBSEC
 !     else                                                 !PUBSEC
 !       let #New_annual_rt = #New_Step_annual_rt * &A.FTE  !PUBSEC
 !     end-if                                               !PUBSEC
 !     let #New_Comprate  = round(#New_annual_rt / 24, 2)
 !     break
 !   when = 'M'
 !     if &A.FTE = 0 or &A.FTE = 1                          !PUBSEC
 !       let #New_Comprate = #New_Step_monthly_rt           !PUBSEC
 !     else                                                 !PUBSEC
 !       let #New_Comprate = #New_Step_monthly_rt * &A.FTE  !PUBSEC
 !     end-if                                               !PUBSEC
 !     let #New_annual_rt = round(#New_Comprate * 12, 2)
 !     break
 !   when = 'Q'
 !     if &A.FTE = 0 or &A.FTE = 1                          !PUBSEC
 !       let #New_annual_rt = #New_Step_annual_rt           !PUBSEC
 !     else                                                 !PUBSEC
 !       let #New_annual_rt = #New_Step_annual_rt * &A.FTE  !PUBSEC
 !     end-if                                               !PUBSEC
 !     let #New_Comprate  = round(#New_annual_rt / 4, 2)
 !     break
 !   when-other
 !     if &A.FTE = 0 or &A.FTE = 1                          !PUBSEC
 !       let #New_Comprate = #New_Step_annual_rt            !PUBSEC
 !     else                                                 !PUBSEC
 !       let #New_Comprate = #New_Step_annual_rt * &A.FTE   !PUBSEC
 !     end-if                                               !PUBSEC
 !     let #New_annual_rt = #New_Comprate
 !     break
 ! end-evaluate


 ! let #New_monthly_rt = round(#New_annual_rt / 12, 2)

 ! if &A.Comp_Frequency = 'H'                         ! Hourly
 !   let #New_hourly_rt = #New_Comprate
 ! else                                               ! Salaried
 !   if &A.Std_Hours <> 0
 !     let #New_hourly_rt = round(#New_annual_rt / (52 * &A.Std_Hours), 3)
 !   else
 !     let #New_hourly_rt = 0
 !   end-if
 ! end-if

 ! let #New_Change_Amt = #New_Comprate - &A.Comprate
 ! if &A.Comprate <> 0
 !   let #New_Change_Pct = round(#New_Change_Amt / &A.Comprate * 100, 3)
 ! else
 !   let #New_Change_Pct = 0
 ! end-if


 ! Initialize Rates for New Job
   move #new_step to #new_JobRec_step
   move $new_effdt to $new_JobRec_effdt
   move #new_effseq to #new_JobRec_effseq
   move 0 to #new_JobRec_hourly_rt
   move 0 to #new_jobRec_daily_rt
   move 0 to #new_Jobrec_monthly_rt
   move 0 to #new_JobRec_annual_rt


   !*** For each new comprate convert to Job Currency and frequency **
   let #no_more_new_components = 0
   let #first_component = 1
   let #new_Job_comprate = 0

   while #no_more_new_components = 0

   #DEBUGY display 'inside while loop'

        do FIND-NEW-COMP-STEP

        do CONVERT-NEW-COMPONENT-COMPRATE

        !***  setting the find mode to look for class in FInd Old Compensatation
        let $Comp_Find_mode = 'BASE'
        let #start_find_idx = 0

        !* Make sure at least one search is performed
        let $old_ratecd_fnd = 'Y'

        do FIND_OLD_COMPENSATION

        let $old_fte_indicator = 'N'

        If $old_ratecd_fnd = 'Y'
           get $old_fte_indicator from comparray (#old_comp_idx) cp_fte_indicator
        else

           !*****  According to HR rules of the Job page FTE is disabled when
           !****** Frequency is H, Rate type is PC, HF, or HR and Base Pay SW = N

           if $NewCP_Comp_Frequency <> 'H' and $NewComp_Rate_Type <> 'PC' and
              $NewComp_Rate_Type <> 'HF' and $NewComp_Rate_Type <> 'HR' and
              $NewComp_Base_Pay_Sw <> 'N'

               if &A.FTE <> 0 and &A.FTE <> 1
                      let $old_fte_indicator = 'Y'
                      let $error-msg = 'Default Comprate ' || $NewCP_Comp_Ratecd
                              || ' FTE Indic to Y'
                      do write-report
                      let $error_msg = ' '
               end-if
           end-if
        end-if

        do DET-ANNUAL-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#new_step_annual_rt)

        do DET-MONTHLY-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,$Monthly_Freq,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#new_step_monthly_rt)

        do DET-DAILY-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,$Daily_Freq,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#new_step_daily_rt)

        do DET-HOURLY-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#new_step_hourly_rt)

        if $old_fte_indicator = 'Y' and &A.FTE <> 0.00
           let #Exc_Comprate = #Exc_Comprate * &A.FTE
           let #new_step_hourly_rt = #new_step_hourly_rt * &A.FTE
           let #new_step_daily_rt  = #new_step_daily_rt * &A.FTE
           let #new_step_monthly_rt  = #new_step_monthly_rt * &A.FTE
           let #new_step_annual_rt   = #new_step_annual_rt * &A.FTE
        else
           let #Exc_Comprate = #Exc_Comprate
        end-if

        let #new_Job_comprate = #New_Job_comprate + #Exc_Comprate

        ! Setup Rates for New Job
        let #new_JobRec_hourly_rt = #new_JobRec_hourly_rt + #new_step_hourly_rt
        let #new_jobRec_daily_rt  = #new_jobRec_daily_rt  + #new_step_daily_rt
        let #new_Jobrec_monthly_rt = #new_Jobrec_monthly_rt + #new_step_monthly_rt
        let #new_JobRec_annual_rt = #new_JobRec_annual_rt + #new_step_annual_rt

        let #first_component = 0

   end-while

   !**** Accumulate new Job entries into accumulators
   let #New_Comprate   =  #new_Job_comprate
   let #New_Annual_Rt  =  #new_JobRec_annual_rt
   let #New_Monthly_Rt =  #new_Jobrec_monthly_rt
   let #New_Daily_Rt   =  #new_jobRec_daily_rt
   let #New_Hourly_Rt  =  #new_JobRec_hourly_rt


   !Add on any SENPAY entries
   !***  setting the find mode to look for class in FInd Old Compensatation
   let $Comp_Find_mode = 'CLASS'
   let #start_find_idx = 0
   let $out_rate_code_class = 'SENPAY'

   !* Make sure at least one search is performed
   let $old_ratecd_fnd = 'Y'

   !*** Continue searching until no more entries are found
   while $old_ratecd_fnd <> 'N'

         do FIND_OLD_COMPENSATION

         if $old_ratecd_fnd = 'Y'

                get #old_comp_amt from comparray (#old_comp_idx) cp_comprate
                get $old_comp_frequency from comparray (#old_comp_idx) cp_comp_frequency
                get $old_comp_currency_cd from comparray (#old_comp_idx) cp_currency_cd
                get $old_fte_indicator from comparray (#old_comp_idx) cp_fte_indicator


                !*   Need to take old rate and reapply against the job
                do CONVERT_OLD_COMPRATE

                if $old_fte_indicator = 'Y' and &A.FTE <> 0
                     let #Exc_Comprate   = #Exc_Comprate * &A.FTE
                     let #Exc_Annual_Rt  = #Exc_Annual_Rt * &A.FTE
                     let #Exc_Monthly_Rt = #Exc_Monthly_Rt * &A.FTE
                     let #Exc_Daily_Rt   = #Exc_Daily_Rt * &A.FTE
                     let #Exc_Hourly_Rt  = #Exc_Hourly_Rt * &A.FTE
                end-if

                let #New_Comprate   =  #new_comprate + #Exc_Comprate
                let #New_Annual_Rt  =  #New_Annual_Rt + #Exc_annual_rt
                let #New_Monthly_Rt =  #New_Monthly_Rt + #Exc_Monthly_rt
                let #New_Daily_Rt   =  #New_Daily_Rt + #Exc_daily_rt
                let #New_Hourly_Rt  =  #New_Hourly_Rt + #Exc_Hourly_rt

                !*** For the next loop make sure we dont search entries we have already searched
                let #start_find_idx = #old_comp_idx

        end-if

    end-while

   !Add on any Manual entries
   !***  setting the find mode to look for class in FInd Old Compensatation
   let $Comp_Find_mode = 'MANUAL'
   let #start_find_idx = 0
   let $out_rate_code_class = 'SENPAY'

   !* Make sure at least one search is performed
   let $old_ratecd_fnd = 'Y'

   !*** Continue searching until no more entries are found
   while $old_ratecd_fnd <> 'N'

         do FIND_OLD_COMPENSATION

         if $old_ratecd_fnd = 'Y'

                get #old_comp_amt from comparray (#old_comp_idx) cp_comprate
                get $old_comp_frequency from comparray (#old_comp_idx) cp_comp_frequency
                get $old_comp_currency_cd from comparray (#old_comp_idx) cp_currency_cd
                get $old_fte_indicator from comparray (#old_comp_idx) cp_fte_indicator


                !*   Need to take old rate and reapply against the job

                do CONVERT_OLD_COMPRATE

                !**   Apply FTE from JOB if compensation record is checked
                if $old_fte_indicator = 'Y' and &A.FTE <> 0
                     let #Exc_Comprate   = #Exc_Comprate * &A.FTE
                     let #Exc_Annual_Rt  = #Exc_Annual_Rt * &A.FTE
                     let #Exc_Monthly_Rt = #Exc_Monthly_Rt * &A.FTE
                     let #Exc_Daily_Rt   = #Exc_Daily_Rt * &A.FTE
                     let #Exc_Hourly_Rt  = #Exc_Hourly_Rt * &A.FTE
                end-if

                let #New_Comprate   =  #new_comprate + #Exc_Comprate
                let #New_Annual_Rt  =  #New_Annual_Rt + #Exc_annual_rt
                let #New_Monthly_Rt =  #New_Monthly_Rt + #Exc_Monthly_rt
                let #New_Daily_Rt   =  #New_Daily_Rt + #Exc_daily_rt
                let #New_Hourly_Rt  =  #New_Hourly_Rt + #Exc_Hourly_rt

                !*** For the next loop make sure we dont search entries we have already searched
                let #start_find_idx = #old_comp_idx

        end-if

    end-while


   let #New_Job_Comprate   =   #New_Comprate
   let #New_jobrec_Annual_Rt  = #new_Annual_Rt
   let #New_jobrec_Monthly_Rt = #new_monthly_Rt
   let #New_jobrec_Daily_Rt   = #new_Daily_Rt
   let #New_jobrec_Hourly_Rt  = #new_Hourly_Rt

   let #New_Change_Amt = #New_Job_Comprate - &A.Comprate

   if &A.Comprate <> 0
      let #New_Change_Pct = round(#New_Change_Amt / &A.Comprate * 100, 3)
   else
      let #New_Change_Pct = 0
   end-if


  end-procedure


!**************************************************************************
Begin-Procedure Calc-New-Rates-B
!**************************************************************************

#DEBUGY display 'calc-new-rates-b'

  !For all future Jobs
  !evaluate $Comp_Frequency
  !  when = 'H'                      !Hourly
  !    let #New_Comprate  = #New_Step_hourly_rt_F
  !    let #New_annual_rt = round(#New_Comprate * #Std_Hours * 52, 2)
  !    break
  !  when = 'A'                      !Annual
  !    if #FTE = 0 or #FTE = 1
  !      let #New_Comprate  = #New_Step_annual_rt_F
  !    else
  !      let #New_Comprate  = #New_Step_annual_rt_F * #FTE
  !    end-if
  !    let #New_annual_rt = #New_Comprate-F
  !    break
  !  when = 'D'
  !    if #FTE = 0 or #FTE = 1
  !      let #New_annual_rt = #New_Step_annual_rt_F
  !    else
  !      let #New_annual_rt = #New_Step_annual_rt_F * #FTE
  !    end-if
  !    let #New_Comprate  = round(#New_annual_rt / 365, 2)
  !    break
  !  when = 'W'
  !    if #FTE = 0 or #FTE = 1
  !      let #New_annual_rt = #New_Step_annual_rt_F
  !    else
  !      let #New_annual_rt = #New_Step_annual_rt_F * #FTE
  !    end-if
  !    let #New_Comprate  = round(#New_annual_rt / 52, 2)
  !    break
  !  when = 'B'
  !    if #FTE = 0 or #FTE = 1
  !      let #New_annual_rt = #New_Step_annual_rt_F
  !    else
  !      let #New_annual_rt = #New_Step_annual_rt_F * #FTE
  !    end-if
  !    let #New_Comprate  = round(#New_annual_rt / 26, 2)
  !    break
  !  when = 'S'
  !    if #FTE = 0 or #FTE = 1
  !      let #New_annual_rt = #New_Step_annual_rt_F
  !    else
  !      let #New_annual_rt = #New_Step_annual_rt_F * #FTE
  !    end-if
  !    let #New_Comprate  = round(#New_annual_rt / 24, 2)
  !    break
  !  when = 'M'
  !    if #FTE = 0 or #FTE = 1
  !      let #New_Comprate = #New_Step_monthly_rt_F
  !    else
  !      let #New_Comprate = #New_Step_monthly_rt_F * #FTE
  !    end-if
  !    let #New_annual_rt = round(#New_Comprate * 12, 2)
  !    break
  !  when = 'Q'
  !    if #FTE = 0 or #FTE = 1
  !      let #New_annual_rt = #New_Step_annual_rt_F
  !    else
  !      let #New_annual_rt = #New_Step_annual_rt_F * #FTE
  !    end-if
  !    let #New_Comprate  = round(#New_annual_rt / 4, 2)
  !    break
  !  when-other
  !    if #FTE = 0 or #FTE = 1
  !      let #New_Comprate = #New_Step_annual_rt_F
  !    else
  !      let #New_Comprate = #New_Step_annual_rt_F * #FTE
  !    end-if
  !    let #New_annual_rt = #New_Comprate
  !    break
  !end-evaluate


  !let #New_monthly_rt = round(#New_annual_rt / 12, 2)
  !
  !if $Comp_Frequency = 'H'                         ! Hourly
  !  let #New_hourly_rt = #New_Comprate
  !else                                               ! Salaried
  !  if #Std_Hours <> 0
  !    let #New_hourly_rt = round(#New_annual_rt / (52 * #Std_Hours), 3)
  !  else
  !    let #New_hourly_rt = 0
  !  end-if
  !end-if

  !let #New_Change_Amt = #New_Comprate - #Comprate
  !if #Comprate <> 0
  !  let #New_Change_Pct = round(#New_Change_Amt / #Comprate * 100, 3)
  !else
  !  let #New_Change_Pct = 0
  !end-if


 ! Initialize Rates for New Job
#DEBUGY display 'new_step_f:' noline
#DEBUGY display #new_step_F
#DEBUGY display 'new_effdt:' noline
#DEBUGY display $new_effdt
#DEBUGY display 'new_JobRec_effdt:' noline
#DEBUGY display $new_JobRec_effdt

   move #new_step_F to #new_JobRec_step

   move 0 to #new_JobRec_hourly_rt
   move 0 to #new_jobRec_daily_rt
   move 0 to #new_Jobrec_monthly_rt
   move 0 to #new_JobRec_annual_rt


   !*** For each new comprate convert to Job Currency and frequency **
   let #no_more_new_components = 0
   let #first_component = 1
   let #new_Job_comprate = 0

   while #no_more_new_components = 0

   #DEBUGY display 'no more new components'

if ($futurejob = 'N')  !or ($grade_step_found = 'Y')

        do FIND-NEW-COMP-STEP-F1
else

        do FIND-NEW-COMP-STEP-F
end-if
        do CONVERT-NEW-COMPONENT-COMPRATE-F

        !***  setting the find mode to look for class in FInd Old Compensatation
        let $Comp_Find_mode = 'BASE'
        let #start_find_idx = 0

        !* Make sure at least one search is performed
        let $old_ratecd_fnd = 'Y'

        do FIND_OLD_COMPENSATION_F

        let $old_fte_indicator = 'N'

        If $old_ratecd_fnd = 'Y'
           get $old_fte_indicator from comparray2 (#old_comp_idx) cp_fte_indicator
    #debugy display 'old rate code found'
        else
    #debugy display 'old rate code not found'
           !*****  According to HR rules of the Job page FTE is disabled when
           !****** Frequency is H, Rate type is PC, HF, or HR and Base Pay SW = N

           if $NewCP_Comp_Frequency <> 'H' and $NewComp_Rate_Type <> 'PC' and
              $NewComp_Rate_Type <> 'HF' and $NewComp_Rate_Type <> 'HR' and
              $NewComp_Base_Pay_Sw <> 'N'

               if #FTE <> 0 and #FTE <> 1
                      let $old_fte_indicator = 'Y'
                      let $error-msg = 'Default Comprate ' || $NewCP_Comp_Ratecd
                              || ' FTE Indic to Y'
                      do write-report
                      let $error_msg = ' '
               end-if
           end-if
        end-if

 if $FutureJob = 'N'


        do DET-ANNUAL-RT($new_JobRec_effdt,#Exc_Comprate_F,$COMP_FREQUENCY,
           #STD_HOURS,$STD_HRS_FREQUENCY,#new_step_annual_rt_F)

        do DET-MONTHLY-RT($new_JobRec_effdt,#Exc_Comprate_F,$COMP_FREQUENCY,$Monthly_Freq_F,
           #STD_HOURS,$STD_HRS_FREQUENCY,#new_step_monthly_rt_F)

        do DET-DAILY-RT($new_JobRec_effdt,#Exc_Comprate_F,$COMP_FREQUENCY,$Daily_Freq_F,
           #STD_HOURS,$STD_HRS_FREQUENCY,#new_step_daily_rt_F)

        do DET-HOURLY-RT($new_JobRec_effdt,#Exc_Comprate_F,$COMP_FREQUENCY,
           #STD_HOURS,$STD_HRS_FREQUENCY,#new_step_hourly_rt_F)
else

        do DET-ANNUAL-RT($EFFDT,#Exc_Comprate_F,$COMP_FREQUENCY,
           #STD_HOURS,$STD_HRS_FREQUENCY,#new_step_annual_rt_F)

        do DET-MONTHLY-RT($EFFDT,#Exc_Comprate_F,$COMP_FREQUENCY,$Monthly_Freq_F,
           #STD_HOURS,$STD_HRS_FREQUENCY,#new_step_monthly_rt_F)

        do DET-DAILY-RT($EFFDT,#Exc_Comprate_F,$COMP_FREQUENCY,$Daily_Freq_F,
           #STD_HOURS,$STD_HRS_FREQUENCY,#new_step_daily_rt_F)

        do DET-HOURLY-RT($EFFDT,#Exc_Comprate_F,$COMP_FREQUENCY,
           #STD_HOURS,$STD_HRS_FREQUENCY,#new_step_hourly_rt_F)
end-if

        if $old_fte_indicator = 'Y' and #FTE <> 0.00
           let #Exc_Comprate_F = #Exc_Comprate_F * #FTE
           let #new_step_hourly_rt_F = #new_step_hourly_rt_F * #FTE
           let #new_step_daily_rt_F  = #new_step_daily_rt_F * #FTE
           let #new_step_monthly_rt_F  = #new_step_monthly_rt_F * #FTE
           let #new_step_annual_rt_F   = #new_step_annual_rt_F * #FTE
        else
           let #Exc_Comprate_F = #Exc_Comprate_F
        end-if

   #DEBUGY display 'New_Job_comprate after BASE: ' noline
   #DEBUGY display #New_Job_comprate
   #DEBUGY display 'Exc_Comprate_F: ' noline
   #DEBUGY display #Exc_Comprate_F
   #DEBUGY display 'new_JobRec_hourly_rt: ' noline
   #DEBUGY display #new_JobRec_hourly_rt

        let #new_Job_comprate = #New_Job_comprate + #Exc_Comprate_F

        ! Setup Rates for New Job
        let #new_JobRec_hourly_rt = #new_JobRec_hourly_rt + #new_step_hourly_rt_F
        let #new_jobRec_daily_rt  = #new_jobRec_daily_rt  + #new_step_daily_rt_F
        let #new_Jobrec_monthly_rt = #new_Jobrec_monthly_rt + #new_step_monthly_rt_F
        let #new_JobRec_annual_rt = #new_JobRec_annual_rt + #new_step_annual_rt_F

        let #first_component = 0

   end-while

   !**** Accumulate new Job entries into accumulators
   let #New_Comprate   =  #new_Job_comprate
   let #New_Annual_Rt  =  #new_JobRec_annual_rt
   let #New_Monthly_Rt =  #new_Jobrec_monthly_rt
   let #New_Daily_Rt   =  #new_jobRec_daily_rt
   let #New_Hourly_Rt  =  #new_JobRec_hourly_rt


   !Add on any SENPAY entries
   !***  setting the find mode to look for class in FInd Old Compensatation
   let $Comp_Find_mode = 'CLASS'
   let #start_find_idx = 0
   let $out_rate_code_class = 'SENPAY'

   !* Make sure at least one search is performed
   let $old_ratecd_fnd = 'Y'

   !*** Continue searching until no more entries are found
   while $old_ratecd_fnd <> 'N'

   #DEBUGY display 'Continue searching until no more entries are found'

   do FIND_OLD_COMPENSATION_F

         if $old_ratecd_fnd = 'Y'

                get #old_comp_amt from comparray2 (#old_comp_idx) cp_comprate
                get $old_comp_frequency from comparray2 (#old_comp_idx) cp_comp_frequency
                get $old_comp_currency_cd from comparray2 (#old_comp_idx) cp_currency_cd
                get $old_fte_indicator from comparray2 (#old_comp_idx) cp_fte_indicator


                !*   Need to take old rate and reapply against the job
                do CONVERT_OLD_COMPRATE_F

                if $old_fte_indicator = 'Y' and #FTE <> 0
                     let #Exc_Comprate_F   = #Exc_Comprate_F * #FTE
                     let #Exc_Annual_Rt_F  = #Exc_Annual_Rt_F * #FTE
                     let #Exc_Monthly_Rt_F = #Exc_Monthly_Rt_F * #FTE
                     let #Exc_Daily_Rt_F   = #Exc_Daily_Rt_F * #FTE
                     let #Exc_Hourly_Rt_F  = #Exc_Hourly_Rt_F * #FTE
                end-if

                let #New_Comprate   =  #new_comprate + #Exc_Comprate_F
                let #New_Annual_Rt  =  #New_Annual_Rt + #Exc_annual_rt_F
                let #New_Monthly_Rt =  #New_Monthly_Rt + #Exc_Monthly_rt_F
                let #New_Daily_Rt   =  #New_Daily_Rt + #Exc_daily_rt_F
                let #New_Hourly_Rt  =  #New_Hourly_Rt + #Exc_Hourly_rt_F

                !*** For the next loop make sure we dont search entries we have already searched
                let #start_find_idx = #old_comp_idx

        end-if

    end-while


   #DEBUGY display 'New_Job_comprate after CLASS: ' noline
   #DEBUGY display #New_comprate
   #DEBUGY display 'Exc_Comprate_F: ' noline
   #DEBUGY display #Exc_Comprate_F
   #DEBUGY display 'New_Hourly_Rt: ' noline
   #DEBUGY display #New_Hourly_Rt


   !Add on any Manual entries
   !***  setting the find mode to look for class in FInd Old Compensatation
   let $Comp_Find_mode = 'MANUAL'
   let #start_find_idx = 0
   let $out_rate_code_class = 'SENPAY'

   !* Make sure at least one search is performed
   let $old_ratecd_fnd = 'Y'

   !*** Continue searching until no more entries are found
   while $old_ratecd_fnd <> 'N'

         do FIND_OLD_COMPENSATION_F

         if $old_ratecd_fnd = 'Y'

                get #old_comp_amt from comparray2 (#old_comp_idx) cp_comprate
                get $old_comp_frequency from comparray2 (#old_comp_idx) cp_comp_frequency
                get $old_comp_currency_cd from comparray2 (#old_comp_idx) cp_currency_cd
                get $old_fte_indicator from comparray2 (#old_comp_idx) cp_fte_indicator


                !*   Need to take old rate and reapply against the job

   #DEBUGY display 'entering convert comprate F in MANUAL mode'

                do CONVERT_OLD_COMPRATE_F

                !**   Apply FTE from JOB if compensation record is checked
                if $old_fte_indicator = 'Y' and #FTE <> 0
                     let #Exc_Comprate_F   = #Exc_Comprate_F * #FTE
                     let #Exc_Annual_Rt_F  = #Exc_Annual_Rt_F * #FTE
                     let #Exc_Monthly_Rt_F = #Exc_Monthly_Rt_F * #FTE
                     let #Exc_Daily_Rt_F   = #Exc_Daily_Rt_F * #FTE
                     let #Exc_Hourly_Rt_F  = #Exc_Hourly_Rt_F * #FTE
                end-if

                let #New_Comprate   =  #new_comprate + #Exc_Comprate_F
                let #New_Annual_Rt  =  #New_Annual_Rt + #Exc_annual_rt_F
                let #New_Monthly_Rt =  #New_Monthly_Rt + #Exc_Monthly_rt_F
                let #New_Daily_Rt   =  #New_Daily_Rt + #Exc_daily_rt_F
                let #New_Hourly_Rt  =  #New_Hourly_Rt + #Exc_Hourly_rt_F

                !*** For the next loop make sure we dont search entries we have already searched
                let #start_find_idx = #old_comp_idx

        end-if

    end-while

   #DEBUGY display 'New_Job_comprate after MANUAL: ' noline
   #DEBUGY display #New_comprate
   #DEBUGY display 'Exc_Comprate_F: ' noline
   #DEBUGY display #Exc_Comprate_F
   #DEBUGY display 'New_Hourly_Rt: ' noline
   #DEBUGY display #New_Hourly_Rt


   let #New_Job_Comprate   =   #New_Comprate
   let #New_jobrec_Annual_Rt  = #new_Annual_Rt
   let #New_jobrec_Monthly_Rt = #new_monthly_Rt
   let #New_jobrec_Daily_Rt   = #new_Daily_Rt
   let #New_jobrec_Hourly_Rt  = #new_Hourly_Rt

   #DEBUGY display 'new rates from calc-rates-B'
    #DEBUGY display #New_Job_Comprate
     #DEBUGY display #New_jobrec_Annual_Rt
      #DEBUGY display #New_jobrec_Monthly_Rt
      #DEBUGY display #New_jobrec_Daily_Rt
      #DEBUGY display #New_jobrec_Hourly_Rt


   let #New_Change_Amt = #New_Job_Comprate - #Comprate

   if #Comprate <> 0
      let #New_Change_Pct = round(#New_Change_Amt / #Comprate * 100, 3)
   else
      let #New_Change_Pct = 0
   end-if

   move $new_JobRec_effdt to $old_JobRec_effdt
   move $new_effdt to $new_JobRec_effdt
   move #new_effseq to #new_JobRec_effseq

  end-procedure Calc-New-Rates-B
!***********************************************************************
! Procedure: FIND-NEW-COMP-STEP                                        *
! Descr:     For each pay component, this module searchs the working   *
!            storage array to find the new Pay Component grade/step    *
!            corresponding to the employee's new salary step.          *
!                                                                      *
! Called by: CALC-NEW-RATES-A                                            *
!***********************************************************************
begin-procedure FIND-NEW-COMP-STEP

   !** Default the new COMPENSATION fields to the old values, just in case a
   !**   new RATE_CODE_STEP row is not located.

   if #first_component = 1
       move #cp_Comp_Effseq       to #NewCP_Comp_Effseq
       move $cp_Comp_Ratecd       to $NewCP_Comp_Ratecd
       move #cp_Comp_Rate_Points  to #NewCP_Comp_Rate_Points
       move #cp_Comprate          to #NewCP_Comprate
       move #cp_Comp_Pct          to #NewCP_Comp_Pct
       move $cp_Comp_Frequency    to $NewCP_Comp_Frequency
       move $cp_Currency_Cd       to $NewCP_Currency_Cd
       move $cp_Manual_Sw         to $NewCP_Manual_Sw
       move #cp_Convert_Comprt    to #NewCP_Convert_Comprt
       move $cp_Rate_Code_Group   to $NewCP_Rate_Code_Group
       move 0.00                  to #NewCP_Change_Amt
       move 0.00                  to #NewCP_Change_Pct
       move 0.00                  to #NewCP_Change_Pts
       move $cp_FTE_Indicator     to $NewCP_FTE_Indicator
       move ' '                   to $NewComp_Rate_Type
       move ' '                   to $NewComp_Base_Pay_Sw

   !** Find the correct row for the current EFFSEQ and RATECD from the range
   !**   of rows in the RATE_CODE_STEP array which correspond to the new
   !**   salary grade and step.  Move the values into the COMPENSATION row.


       move #New_comp_begin_idx to #SC_idx

   else
     add 1 to #SC_idx
   end-if


   if #SC_idx <= #New_comp_end_idx
      get #NewCP_Comp_Effseq      from stepcomp(#SC_Idx) sc_Comp_Effseq
      get $NewCP_Comp_Ratecd      from stepcomp(#SC_Idx) sc_Comp_Ratecd
      get $NewCP_Currency_Cd      from stepcomp(#SC_Idx) sc_Currency_cd
      get $NewCP_Comp_Frequency   from stepcomp(#SC_Idx) sc_Comp_Frequency
      get #NewCP_Hourly_Rt        from stepcomp(#SC_Idx) sc_Hourly_Rt
      get #NewCP_Monthly_Rt       from stepcomp(#SC_Idx) sc_Monthly_Rt
      get #NewCP_Annual_Rt        from stepcomp(#SC_Idx) sc_Annual_Rt
      get #NewCP_Comp_Pct         from stepcomp(#SC_Idx) sc_Comp_Pct
      get #NewCP_Comp_Rate_Points from stepcomp(#SC_Idx) sc_Comp_Rate_Points
      get $NewCP_Rate_Code_Group  from stepcomp(#SC_Idx) sc_Rate_Code_Group
      get #NewCP_Comprate         from stepcomp(#SC_Idx) sc_Comprate
      get #NewCP_Daily_Rt         from stepcomp(#SC_Idx) sc_Daily_Rt
      get $NewComp_Rate_Type      from stepcomp(#SC_idx) rc_Comp_rate_type
      get $NewComp_Base_Pay_Sw    from stepcomp(#SC_idx) rc_Comp_base_pay_sw

      #DEBUGY display #SC_idx
      #DEBUGY display 'NewCP_Comprate: ' noline
      #DEBUGY display #NewCP_Comprate

   end-if

   if #SC_idx >= #New_comp_end_idx
         let #no_more_new_components = 1

   end-if


end-procedure !FIND-NEW-COMP-STEP
!***********************************************************************
! Procedure: FIND-NEW-COMP-STEP-F                                        *
! Descr:     For each pay component, this module searchs the working   *
!            storage array to find the new Pay Component grade/step    *
!            corresponding to the employee's new salary step.          *
!                                                                      *
! Called by: CALC-NEW-RATES-B                                            *
!***********************************************************************
begin-procedure FIND-NEW-COMP-STEP-F

   !** Default the new COMPENSATION fields to the old values, just in case a
   !**   new RATE_CODE_STEP row is not located.

   #DEBUGY display 'entering find-new-comp-step-f'

    if #first_component = 1
       move #cp_Comp_Effseq       to #NewCP_Comp_Effseq
       move $cp_Comp_Ratecd       to $NewCP_Comp_Ratecd
       move #cp_Comp_Rate_Points  to #NewCP_Comp_Rate_Points
       move #cp_Comprate          to #NewCP_Comprate
       move #cp_Comp_Pct          to #NewCP_Comp_Pct
       move $cp_Comp_Frequency    to $NewCP_Comp_Frequency
       move $cp_Currency_Cd       to $NewCP_Currency_Cd
       move $cp_Manual_Sw         to $NewCP_Manual_Sw
       move #cp_Convert_Comprt    to #NewCP_Convert_Comprt
       move $cp_Rate_Code_Group   to $NewCP_Rate_Code_Group
       move 0.00                  to #NewCP_Change_Amt
       move 0.00                  to #NewCP_Change_Pct
       move 0.00                  to #NewCP_Change_Pts
       move $cp_FTE_Indicator     to $NewCP_FTE_Indicator
       move ' '                   to $NewComp_Rate_Type
       move ' '                   to $NewComp_Base_Pay_Sw

   !** Find the correct row for the current EFFSEQ and RATECD from the range
   !**   of rows in the RATE_CODE_STEP array which correspond to the new
   !**   salary grade and step.  Move the values into the COMPENSATION row.

   #DEBUGY display 'first component'
   #DEBUGY display #New_comp_begin_idx_F
   #DEBUGY display #New_comp_end_idx_F

    move #New_comp_begin_idx_F to #SC2_idx
   !let #SC2_idx = 1
   else
     add 1 to #SC2_idx
   end-if


   if #SC2_idx <= #New_comp_end_idx_F
      get #NewCP_Comp_Effseq      from stepcomp2(#SC2_Idx) sc_Comp_Effseq
      get $NewCP_Comp_Ratecd      from stepcomp2(#SC2_Idx) sc_Comp_Ratecd
      get $NewCP_Currency_Cd      from stepcomp2(#SC2_Idx) sc_Currency_cd
      get $NewCP_Comp_Frequency   from stepcomp2(#SC2_Idx) sc_Comp_Frequency
      get #NewCP_Hourly_Rt        from stepcomp2(#SC2_Idx) sc_Hourly_Rt
      get #NewCP_Monthly_Rt       from stepcomp2(#SC2_Idx) sc_Monthly_Rt
      get #NewCP_Annual_Rt        from stepcomp2(#SC2_Idx) sc_Annual_Rt
      get #NewCP_Comp_Pct         from stepcomp2(#SC2_Idx) sc_Comp_Pct
      get #NewCP_Comp_Rate_Points from stepcomp2(#SC2_Idx) sc_Comp_Rate_Points
      get $NewCP_Rate_Code_Group  from stepcomp2(#SC2_Idx) sc_Rate_Code_Group
      get #NewCP_Comprate         from stepcomp2(#SC2_Idx) sc_Comprate
      get #NewCP_Daily_Rt         from stepcomp2(#SC2_Idx) sc_Daily_Rt
      get $NewComp_Rate_Type      from stepcomp2(#SC2_idx) rc_Comp_rate_type
      get $NewComp_Base_Pay_Sw    from stepcomp2(#SC2_idx) rc_Comp_base_pay_sw

     #DEBUGY display 'got new componet array information'
     #DEBUGY display #SC2_idx
     #DEBUGY display 'NewCP_Comprate: ' noline
     #DEBUGY display #NewCP_Comprate

   end-if
   if #SC2_idx >= #New_comp_end_idx_F
         let #no_more_new_components = 1

   end-if


   #DEBUGY display 'exiting find-new-comp-step-f'

end-procedure FIND-NEW-COMP-STEP-F

!***********************************************************************
! Procedure: FIND-NEW-COMP-STEP-F1                                        *
! Descr:     For each pay component, this module searchs the working   *
!            storage array to find the new Pay Component grade/step    *
!            corresponding to the employee's new salary step.          *
!                                                                      *
! Called by: CALC-NEW-RATES-B                                            *
!***********************************************************************
begin-procedure FIND-NEW-COMP-STEP-F1

   !** Default the new COMPENSATION fields to the old values, just in case a
   !**   new RATE_CODE_STEP row is not located.

   #DEBUGY display 'entering find-new-comp-step-f1'

   if #first_component = 1
       move #cp_Comp_Effseq       to #NewCP_Comp_Effseq
       move $cp_Comp_Ratecd       to $NewCP_Comp_Ratecd
       move #cp_Comp_Rate_Points  to #NewCP_Comp_Rate_Points
       move #cp_Comprate          to #NewCP_Comprate
       move #cp_Comp_Pct          to #NewCP_Comp_Pct
       move $cp_Comp_Frequency    to $NewCP_Comp_Frequency
       move $cp_Currency_Cd       to $NewCP_Currency_Cd
       move $cp_Manual_Sw         to $NewCP_Manual_Sw
       move #cp_Convert_Comprt    to #NewCP_Convert_Comprt
       move $cp_Rate_Code_Group   to $NewCP_Rate_Code_Group
       move 0.00                  to #NewCP_Change_Amt
       move 0.00                  to #NewCP_Change_Pct
       move 0.00                  to #NewCP_Change_Pts
       move $cp_FTE_Indicator     to $NewCP_FTE_Indicator
       move ' '                   to $NewComp_Rate_Type
       move ' '                   to $NewComp_Base_Pay_Sw

   !** Find the correct row for the current EFFSEQ and RATECD from the range
   !**   of rows in the RATE_CODE_STEP array which correspond to the new
   !**   salary grade and step.  Move the values into the COMPENSATION row.

   #DEBUGY display 'first component'
   #DEBUGY display #New_comp_begin_idx_F

    move #New_comp_begin_idx_F to #SC2_idx
  ! let #SC2_idx = 1
   else
     add 1 to #SC2_idx
   end-if


   if #SC2_idx <= #New_comp_end_idx_F
      get #NewCP_Comp_Effseq      from stepcomp(#SC2_Idx) sc_Comp_Effseq
      get $NewCP_Comp_Ratecd      from stepcomp(#SC2_Idx) sc_Comp_Ratecd
      get $NewCP_Currency_Cd      from stepcomp(#SC2_Idx) sc_Currency_cd
      get $NewCP_Comp_Frequency   from stepcomp(#SC2_Idx) sc_Comp_Frequency
      get #NewCP_Hourly_Rt        from stepcomp(#SC2_Idx) sc_Hourly_Rt
      get #NewCP_Monthly_Rt       from stepcomp(#SC2_Idx) sc_Monthly_Rt
      get #NewCP_Annual_Rt        from stepcomp(#SC2_Idx) sc_Annual_Rt
      get #NewCP_Comp_Pct         from stepcomp(#SC2_Idx) sc_Comp_Pct
      get #NewCP_Comp_Rate_Points from stepcomp(#SC2_Idx) sc_Comp_Rate_Points
      get $NewCP_Rate_Code_Group  from stepcomp(#SC2_Idx) sc_Rate_Code_Group
      get #NewCP_Comprate         from stepcomp(#SC2_Idx) sc_Comprate
      get #NewCP_Daily_Rt         from stepcomp(#SC2_Idx) sc_Daily_Rt
      get $NewComp_Rate_Type      from stepcomp(#SC2_idx) rc_Comp_rate_type
      get $NewComp_Base_Pay_Sw    from stepcomp(#SC2_idx) rc_Comp_base_pay_sw

     #DEBUGY display 'got new componet array information- f1'
     #DEBUGY display #SC2_idx
     #DEBUGY display 'NewCP_Comprate: ' noline
     #DEBUGY display #NewCP_Comprate

   end-if
   if #SC2_idx >= #New_comp_end_idx_F
         let #no_more_new_components = 1

   end-if


   #DEBUGY display 'exiting find-new-comp-step-f1'

end-procedure FIND-NEW-COMP-STEP-F1


!***********************************************************************
! Procedure: CONVERT-NEW-COMPONENT-COMPRATE                            *
! Descr:     For each pay component, this module calls ConvertCurrency *
!            to calculate pay in the base currency for PS_JOB, then it *
!            converts the result based on the Pay Frequency parameters *
!            from PS_JOB.  Following this, the Annual, Monthly, Daily  *
!            and Hourly rates are calculated using called procedures.  *
!                                                                      *
! Called by: CALC-NEW-RATES-B                                            *
!***********************************************************************
begin-procedure CONVERT-NEW-COMPONENT-COMPRATE

   #DEBUGY display 'entering convert new component rates - ORIGINAL'
   #DEBUGY display 'NewCP_Comprate: ' noline
   #DEBUGY display #NewCP_Comprate
   #DEBUGY display 'NewCP_Comp_Frequency: ' noline
   #DEBUGY display $NewCP_Comp_Frequency
   #DEBUGY display 'Effective Date:' noline
   #DEBUGY display &A.EFFDT
   #DEBUGY display 'COMP_FREQUENCY: ' noline
   #DEBUGY display $COMP_FREQUENCY
   #DEBUGY display 'STD_HOURS: ' noline
   #DEBUGY display #STD_HOURS
   #DEBUGY display 'STD_HRS_FREQUENCY:' noline
   #DEBUGY display $STD_HRS_FREQUENCY


   do CONVERTCURRENCY(#NewCP_Comprate,$NewCP_Currency_cd,&A.CURRENCY_CD,
                      'OFFIC',&A.EFFDT,#Wrk_Comprate,'W')

   do CONVERT-FREQUENCY(&A.EFFDT,#Wrk_Comprate,$NewCP_Comp_Frequency,&A.COMP_FREQUENCY,
                        &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Comprate)

   #DEBUGY display 'converted new component rates'

   #DEBUGY display '#Exc_Comprate: ' NOLINE
   #DEBUGY display #Exc_Comprate


end-procedure !CONVERT-NEW-COMPONENT-COMPRATE
!***********************************************************************
! Procedure: CONVERT-NEW-COMPONENT-COMPRATE-F                            *
! Descr:     For each pay component, this module calls ConvertCurrency *
!            to calculate pay in the base currency for PS_JOB, then it *
!            converts the result based on the Pay Frequency parameters *
!            from PS_JOB.  Following this, the Annual, Monthly, Daily  *
!            and Hourly rates are calculated using called procedures.  *
!                                                                      *
! Called by: CALC-NEW-RATES-B                                            *
!***********************************************************************
begin-procedure CONVERT-NEW-COMPONENT-COMPRATE-F

   #DEBUGY display 'entering convert new component rates - F'
   #DEBUGY display 'NewCP_Comprate: ' noline
   #DEBUGY display #NewCP_Comprate
   #DEBUGY display 'NewCP_Comp_Frequency: ' noline
   #DEBUGY display $NewCP_Comp_Frequency
   #DEBUGY display 'new_JobRec_effdt: ' noline
   #DEBUGY display $new_JobRec_effdt
   #DEBUGY display 'COMP_FREQUENCY: ' noline
   #DEBUGY display $COMP_FREQUENCY
   #DEBUGY display 'STD_HOURS: ' noline
   #DEBUGY display #STD_HOURS
   #DEBUGY display 'STD_HRS_FREQUENCY:' noline
   #DEBUGY display $STD_HRS_FREQUENCY

if $Futurejob = 'N'

   #DEBUGY display 'inside future job - N'

   do CONVERTCURRENCY(#NewCP_Comprate,$NewCP_Currency_cd,$CURRENCY_CD,
                      'OFFIC',$new_JobRec_effdt,#Wrk_Comprate,'W')

   do CONVERT-FREQUENCY($new_JobRec_effdt,#Wrk_Comprate,$NewCP_Comp_Frequency,$COMP_FREQUENCY,
                        #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_Comprate_F)

else

   do CONVERTCURRENCY(#NewCP_Comprate,$NewCP_Currency_cd,$CURRENCY_CD,
                      'OFFIC',$EFFDT,#Wrk_Comprate,'W')

   do CONVERT-FREQUENCY($EFFDT,#Wrk_Comprate,$NewCP_Comp_Frequency,$COMP_FREQUENCY,
                        #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_Comprate_F)
end-if

   #DEBUGY display 'converted new component rates'

   #DEBUGY display '#Exc_Comprate_F: ' NOLINE
   #DEBUGY display #Exc_Comprate_F


end-procedure CONVERT-NEW-COMPONENT-COMPRATE-F

!***********************************************************************
! Procedure: FIND_OLD_COMPENSATION                                     *
! Descr:     While attempting to create the new compensation record    *
!            the change amount and percentage are calculated, these    *
!            values will be based on what was stored for the Ratecd    *
!            in the old compensation
!                                                                      *
! Called by: GET-STEPS                                                 *
!***********************************************************************
begin-procedure FIND_OLD_COMPENSATION

!****** Using the ratecd being written see if it existed in old
!****** Compensation
let $Old_ratecd_fnd = 'N'

if #start_find_idx <> 0
        let #old_comp_idx = #start_find_idx
else
        let #old_comp_idx = 0
end-if

   !***** Search base compensations until rate code is found or no
   !***** no more entries to search
   while $Old_ratecd_fnd = 'N' and #old_comp_idx < #cp_cnt

        add 1 to #old_comp_idx

        if $Comp_find_mode = 'BASE'
               get $Old_comp_ratecd from comparray (#old_comp_idx) cp_comp_ratecd
               get #Old_cp_effseq from comparray (#old_comp_idx) cp_effseq
               get $Old_manual_sw from comparray (#old_comp_idx) cp_manual_sw


               if $NewCP_Comp_Ratecd = $Old_comp_ratecd and #out_Comp_effseq = #Old_cp_effseq
                             and $Old_manual_sw = 'N'
                    move 'Y' to $Old_ratecd_fnd
               end-if
        end-if

        if $Comp_find_mode = 'RATECD'
               get $Old_comp_ratecd from comparray (#old_comp_idx) cp_comp_ratecd
               get #Old_cp_effseq from comparray (#old_comp_idx) cp_effseq
               get $Old_manual_sw from comparray (#old_comp_idx) cp_manual_sw

               if $out_Comp_ratecd = $Old_comp_ratecd and #Out_NewCP_Comp_Effseq = #Old_cp_effseq
                             and $Old_manual_sw = 'N'
                    move 'Y' to $Old_ratecd_fnd
               end-if
        end-if


        if $Comp_find_mode = 'CLASS'
                get $Old_comp_rate_code_class from comparray (#old_comp_idx) cp_rate_code_class

                if $out_rate_code_class = $Old_comp_rate_code_class
                        move 'Y' to $Old_ratecd_fnd
                end-if
        end-if

        if $Comp_find_mode = 'MANUAL'
                get $Old_manual_sw from comparray (#old_comp_idx) cp_manual_sw
                get $Old_comp_rate_code_class from comparray (#old_comp_idx) cp_rate_code_class

                if $Old_manual_sw = 'Y' and $Old_comp_rate_code_class <> $out_rate_code_class
                        move 'Y' to $Old_ratecd_fnd
                end-if
        end-if

   end-while

end-procedure


!***********************************************************************
! Procedure: FIND_OLD_COMPENSATION_F                                     *
!***********************************************************************
begin-procedure FIND_OLD_COMPENSATION_F

!****** Using the ratecd being written see if it existed in old
!****** Compensation
let $Old_ratecd_fnd = 'N'


if #start_find_idx <> 0
        let #old_comp_idx = #start_find_idx
else
        let #old_comp_idx = 0
end-if

#debugy display 'cp2_cnt: ' noline
#debugy display #cp2_cnt
#debugy display 'Comp_find_mode: ' noline
#debugy display $Comp_find_mode


   !***** Search base compensations until rate code is found or no
   !***** no more entries to search
   while $Old_ratecd_fnd = 'N' and #old_comp_idx < #cp2_cnt

        add 1 to #old_comp_idx

        if $Comp_find_mode = 'BASE'
               get $Old_comp_ratecd from comparray2 (#old_comp_idx) cp_comp_ratecd
               get #Old_cp_effseq from comparray2 (#old_comp_idx) cp_effseq
               get $Old_manual_sw from comparray2 (#old_comp_idx) cp_manual_sw


               if $NewCP_Comp_Ratecd = $Old_comp_ratecd and #out_Comp_effseq = #Old_cp_effseq
                             and $Old_manual_sw = 'N'
                    move 'Y' to $Old_ratecd_fnd
               end-if
        end-if

        if $Comp_find_mode = 'RATECD'


               get $Old_comp_ratecd from comparray2 (#old_comp_idx) cp_comp_ratecd
               get #Old_cp_effseq from comparray2 (#old_comp_idx) cp_effseq
               get $Old_manual_sw from comparray2 (#old_comp_idx) cp_manual_sw


    #debugy display 'Old_comp_ratecd: ' noline
    #debugy display $Old_comp_ratecd
    #debugy display 'out_Comp_ratecd : ' noline
    #debugy display $out_Comp_ratecd
    #debugy display 'Out_NewCP_Comp_Effseq: ' noline
    #debugy display #Out_NewCP_Comp_Effseq
    #debugy display 'Old_cp_effseq: ' noline
    #debugy display #Old_cp_effseq

               if $out_Comp_ratecd = $Old_comp_ratecd and #Out_NewCP_Comp_Effseq = #Old_cp_effseq
                             and $Old_manual_sw = 'N'
                    move 'Y' to $Old_ratecd_fnd
               end-if
        end-if


        if $Comp_find_mode = 'CLASS'
                get $Old_comp_rate_code_class from comparray2 (#old_comp_idx) cp_rate_code_class

                if $out_rate_code_class = $Old_comp_rate_code_class
                        move 'Y' to $Old_ratecd_fnd
                end-if
        end-if

        if $Comp_find_mode = 'MANUAL'
                get $Old_manual_sw from comparray2 (#old_comp_idx) cp_manual_sw
                get $Old_comp_rate_code_class from comparray2 (#old_comp_idx) cp_rate_code_class

                if $Old_manual_sw = 'Y' and $Old_comp_rate_code_class <> $out_rate_code_class
                        move 'Y' to $Old_ratecd_fnd
                end-if
        end-if

    #debugy display 'Old_ratecd_fnd: ' noline
    #debugy display $Old_ratecd_fnd

  end-while

end-procedure  FIND_OLD_COMPENSATION_F



!***********************************************************************
! Procedure: CONVERT_OLD_COMPRATE                                      *
! Descr:     For each pay component, the amount is converted to its JOB*
!            equivalent                                                *
!                                                                      *
! Called by: CALC-NEW-RATES-A                                            *
!***********************************************************************
begin-procedure CONVERT_OLD_COMPRATE

   do CONVERTCURRENCY(#old_comp_amt,$old_comp_currency_cd,&A.CURRENCY_CD,
          'OFFIC',&A.EFFDT,#Wrk_Comprate,'W')

   do CONVERT-FREQUENCY(&A.EFFDT,#Wrk_Comprate,$old_comp_frequency,&A.COMP_FREQUENCY,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Comprate)

   if &F.FREQUENCY_TYPE = 'C'
           let $Monthly_Freq = ' '
           let $Daily_Freq = ' '
           do GET-PAYGROUP-FREQ-CNT(&A.EMPLID,&A.EMPL_RCD,&A.EFFDT,$Monthly_Freq,$Daily_Freq)
   else
           let $Monthly_Freq = 'M'
           let $Daily_Freq = 'D'
   end-if

   do DET-ANNUAL-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Annual_Rt)

   do DET-MONTHLY-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,$Monthly_Freq,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Monthly_Rt)

   do DET-DAILY-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,$Daily_Freq,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_daily_rt)

   do DET-HOURLY-RT(&A.EFFDT,#Exc_Comprate,&A.COMP_FREQUENCY,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#Exc_Hourly_rt)

end-procedure

!***********************************************************************
! Procedure: CONVERT_OLD_COMPRATE_F                                      *
! Descr:     For each pay component, the amount is converted to its JOB*
!            equivalent                                                *
!                                                                      *
! Called by: CALC-NEW-RATES-B                                            *
!***********************************************************************
begin-procedure CONVERT_OLD_COMPRATE_F

    #debugy display 'entering CONVERT_OLD_COMPRATE_F'
    #debugy display 'Futurejob: ' noline
    #debugy display $Futurejob
    #debugy display 'FREQUENCY_TYPE: ' noline
    #debugy display $FREQUENCY_TYPE
    #debugy display 'old_comp_amt: ' noline
    #debugy display #old_comp_amt
    #debugy display 'old_comp_currency_cd: ' noline
    #debugy display $old_comp_currency_cd
    #debugy display 'new_JobRec_effdt: ' noline
    #debugy display $new_JobRec_effdt
    #debugy display 'STD_HOURS: ' noline
    #debugy display #STD_HOURS
    #debugy display 'STD_HRS_FREQUENCY: ' noline
    #debugy display $STD_HRS_FREQUENCY
    #debugy display 'old_comp_frequency: ' noline
    #debugy display $old_comp_frequency
    #debugy display 'Wrk_Comprate: ' noline
    #debugy display #Wrk_Comprate



if $Futurejob = 'N'


   do CONVERTCURRENCY(#old_comp_amt,$old_comp_currency_cd,$CURRENCY_CD,
         'OFFIC',$new_JobRec_effdt,#Wrk_Comprate,'W')

   do CONVERT-FREQUENCY($EFFDT,#Wrk_Comprate,$old_comp_frequency,$COMP_FREQUENCY,
           #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_Comprate_F)

else
   do CONVERTCURRENCY(#old_comp_amt,$old_comp_currency_cd,$CURRENCY_CD,
          'OFFIC',$EFFDT,#Wrk_Comprate,'W')

   do CONVERT-FREQUENCY($EFFDT,#Wrk_Comprate,$old_comp_frequency,$COMP_FREQUENCY,
           #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_Comprate_F)
end-if


    if $FREQUENCY_TYPE = 'C'
           let $Monthly_Freq_F = ' '
           let $Daily_Freq_F = ' '

if $Futurejob = 'N'
    do GET-PAYGROUP-FREQ-CNT($EMPLID,#EMPL_RCD,$new_JobRec_effdt,$Monthly_Freq_F,$Daily_Freq_F)
else
    do GET-PAYGROUP-FREQ-CNT($EMPLID,#EMPL_RCD,$EFFDT,$Monthly_Freq_F,$Daily_Freq_F)
end-if
   else
           let $Monthly_Freq_F = 'M'
           let $Daily_Freq_F = 'D'
   end-if

    #debugy display 'Exc_Comprate_F: ' noline
    #debugy display #Exc_Comprate_F

if $Futurejob = 'N'

   do DET-ANNUAL-RT($new_JobRec_effdt,#Exc_Comprate_F,$COMP_FREQUENCY,
           #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_Annual_Rt_F)

   do DET-MONTHLY-RT($new_JobRec_effdt,#Exc_Comprate_F,$COMP_FREQUENCY,$Monthly_Freq_F,
           #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_Monthly_Rt_F)

   do DET-DAILY-RT($new_JobRec_effdt,#Exc_Comprate_F,$COMP_FREQUENCY,$Daily_Freq_F,
           #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_daily_rt_F)

   do DET-HOURLY-RT($new_JobRec_effdt,#Exc_Comprate_F,$COMP_FREQUENCY,
           #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_Hourly_rt_F)

else

   do DET-ANNUAL-RT($EFFDT,#Exc_Comprate_F,$COMP_FREQUENCY,
           #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_Annual_Rt_F)

   do DET-MONTHLY-RT($EFFDT,#Exc_Comprate_F,$COMP_FREQUENCY,$Monthly_Freq_F,
           #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_Monthly_Rt_F)

   do DET-DAILY-RT($EFFDT,#Exc_Comprate_F,$COMP_FREQUENCY,$Daily_Freq_F,
           #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_daily_rt_F)

   do DET-HOURLY-RT($EFFDT,#Exc_Comprate_F,$COMP_FREQUENCY,
           #STD_HOURS,$STD_HRS_FREQUENCY,#Exc_Hourly_rt_F)
end-if



end-procedure CONVERT_OLD_COMPRATE_F


!***********************************************************************
! Procedure: DETERMINE-NEW-COMPENSATIONS                               *
! Descr:     Get compensation base information from the array storing  *
!            RATECD information for the given step.  Once base info    *
!            retrieved calculate remainder, (CONVERT_COMPRT, CHANGE_AMT*
!            CHANGE_PCT and CHANGE_PTS).  Insert a new compensation    *
!                                                                      *
! Called by: PROCESS_EMPS                                              *
!***********************************************************************
begin-procedure Determine-New-Compensations

  ! *** Starting at the first rate code entry for the new step insert
  ! *** a new compensation record directly releated to the RATECD
  ! *** for the new step
  let #out_cp_idx = #New_comp_begin_idx
  let #out_cp_cnt = #New_comp_end_idx

  ! *** All ratecd entries for NEW STEP are turned into COMPENSATIONS
  ! *** Comprate reflects post Frequency but pre Currency conversion
     while #out_cp_idx <= #out_cp_cnt
       get #out_Comp_effseq       from  stepcomp (#out_cp_idx) sc_comp_effseq
       get $out_Comp_ratecd       from  stepcomp (#out_cp_idx) sc_comp_ratecd
       get #out_Comp_rate_points  from  stepcomp (#out_cp_idx) sc_comp_rate_points
       get #out_Comprate          from  stepcomp (#out_cp_idx) sc_comprate
       get #out_Comp_pct          from  stepcomp (#out_cp_idx) sc_comp_pct
       get $out_Comp_frequency    from  stepcomp (#out_cp_idx) sc_comp_frequency
       get $out_Currency_cd       from  stepcomp (#out_cp_idx) sc_currency_cd
       get $out_Rate_code_group   from  stepcomp (#out_cp_idx) sc_rate_code_group
       get $out_comp_rate_type    from  stepcomp (#out_cp_idx) rc_comp_rate_type
       get $out_comp_base_pay_sw  from  stepcomp (#out_cp_idx) rc_comp_base_pay_sw

       let $out_Manual_sw         =  'N'
       let $out_cmp_src_ind       =  'S'

       !*** When doing a manual step upgrade the FTE flag defaults to N ***
       let $out_FTE_Indicator     =  'N'

       ! ***** Determine the Convert Comprate for record by applying
       ! ***** Currency Factor

    #debugy display &A.CURRENCY_CD

       do CONVERTCURRENCY(#out_Comprate,$out_Currency_cd,&A.CURRENCY_CD,
                      'OFFIC',&A.EFFDT,#out_wk_Convert_Comprate,'W')
    #debugy display 'out_Currency_cd: ' noline
    #debugy display $out_Currency_cd

       ! **** New to build 36
       do CONVERT-FREQUENCY(&A.EFFDT,#out_wk_Convert_Comprate,$out_comp_frequency,&A.COMP_FREQUENCY,
           &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#out_Convert_Comprate)

       ! ***** Now calculate difference between rate before and rate after if
       ! ***** it existed prior to this new job step
       let $Comp_find_mode = 'RATECD'
       let #start_find_idx = 0
       do FIND_OLD_COMPENSATION

       ! ***** If an old entry for the Rate code not found then all change
       ! ***** amounts are set to 0
       ! ***** $Old_ratecd_fnd set in Find_old_compensation as is old_comp_idx
       if $Old_ratecd_fnd = 'N'
           let #out_comp_change_amt = 0
           let #out_comp_change_pct = 0
           let #out_comp_change_pts = 0

           !*****  According to HR rules of the Job page FTE is disabled when
           !****** Frequency is H, Rate type is PC, HF, or HR and Base Pay SW = N

           if $out_Comp_frequency <> 'H' and $out_comp_rate_type <> 'PC' and
              $out_comp_rate_type <> 'HF' and $out_comp_rate_type <> 'HR' and
              $out_comp_base_pay_sw <> 'N'

               if &A.FTE <> 0.00 and &A.FTE <> 1
                   let #out_Convert_Comprate = #out_Convert_Comprate * &A.FTE
                   let $out_FTE_Indicator     =  'Y'
               end-if
           end-if

       else

           get #Old_comp_amt from comparray (#old_comp_idx) cp_comprate
           get #Old_comp_pts from comparray (#old_comp_idx) cp_comp_rate_points
           get $old_comp_frequency from comparray (#old_comp_idx) cp_comp_frequency
           get $old_comp_currency from comparray (#old_comp_idx) cp_currency_cd
           get $old_fte_indicator from comparray (#old_comp_idx) cp_fte_indicator

           if $old_fte_indicator = 'Y' and &A.FTE <> 0.00
              let #out_Convert_Comprate = #out_Convert_Comprate * &A.FTE
              let $out_FTE_Indicator     =  'Y'
           end-if

           ! ***** Determine the Convert Comprate for record by applying
           ! ***** Currency Factor
           do CONVERTCURRENCY(#old_comp_amt,$old_comp_currency,$out_Currency_cd,
                      'OFFIC',&A.EFFDT,#out_work_Comprate,'W')

           ! ***** Make sure for change amounts we are comparing the same frequency IE Apple to Apple
           do CONVERT-FREQUENCY(&A.EFFDT,#out_work_Comprate,$old_comp_frequency,$out_comp_frequency,
                        &A.STD_HOURS,&A.STD_HRS_FREQUENCY,#out_work_Comprate)

           let #out_comp_change_amt = #out_Comprate - #out_work_Comprate
           let #out_comp_change_pts = #out_Comp_rate_points - #Old_comp_pts

           ! **** Change percentage
           if #Old_comp_amt <> 0
              let #out_comp_change_Pct = round(#out_Comp_change_amt / #out_work_comprate * 100, 3)
           else
              let #out_comp_change_Pct = 0
           end-if
       end-if

       !****** Create new Compensation record for new job
       do INSERT-NEW-COMP-REC

       add 1 to #out_cp_idx

     end-while                                    !*** All new compensation now inserted


   !*** Now copy SENPAY from old compensation to new compensation
   !***  setting the find mode to look for class in FInd Old Compensatation
   let $Comp_Find_mode = 'CLASS'
   let #start_find_idx = 0
   let $out_rate_code_class = 'SENPAY'

   !* Make sure at least one search is performed
   let $old_ratecd_fnd = 'Y'

   !*** Continue searching until no more entries are found
   while $old_ratecd_fnd <> 'N'
         do FIND_OLD_COMPENSATION

         if $old_ratecd_fnd = 'Y'

                get #out_Comp_effseq       from  comparray (#old_comp_idx) cp_comp_effseq
                get $out_Comp_ratecd       from  comparray (#old_comp_idx) cp_comp_ratecd
                get #out_Comp_rate_points  from  comparray (#old_comp_idx) cp_comp_rate_points
                get #out_Comprate          from  comparray (#old_comp_idx) cp_comprate
                get #out_Comp_pct          from  comparray (#old_comp_idx) cp_comp_pct
                get $out_Comp_frequency    from  comparray (#old_comp_idx) cp_comp_frequency
                get $out_Currency_cd       from  comparray (#old_comp_idx) cp_currency_cd
                get $out_Rate_code_group   from  comparray (#old_comp_idx) cp_rate_code_group
                get $out_Manual_sw         from  comparray (#old_comp_idx) cp_manual_sw
                get $out_FTE_Indicator     from  comparray (#old_comp_idx) cp_fte_indicator
                get $out_cmp_src_ind       from  comparray (#old_comp_idx) cp_cmp_src_ind
                get #out_Convert_Comprate  from  comparray (#old_comp_idx)  cp_convert_comprt

                ! ***** amounts are set to 0
                let #out_comp_change_amt = 0
                let #out_comp_change_pct = 0
                let #out_comp_change_pts = 0

                !****** Create a copy of Compensation record for new job
                do INSERT-NEW-COMP-REC

        end-if

        !*** For the next loop make sure we dont search entries we have already searched
        let #start_find_idx = #old_comp_idx

    end-while

   !Add on any Manual entries
   !***  setting the find mode to look for class in FInd Old Compensatation
   let $Comp_Find_mode = 'MANUAL'
   let #start_find_idx = 0
   let $out_rate_code_class = 'SENPAY'

   !* Make sure at least one search is performed
   let $old_ratecd_fnd = 'Y'

   !*** Continue searching until no more entries are found
   while $old_ratecd_fnd <> 'N'
         do FIND_OLD_COMPENSATION

         if $old_ratecd_fnd = 'Y'

                get #out_Comp_effseq       from  comparray (#old_comp_idx) cp_comp_effseq
                get $out_Comp_ratecd       from  comparray (#old_comp_idx) cp_comp_ratecd
                get #out_Comp_rate_points  from  comparray (#old_comp_idx) cp_comp_rate_points
                get #out_Comprate          from  comparray (#old_comp_idx) cp_comprate
                get #out_Comp_pct          from  comparray (#old_comp_idx) cp_comp_pct
                get $out_Comp_frequency    from  comparray (#old_comp_idx) cp_comp_frequency
                get $out_Currency_cd       from  comparray (#old_comp_idx) cp_currency_cd
                get $out_Rate_code_group   from  comparray (#old_comp_idx) cp_rate_code_group
                get $out_Manual_sw         from  comparray (#old_comp_idx) cp_manual_sw
                get $out_FTE_Indicator     from  comparray (#old_comp_idx) cp_fte_indicator
                get $out_cmp_src_ind       from  comparray (#old_comp_idx) cp_cmp_src_ind
                get #out_Convert_Comprate  from  comparray (#old_comp_idx) cp_convert_comprt

                ! ***** amounts are set to 0
                let #out_comp_change_amt = 0
                let #out_comp_change_pct = 0
                let #out_comp_change_pts = 0

                !****** Create a copy of Compensation record for new job
                do INSERT-NEW-COMP-REC

        end-if

        !*** For the next loop make sure we dont search entries we have already searched
        let #start_find_idx = #old_comp_idx

    end-while


end-procedure


!***********************************************************************
! Procedure: DETERMINE-NEW-COMPENSATIONS-F                             *
!***********************************************************************
begin-procedure Determine-New-Compensations-F


#debugy display 'determine new compensations - F'


if $FutureJob = 'N'
    let $old_jobrec_effdt = $old_JobRec_effdt
else
    let $old_jobrec_effdt = &A2.Effdt
end-if
#debugy display 'new_JobRec_effdt:'
#debugy display $new_JobRec_effdt
#debugy display 'old_JobRec_effdt:'
#debugy display $old_JobRec_effdt

  ! *** Starting at the first rate code entry for the new step insert
  ! *** a new compensation record directly releated to the RATECD
  ! *** for the new step
  let #out_cp_idx = #New_comp_begin_idx_F
  let #out_cp_cnt = #New_comp_end_idx_F

#debugy display #New_comp_begin_idx_F
#debugy display #New_comp_end_idx_F

  ! *** All ratecd entries for NEW STEP are turned into COMPENSATIONS
  ! *** Comprate reflects post Frequency but pre Currency conversion
     while #out_cp_idx <= #out_cp_cnt

if $futurejob = 'N'

       get #out_Comp_effseq       from  stepcomp (#out_cp_idx) sc_comp_effseq
       get $out_Comp_ratecd       from  stepcomp (#out_cp_idx) sc_comp_ratecd
       get #out_Comp_rate_points  from  stepcomp (#out_cp_idx) sc_comp_rate_points
       get #out_Comprate          from  stepcomp (#out_cp_idx) sc_comprate
       get #out_Comp_pct          from  stepcomp (#out_cp_idx) sc_comp_pct
       get $out_Comp_frequency    from  stepcomp (#out_cp_idx) sc_comp_frequency
       get $out_Currency_cd       from  stepcomp (#out_cp_idx) sc_currency_cd
       get $out_Rate_code_group   from  stepcomp (#out_cp_idx) sc_rate_code_group
       get $out_comp_rate_type    from  stepcomp (#out_cp_idx) rc_comp_rate_type
       get $out_comp_base_pay_sw  from  stepcomp (#out_cp_idx) rc_comp_base_pay_sw

       let $out_Manual_sw         =  'N'
       let $out_cmp_src_ind       =  'S'
else
       get #out_Comp_effseq       from  stepcomp2 (#out_cp_idx) sc_comp_effseq
       get $out_Comp_ratecd       from  stepcomp2 (#out_cp_idx) sc_comp_ratecd
       get #out_Comp_rate_points  from  stepcomp2 (#out_cp_idx) sc_comp_rate_points
       get #out_Comprate          from  stepcomp2 (#out_cp_idx) sc_comprate
       get #out_Comp_pct          from  stepcomp2 (#out_cp_idx) sc_comp_pct
       get $out_Comp_frequency    from  stepcomp2 (#out_cp_idx) sc_comp_frequency
       get $out_Currency_cd       from  stepcomp2 (#out_cp_idx) sc_currency_cd
       get $out_Rate_code_group   from  stepcomp2 (#out_cp_idx) sc_rate_code_group
       get $out_comp_rate_type    from  stepcomp2 (#out_cp_idx) rc_comp_rate_type
       get $out_comp_base_pay_sw  from  stepcomp2 (#out_cp_idx) rc_comp_base_pay_sw

       let $out_Manual_sw         =  'N'
       let $out_cmp_src_ind       =  'S'

end-if

#debugy display 'out_Comprate: ' noline
#debugy display #out_Comprate

       !*** When doing a manual step upgrade the FTE flag defaults to N ***
       let $out_FTE_Indicator     =  'N'

       ! ***** Determine the Convert Comprate for record by applying
       ! ***** Currency Factor
       do CONVERTCURRENCY(#out_Comprate,$out_Currency_cd,$CURRENCY_CD,
                      'OFFIC',$old_jobrec_effdt,#out_wk_Convert_Comprate,'W')

#debugy display 'out_Currency_cd: ' NOLINE
#debugy display $out_Currency_cd
#debugy display 'out_wk_Convert_Comprate: ' NOLINE
#debugy display #out_wk_Convert_Comprate
#debugy display 'COMP_FREQUENCY: ' NOLINE
#debugy display $COMP_FREQUENCY
#debugy display 'STD_HOURS: ' NOLINE
#debugy display #STD_HOURS
#debugy display 'STD_HRS_FREQUENCY: ' NOLINE
#debugy display $STD_HRS_FREQUENCY


       ! **** New to build 36
       do CONVERT-FREQUENCY($old_jobrec_effdt,#out_wk_Convert_Comprate,$out_comp_frequency,$COMP_FREQUENCY,
           #STD_HOURS,$STD_HRS_FREQUENCY,#out_Convert_Comprate)

#debugy display 'out_comp_frequency: ' NOLINE
#debugy display $out_comp_frequency
#debugy display 'out_Convert_Comprate: ' NOLINE
#debugy display #out_Convert_Comprate


       ! ***** Now calculate difference between rate before and rate after if
       ! ***** it existed prior to this new job step
       let $Comp_find_mode = 'RATECD'
       let #start_find_idx = 0
       do FIND_OLD_COMPENSATION_F

       ! ***** If an old entry for the Rate code not found then all change
       ! ***** amounts are set to 0
       ! ***** $Old_ratecd_fnd set in Find_old_compensation_F as is old_comp_idx
       if $Old_ratecd_fnd = 'N'
           let #out_comp_change_amt = 0
           let #out_comp_change_pct = 0
           let #out_comp_change_pts = 0

           !*****  According to HR rules of the Job page FTE is disabled when
           !****** Frequency is H, Rate type is PC, HF, or HR and Base Pay SW = N

           if $out_Comp_frequency <> 'H' and $out_comp_rate_type <> 'PC' and
              $out_comp_rate_type <> 'HF' and $out_comp_rate_type <> 'HR' and
              $out_comp_base_pay_sw <> 'N'

               if #FTE <> 0.00 and #FTE <> 1
                   let #out_Convert_Comprate = #out_Convert_Comprate * #FTE
                   let $out_FTE_Indicator     =  'Y'
               end-if
           end-if

       else

           get #Old_comp_amt from comparray2 (#old_comp_idx) cp_comprate
           get #Old_comp_pts from comparray2 (#old_comp_idx) cp_comp_rate_points
           get $old_comp_frequency from comparray2 (#old_comp_idx) cp_comp_frequency
           get $old_comp_currency from comparray2 (#old_comp_idx) cp_currency_cd
           get $old_fte_indicator from comparray2 (#old_comp_idx) cp_fte_indicator

    #debugy display 'Old_comp_amt: ' noline
    #debugy display #Old_comp_amt

           if $old_fte_indicator = 'Y' and #FTE <> 0.00
              let #out_Convert_Comprate = #out_Convert_Comprate * #FTE
              let $out_FTE_Indicator     =  'Y'
           end-if

           ! ***** Determine the Convert Comprate for record by applying
           ! ***** Currency Factor
           do CONVERTCURRENCY(#old_comp_amt,$old_comp_currency,$out_Currency_cd,
                      'OFFIC',$old_jobrec_effdt,#out_work_Comprate,'W')

           ! ***** Make sure for change amounts we are comparing the same frequency IE Apple to Apple
           do CONVERT-FREQUENCY($old_jobrec_effdt,#out_work_Comprate,$old_comp_frequency,$out_comp_frequency,
                        #STD_HOURS,$STD_HRS_FREQUENCY,#out_work_Comprate)

           let #out_comp_change_amt = #out_Comprate - #out_work_Comprate
           let #out_comp_change_pts = #out_Comp_rate_points - #Old_comp_pts

           ! **** Change percentage
           if #Old_comp_amt <> 0
              let #out_comp_change_Pct = round(#out_Comp_change_amt / #out_work_comprate * 100, 3)
           else
              let #out_comp_change_Pct = 0
           end-if
       end-if

       !****** Create new Compensation record for new job

       do INSERT-NEW-COMP-REC


       add 1 to #out_cp_idx

     end-while                                    !*** All new compensation now inserted


   !*** Now copy SENPAY from old compensation to new compensation
   !***  setting the find mode to look for class in FInd Old Compensatation
   let $Comp_Find_mode = 'CLASS'
   let #start_find_idx = 0
   let $out_rate_code_class = 'SENPAY'

   !* Make sure at least one search is performed
   let $old_ratecd_fnd = 'Y'

   !*** Continue searching until no more entries are found
   while $old_ratecd_fnd <> 'N'
         do FIND_OLD_COMPENSATION_F

         if $old_ratecd_fnd = 'Y'

                get #out_Comp_effseq       from  comparray2 (#old_comp_idx) cp_comp_effseq
                get $out_Comp_ratecd       from  comparray2 (#old_comp_idx) cp_comp_ratecd
                get #out_Comp_rate_points  from  comparray2 (#old_comp_idx) cp_comp_rate_points
                get #out_Comprate          from  comparray2 (#old_comp_idx) cp_comprate
                get #out_Comp_pct          from  comparray2 (#old_comp_idx) cp_comp_pct
                get $out_Comp_frequency    from  comparray2 (#old_comp_idx) cp_comp_frequency
                get $out_Currency_cd       from  comparray2 (#old_comp_idx) cp_currency_cd
                get $out_Rate_code_group   from  comparray2 (#old_comp_idx) cp_rate_code_group
                get $out_Manual_sw         from  comparray2 (#old_comp_idx) cp_manual_sw
                get $out_FTE_Indicator     from  comparray2 (#old_comp_idx) cp_fte_indicator
                get $out_cmp_src_ind       from  comparray2 (#old_comp_idx) cp_cmp_src_ind
                get #out_Convert_Comprate  from  comparray2 (#old_comp_idx)  cp_convert_comprt

                ! ***** amounts are set to 0
                let #out_comp_change_amt = 0
                let #out_comp_change_pct = 0
                let #out_comp_change_pts = 0

                !****** Create a copy of Compensation record for new job
                do INSERT-NEW-COMP-REC

        end-if

        !*** For the next loop make sure we dont search entries we have already searched
        let #start_find_idx = #old_comp_idx

    end-while

   !Add on any Manual entries
   !***  setting the find mode to look for class in FInd Old Compensatation
   let $Comp_Find_mode = 'MANUAL'
   let #start_find_idx = 0
   let $out_rate_code_class = 'SENPAY'

   !* Make sure at least one search is performed
   let $old_ratecd_fnd = 'Y'

   !*** Continue searching until no more entries are found
   while $old_ratecd_fnd <> 'N'
         do FIND_OLD_COMPENSATION_F

         if $old_ratecd_fnd = 'Y'

                get #out_Comp_effseq       from  comparray2 (#old_comp_idx) cp_comp_effseq
                get $out_Comp_ratecd       from  comparray2 (#old_comp_idx) cp_comp_ratecd
                get #out_Comp_rate_points  from  comparray2 (#old_comp_idx) cp_comp_rate_points
                get #out_Comprate          from  comparray2 (#old_comp_idx) cp_comprate
                get #out_Comp_pct          from  comparray2 (#old_comp_idx) cp_comp_pct
                get $out_Comp_frequency    from  comparray2 (#old_comp_idx) cp_comp_frequency
                get $out_Currency_cd       from  comparray2 (#old_comp_idx) cp_currency_cd
                get $out_Rate_code_group   from  comparray2 (#old_comp_idx) cp_rate_code_group
                get $out_Manual_sw         from  comparray2 (#old_comp_idx) cp_manual_sw
                get $out_FTE_Indicator     from  comparray2 (#old_comp_idx) cp_fte_indicator
                get $out_cmp_src_ind       from  comparray2 (#old_comp_idx) cp_cmp_src_ind
                get #out_Convert_Comprate  from  comparray2 (#old_comp_idx) cp_convert_comprt

                ! ***** amounts are set to 0
                let #out_comp_change_amt = 0
                let #out_comp_change_pct = 0
                let #out_comp_change_pts = 0

                !****** Create a copy of Compensation record for new job
                do INSERT-NEW-COMP-REC

        end-if

        !*** For the next loop make sure we dont search entries we have already searched
        let #start_find_idx = #old_comp_idx

    end-while


end-procedure


!***********************************************************************
! Procedure: INSERT-NEW-COMP-REC                                       *
! Descr:     Inserts a new record into the application table           *
!            PS_BP_COMPENSATION.  This procedure is performed multiple    *
!            times per single JOB row insert.                          *
!                                                                      *
! Called by: GET-STEPS                                                 *
!***********************************************************************
begin-procedure INSERT-NEW-COMP-REC

#DEBUGY display 'inserting new compensation record'
let $SQL-Statement = 'CMP107.SQR, INSERT-NEW-COMP-REC'

if isnull($out_Rate_Code_Group)
    let $out_Rate_Code_Group = ' '
end-if

#debugy display $new_JobRec_effdt
#debugy display #out_Comp_Effseq
#debugy display $out_Comp_Ratecd
#debugy display #out_Comprate
#debugy display #out_Comp_Pct
#debugy display $out_Comp_Frequency
#debugy display $out_Currency_Cd
#debugy display $out_Rate_Code_Group
#debugy display $out_Fte_Indicator

begin-SQL on-error=SQL-Error

INSERT INTO PS_BP_COMPENSATION
( EMPLID
, EMPL_RCD
, EFFDT
, EFFSEQ
, COMP_EFFSEQ
, COMP_RATECD
, COMP_RATE_POINTS
, COMPRATE
, COMP_PCT
, COMP_FREQUENCY
, CURRENCY_CD
, MANUAL_SW
, CONVERT_COMPRT
, RATE_CODE_GROUP
, CHANGE_AMT
, CHANGE_PCT
, CHANGE_PTS
, FTE_INDICATOR
, CMP_SRC_IND  )
VALUES
( $EmplID
, #Empl_Rcd
, $new_JobRec_effdt
, #new_JobRec_effseq
, #out_Comp_Effseq
, $out_Comp_Ratecd
, #out_Comp_Rate_Points
, #out_Comprate
, #out_Comp_Pct
, $out_Comp_Frequency
, $out_Currency_Cd
, $out_Manual_Sw
, #out_Convert_Comprate
, $out_Rate_Code_Group
, #out_comp_change_amt
, #out_comp_change_pct
, #out_comp_change_pts
, $out_Fte_Indicator
, $out_cmp_src_ind  )
end-SQL

end-procedure !INSERT-NEW-COMP-REC
!***********************************************************************
! Procedure: INSERT-NEW-JOBDIST-REC                                    *
! Descr:     An employee has just quialified for a step increase, use  *
!            insert a copy of the original BP JOB EARNS DIST only this one*
!            is related to the BP JOB row we just inserted                *
!                                                                      *
! Called by: PROCESS-EMPS                                              *
!***********************************************************************
begin-procedure Insert-New-JobDist-Rec
!***********************************************************************

#DEBUGY display 'Insert-New-JobDist-Rec'

let $SQL-Statement = 'BPCMP107.SQR, Insert-New-JobDist-Rec'
begin-SQL on-error=SQL-Error

INSERT INTO PS_BP_JOB_ERN_DIST
(EMPLID,
 EMPL_RCD,
 EFFDT,
 EFFSEQ,
 DEPTID,
 JOBCODE,
 POSITION_NBR,
 GL_PAY_TYPE,
 ACCT_CD,
 SHIFT,
 LOCATION,
 ERNCD,
 COMPRATE,
 DIST_PCT,
 STD_HOURS,
 BUSINESS_UNIT)
VALUES
(&J.EmplID,
 &J.Empl_Rcd,
 $new_JobRec_effdt,
 #new_JobRec_effseq,
 &J.DeptID,
 &J.JobCode,
 &J.Position_Nbr,
 &J.GL_Pay_Type,
 &J.Acct_CD,
 &J.Shift,
 &J.Location,
 &J.Erncd,
 #New_Job_Comprate,
 &J.Dist_Pct,
 &J.Std_Hours,
 &J.Business_Unit)
end-SQL
end-procedure


!***********************************************************************
begin-Procedure Refresh-Employee
!***********************************************************************

display 'refresh-employee'
let $SQL-Statement = 'BPCMP107.SQR, Refresh Job: Delete-Employee'
begin-SQL on-error=SQL-Error
DELETE FROM PS_BP_JOB
WHERE EMPLID = &A.EMPLID
  AND EMPL_RCD = &A.EMPL_RCD
  AND EFFDT >= {DateIn-Prefix}&A.EFFDT{DateIn-Suffix}
end-SQL

let $SQL-Statement = 'BPCMP107.SQR, Refresh Job: Insert-Employee'
begin-SQL on-error=SQL-Error
INSERT INTO PS_BP_JOB 
(EMPLID
,EMPL_RCD
,EFFDT
,EFFSEQ
,DEPTID
,JOBCODE
,POSITION_NBR
,APPT_TYPE
,MAIN_APPT_NUM_JPN
,POSITION_OVERRIDE
,POSN_CHANGE_RECORD
,EMPL_STATUS
,ACTION
,ACTION_DT
,ACTION_REASON
,LOCATION
,TAX_LOCATION_CD
,JOB_ENTRY_DT
,DEPT_ENTRY_DT
,POSITION_ENTRY_DT
,SHIFT
,REG_TEMP
,FULL_PART_TIME
,COMPANY
,PAYGROUP
,BAS_GROUP_ID
,ELIG_CONFIG1
,ELIG_CONFIG2
,ELIG_CONFIG3
,ELIG_CONFIG4
,ELIG_CONFIG5
,ELIG_CONFIG6
,ELIG_CONFIG7
,ELIG_CONFIG8
,ELIG_CONFIG9
,BEN_STATUS
,BAS_ACTION
,COBRA_ACTION
,EMPL_TYPE
,HOLIDAY_SCHEDULE
,STD_HOURS
,STD_HRS_FREQUENCY
,OFFICER_CD
,EMPL_CLASS
,SAL_ADMIN_PLAN
,GRADE
,GRADE_ENTRY_DT
,STEP
,STEP_ENTRY_DT
,GL_PAY_TYPE
,ACCT_CD
,EARNS_DIST_TYPE
,COMP_FREQUENCY
,COMPRATE
,CHANGE_AMT
,CHANGE_PCT
,ANNUAL_RT
,MONTHLY_RT
,DAILY_RT
,HOURLY_RT
,ANNL_BENEF_BASE_RT
,SHIFT_RT
,SHIFT_FACTOR
,CURRENCY_CD
,BUSINESS_UNIT
,SETID_DEPT
,SETID_JOBCODE
,SETID_LOCATION
,SETID_SALARY
,REG_REGION
,DIRECTLY_TIPPED
,FLSA_STATUS
,EEO_CLASS
,FUNCTION_CD
,TARIFF_GER
,TARIFF_AREA_GER
,PERFORM_GROUP_GER
,LABOR_TYPE_GER
,SPK_COMM_ID_GER
,HOURLY_RT_FRA
,ACCDNT_CD_FRA
,VALUE_1_FRA
,VALUE_2_FRA
,VALUE_3_FRA
,VALUE_4_FRA
,VALUE_5_FRA
,CTG_RATE
,PAID_HOURS
,PAID_FTE
,PAID_HRS_FREQUENCY
,GVT_EFFDT
,GVT_EFFDT_PROPOSED
,GVT_TRANS_NBR
,GVT_TRANS_NBR_SEQ
,GVT_WIP_STATUS
,GVT_STATUS_TYPE
,GVT_NOA_CODE
,GVT_LEG_AUTH_1
,GVT_PAR_AUTH_D1
,GVT_PAR_AUTH_D1_2
,GVT_LEG_AUTH_2
,GVT_PAR_AUTH_D2
,GVT_PAR_AUTH_D2_2
,GVT_PAR_NTE_DATE
,GVT_WORK_SCHED
,GVT_SUB_AGENCY
,GVT_ELIG_FEHB
,GVT_FEHB_DT
,GVT_PAY_RATE_DETER
,GVT_STEP
,GVT_RTND_PAY_PLAN
,GVT_RTND_SAL_PLAN
,GVT_RTND_GRADE
,GVT_RTND_STEP
,GVT_RTND_GVT_STEP
,GVT_PAY_BASIS
,GVT_COMPRATE
,GVT_LOCALITY_ADJ
,GVT_BIWEEKLY_RT
,GVT_DAILY_RT
,GVT_HRLY_RT_NO_LOC
,GVT_DLY_RT_NO_LOC
,GVT_BW_RT_NO_LOC
,GVT_MNLY_RT_NO_LOC
,GVT_ANNL_RT_NO_LOC
,GVT_XFER_FROM_AGCY
,GVT_XFER_TO_AGCY
,GVT_RETIRE_PLAN
,GVT_ANN_IND
,GVT_FEGLI
,GVT_FEGLI_LIVING
,GVT_LIVING_AMT
,GVT_ANNUITY_OFFSET
,GVT_CSRS_FROZN_SVC
,GVT_PREV_RET_COVRG
,GVT_FERS_COVERAGE
,GVT_TYPE_OF_APPT
,GVT_POI
,GVT_POSN_OCCUPIED
,GVT_CONT_EMPLID
,GVT_ROUTE_NEXT
,GVT_CHANGE_FLAG
,GVT_TSP_UPD_IND
,GVT_PI_UPD_IND
,GVT_SF52_NBR
,GVT_S113G_CEILING
,GVT_LEO_POSITION
,GVT_ANNUIT_COM_DT
,GVT_BASIC_LIFE_RED
,GVT_DED_PRORT_DT
,GVT_FEGLI_BASC_PCT
,GVT_FEGLI_OPT_PCT
,GVT_FEHB_PCT
,GVT_RETRO_FLAG
,GVT_RETRO_DED_FLAG
,GVT_RETRO_JOB_FLAG
,GVT_RETRO_BSE_FLAG
,GVT_OTH_PAY_CHG
,GVT_DETL_POSN_NBR
,ANNL_BEN_BASE_OVRD
,BENEFIT_PROGRAM
,UPDATE_PAYROLL
,GVT_PAY_PLAN
,GVT_PAY_FLAG
,GVT_NID_CHANGE
,UNION_FULL_PART
,UNION_POS
,MATRICULA_NBR
,SOC_SEC_RISK_CODE
,UNION_FEE_AMOUNT
,UNION_FEE_START_DT
,UNION_FEE_END_DT
,EXEMPT_JOB_LBR
,EXEMPT_HOURS_MONTH
,WRKS_CNCL_FUNCTION
,INTERCTR_WRKS_CNCL
,CURRENCY_CD1
,PAY_UNION_FEE
,UNION_CD
,BARG_UNIT
,UNION_SENIORITY_DT
,ENTRY_DATE
,LABOR_AGREEMENT
,EMPL_CTG
,EMPL_CTG_L1
,EMPL_CTG_L2
,SETID_LBR_AGRMNT
,GP_PAYGROUP
,GP_DFLT_ELIG_GRP
,GP_ELIG_GRP
,GP_DFLT_CURRTTYP
,CUR_RT_TYPE
,GP_DFLT_EXRTDT
,GP_ASOF_DT_EXG_RT
,ADDS_TO_FTE_ACTUAL
,CLASS_INDC
,ENCUMB_OVERRIDE
,FICA_STATUS_EE
,FTE
,PRORATE_CNT_AMT
,PAY_SYSTEM_FLG
,BORDER_WALKER
,LUMP_SUM_PAY
,CONTRACT_NUM
,JOB_INDICATOR
,WRKS_CNCL_ROLE_CHE
,BENEFIT_SYSTEM
,WORK_DAY_HOURS
,SUPERVISOR_ID
,REPORTS_TO
,FORCE_PUBLISH
,JOB_DATA_SRC_CD
,ESTABID
,WPP_STOP_FLAG
,LABOR_FACILITY_ID
,LBR_FAC_ENTRY_DT
,LAYOFF_EXEMPT_FLAG
,LAYOFF_EXEMPT_RSN)

SELECT
 EMPLID
,EMPL_RCD
,EFFDT
,EFFSEQ
,DEPTID
,JOBCODE
,POSITION_NBR
,APPT_TYPE
,MAIN_APPT_NUM_JPN
,POSITION_OVERRIDE
,POSN_CHANGE_RECORD
,EMPL_STATUS
,ACTION
,ACTION_DT
,ACTION_REASON
,LOCATION
,TAX_LOCATION_CD
,JOB_ENTRY_DT
,DEPT_ENTRY_DT
,POSITION_ENTRY_DT
,SHIFT
,REG_TEMP
,FULL_PART_TIME
,COMPANY
,PAYGROUP
,BAS_GROUP_ID
,ELIG_CONFIG1
,ELIG_CONFIG2
,ELIG_CONFIG3
,ELIG_CONFIG4
,ELIG_CONFIG5
,ELIG_CONFIG6
,ELIG_CONFIG7
,ELIG_CONFIG8
,ELIG_CONFIG9
,BEN_STATUS
,BAS_ACTION
,COBRA_ACTION
,EMPL_TYPE
,HOLIDAY_SCHEDULE
,STD_HOURS
,STD_HRS_FREQUENCY
,OFFICER_CD
,EMPL_CLASS
,SAL_ADMIN_PLAN
,GRADE
,GRADE_ENTRY_DT
,STEP
,STEP_ENTRY_DT
,GL_PAY_TYPE
,ACCT_CD
,EARNS_DIST_TYPE
,COMP_FREQUENCY
,COMPRATE
,CHANGE_AMT
,CHANGE_PCT
,ANNUAL_RT
,MONTHLY_RT
,DAILY_RT
,HOURLY_RT
,ANNL_BENEF_BASE_RT
,SHIFT_RT
,SHIFT_FACTOR
,CURRENCY_CD
,BUSINESS_UNIT
,SETID_DEPT
,SETID_JOBCODE
,SETID_LOCATION
,SETID_SALARY
,REG_REGION
,DIRECTLY_TIPPED
,FLSA_STATUS
,EEO_CLASS
,FUNCTION_CD
,TARIFF_GER
,TARIFF_AREA_GER
,PERFORM_GROUP_GER
,LABOR_TYPE_GER
,SPK_COMM_ID_GER
,HOURLY_RT_FRA
,ACCDNT_CD_FRA
,VALUE_1_FRA
,VALUE_2_FRA
,VALUE_3_FRA
,VALUE_4_FRA
,VALUE_5_FRA
,CTG_RATE
,PAID_HOURS
,PAID_FTE
,PAID_HRS_FREQUENCY
,DB2_NULL_DT
,DB2_NULL_DT
,0
,0
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,DB2_NULL_DT
,' '
,' '
,' '
,DB2_NULL_DT
,' '
,' '
,' '
,' '
,' '
,0
,' '
,' '
,0
,0
,0
,0
,0
,0
,0
,0
,0
,' '
,' '
,' '
,' '
,' '
,' '
,0
,0
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,DB2_NULL_DT
,' '
,DB2_NULL_DT
,0
,0
,0
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,UNION_FULL_PART
,UNION_POS
,MATRICULA_NBR
,SOC_SEC_RISK_CODE
,UNION_FEE_AMOUNT
,UNION_FEE_START_DT
,UNION_FEE_END_DT
,EXEMPT_JOB_LBR
,EXEMPT_HOURS_MONTH
,WRKS_CNCL_FUNCTION
,INTERCTR_WRKS_CNCL
,CURRENCY_CD1
,PAY_UNION_FEE
,UNION_CD
,BARG_UNIT
,UNION_SENIORITY_DT
,ENTRY_DATE
,LABOR_AGREEMENT
,EMPL_CTG
,EMPL_CTG_L1
,EMPL_CTG_L2
,SETID_LBR_AGRMNT
,GP_PAYGROUP
,GP_DFLT_ELIG_GRP
,GP_ELIG_GRP
,GP_DFLT_CURRTTYP
,CUR_RT_TYPE
,GP_DFLT_EXRTDT
,GP_ASOF_DT_EXG_RT
,ADDS_TO_FTE_ACTUAL
,CLASS_INDC
,ENCUMB_OVERRIDE
,FICA_STATUS_EE
,FTE
,PRORATE_CNT_AMT
,PAY_SYSTEM_FLG
,BORDER_WALKER
,LUMP_SUM_PAY
,CONTRACT_NUM
,JOB_INDICATOR
,WRKS_CNCL_ROLE_CHE
,BENEFIT_SYSTEM
,WORK_DAY_HOURS
,SUPERVISOR_ID
,REPORTS_TO
,FORCE_PUBLISH
,JOB_DATA_SRC_CD
,ESTABID
,' '
,' '
,DB2_NULL_DT
,' '
,' '
FROM PS_JOB, PS_DB2_NULL_FLDS
WHERE EMPLID = &A.EMPLID
  AND EMPL_RCD = &A.EMPL_RCD
  AND EFFDT >= {DateIn-Prefix}&A.EFFDT{DateIn-Suffix}
end-SQL

end-procedure

!***********************************************************************
begin-Procedure Refresh-Emp-Compensation
!***********************************************************************
let $SQL-Statement = 'BPCMP107.SQR, Refresh-Emp-Compensation: Delete-Compensation'

if $SetGrade = 'Y'
    let $bpc_emplid = &A.EMPLID
    let #bpc_empl_rcd = &A.EMPL_RCD
    let $bpc_effdt = &A.EFFDT
else
    let $bpc_emplid = &BPC.EMPLID
    let #bpc_empl_rcd = &BPC.EMPL_RCD
    let $bpc_effdt = &BPC.EFFDT
end-if

begin-SQL on-error=SQL-Error
DELETE FROM PS_BP_COMPENSATION
WHERE EMPLID = $bpc_emplid
  AND EMPL_RCD = #bpc_empl_rcd
  AND EFFDT >= {DateIn-Prefix}$bpc_effdt{DateIn-Suffix}
end-SQL

let $SQL-Statement = 'BPCMP107.SQR, Refresh-Emp-Compensation: Insert-Compensation'
begin-SQL on-error=SQL-Error
INSERT INTO PS_BP_COMPENSATION
( EMPLID
, EMPL_RCD
, EFFDT
, EFFSEQ
, COMP_EFFSEQ
, COMP_RATECD
, COMP_RATE_POINTS
, COMPRATE
, COMP_PCT
, COMP_FREQUENCY
, CURRENCY_CD
, MANUAL_SW
, CONVERT_COMPRT
, RATE_CODE_GROUP
, CHANGE_AMT
, CHANGE_PCT
, CHANGE_PTS
, FTE_INDICATOR
, CMP_SRC_IND  )
SELECT
EMPLID
, EMPL_RCD
, EFFDT
, EFFSEQ
, COMP_EFFSEQ
, COMP_RATECD
, COMP_RATE_POINTS
, COMPRATE
, COMP_PCT
, COMP_FREQUENCY
, CURRENCY_CD
, MANUAL_SW
, CONVERT_COMPRT
, RATE_CODE_GROUP
, CHANGE_AMT
, CHANGE_PCT
, CHANGE_PTS
, FTE_INDICATOR
, CMP_SRC_IND
FROM
PS_COMPENSATION
WHERE EMPLID = $bpc_emplid
  AND EMPL_RCD = #bpc_empl_rcd
  AND EFFDT >= {DateIn-Prefix}$bpc_effdt{DateIn-Suffix}
end-SQL

end-procedure Refresh-Emp-Compensation
!***********************************************************************
begin-Procedure Refresh-Job
!***********************************************************************
!For all employees within the Sal Plan

#DEBUGY display $SalPlan

let $SQL-Statement = 'BPCMP107.SQR, Refresh Job: Delete-Job'
begin-SQL on-error=SQL-Error
DELETE FROM PS_BP_JOB
WHERE SAL_ADMIN_PLAN = $SalPlan
!  AND GRADE [$Grade_Parm]
end-SQL

let $SQL-Statement = 'BPCMP107.SQR, Refresh Job: Insert-Job'
begin-SQL on-error=SQL-Error
INSERT INTO PS_BP_JOB (EMPLID
,EMPL_RCD
,EFFDT
,EFFSEQ
,DEPTID
,JOBCODE
,POSITION_NBR
,APPT_TYPE
,MAIN_APPT_NUM_JPN
,POSITION_OVERRIDE
,POSN_CHANGE_RECORD
,EMPL_STATUS
,ACTION
,ACTION_DT
,ACTION_REASON
,LOCATION
,TAX_LOCATION_CD
,JOB_ENTRY_DT
,DEPT_ENTRY_DT
,POSITION_ENTRY_DT
,SHIFT
,REG_TEMP
,FULL_PART_TIME
,COMPANY
,PAYGROUP
,BAS_GROUP_ID
,ELIG_CONFIG1
,ELIG_CONFIG2
,ELIG_CONFIG3
,ELIG_CONFIG4
,ELIG_CONFIG5
,ELIG_CONFIG6
,ELIG_CONFIG7
,ELIG_CONFIG8
,ELIG_CONFIG9
,BEN_STATUS
,BAS_ACTION
,COBRA_ACTION
,EMPL_TYPE
,HOLIDAY_SCHEDULE
,STD_HOURS
,STD_HRS_FREQUENCY
,OFFICER_CD
,EMPL_CLASS
,SAL_ADMIN_PLAN
,GRADE
,GRADE_ENTRY_DT
,STEP
,STEP_ENTRY_DT
,GL_PAY_TYPE
,ACCT_CD
,EARNS_DIST_TYPE
,COMP_FREQUENCY
,COMPRATE
,CHANGE_AMT
,CHANGE_PCT
,ANNUAL_RT
,MONTHLY_RT
,DAILY_RT
,HOURLY_RT
,ANNL_BENEF_BASE_RT
,SHIFT_RT
,SHIFT_FACTOR
,CURRENCY_CD
,BUSINESS_UNIT
,SETID_DEPT
,SETID_JOBCODE
,SETID_LOCATION
,SETID_SALARY
,REG_REGION
,DIRECTLY_TIPPED
,FLSA_STATUS
,EEO_CLASS
,FUNCTION_CD
,TARIFF_GER
,TARIFF_AREA_GER
,PERFORM_GROUP_GER
,LABOR_TYPE_GER
,SPK_COMM_ID_GER
,HOURLY_RT_FRA
,ACCDNT_CD_FRA
,VALUE_1_FRA
,VALUE_2_FRA
,VALUE_3_FRA
,VALUE_4_FRA
,VALUE_5_FRA
,CTG_RATE
,PAID_HOURS
,PAID_FTE
,PAID_HRS_FREQUENCY
,GVT_EFFDT
,GVT_EFFDT_PROPOSED
,GVT_TRANS_NBR
,GVT_TRANS_NBR_SEQ
,GVT_WIP_STATUS
,GVT_STATUS_TYPE
,GVT_NOA_CODE
,GVT_LEG_AUTH_1
,GVT_PAR_AUTH_D1
,GVT_PAR_AUTH_D1_2
,GVT_LEG_AUTH_2
,GVT_PAR_AUTH_D2
,GVT_PAR_AUTH_D2_2
,GVT_PAR_NTE_DATE
,GVT_WORK_SCHED
,GVT_SUB_AGENCY
,GVT_ELIG_FEHB
,GVT_FEHB_DT
,GVT_PAY_RATE_DETER
,GVT_STEP
,GVT_RTND_PAY_PLAN
,GVT_RTND_SAL_PLAN
,GVT_RTND_GRADE
,GVT_RTND_STEP
,GVT_RTND_GVT_STEP
,GVT_PAY_BASIS
,GVT_COMPRATE
,GVT_LOCALITY_ADJ
,GVT_BIWEEKLY_RT
,GVT_DAILY_RT
,GVT_HRLY_RT_NO_LOC
,GVT_DLY_RT_NO_LOC
,GVT_BW_RT_NO_LOC
,GVT_MNLY_RT_NO_LOC
,GVT_ANNL_RT_NO_LOC
,GVT_XFER_FROM_AGCY
,GVT_XFER_TO_AGCY
,GVT_RETIRE_PLAN
,GVT_ANN_IND
,GVT_FEGLI
,GVT_FEGLI_LIVING
,GVT_LIVING_AMT
,GVT_ANNUITY_OFFSET
,GVT_CSRS_FROZN_SVC
,GVT_PREV_RET_COVRG
,GVT_FERS_COVERAGE
,GVT_TYPE_OF_APPT
,GVT_POI
,GVT_POSN_OCCUPIED
,GVT_CONT_EMPLID
,GVT_ROUTE_NEXT
,GVT_CHANGE_FLAG
,GVT_TSP_UPD_IND
,GVT_PI_UPD_IND
,GVT_SF52_NBR
,GVT_S113G_CEILING
,GVT_LEO_POSITION
,GVT_ANNUIT_COM_DT
,GVT_BASIC_LIFE_RED
,GVT_DED_PRORT_DT
,GVT_FEGLI_BASC_PCT
,GVT_FEGLI_OPT_PCT
,GVT_FEHB_PCT
,GVT_RETRO_FLAG
,GVT_RETRO_DED_FLAG
,GVT_RETRO_JOB_FLAG
,GVT_RETRO_BSE_FLAG
,GVT_OTH_PAY_CHG
,GVT_DETL_POSN_NBR
,ANNL_BEN_BASE_OVRD
,BENEFIT_PROGRAM
,UPDATE_PAYROLL
,GVT_PAY_PLAN
,GVT_PAY_FLAG
,GVT_NID_CHANGE
,UNION_FULL_PART
,UNION_POS
,MATRICULA_NBR
,SOC_SEC_RISK_CODE
,UNION_FEE_AMOUNT
,UNION_FEE_START_DT
,UNION_FEE_END_DT
,EXEMPT_JOB_LBR
,EXEMPT_HOURS_MONTH
,WRKS_CNCL_FUNCTION
,INTERCTR_WRKS_CNCL
,CURRENCY_CD1
,PAY_UNION_FEE
,UNION_CD
,BARG_UNIT
,UNION_SENIORITY_DT
,ENTRY_DATE
,LABOR_AGREEMENT
,EMPL_CTG
,EMPL_CTG_L1
,EMPL_CTG_L2
,SETID_LBR_AGRMNT
,GP_PAYGROUP
,GP_DFLT_ELIG_GRP
,GP_ELIG_GRP
,GP_DFLT_CURRTTYP
,CUR_RT_TYPE
,GP_DFLT_EXRTDT
,GP_ASOF_DT_EXG_RT
,ADDS_TO_FTE_ACTUAL
,CLASS_INDC
,ENCUMB_OVERRIDE
,FICA_STATUS_EE
,FTE
,PRORATE_CNT_AMT
,PAY_SYSTEM_FLG
,BORDER_WALKER
,LUMP_SUM_PAY
,CONTRACT_NUM
,JOB_INDICATOR
,WRKS_CNCL_ROLE_CHE
,BENEFIT_SYSTEM
,WORK_DAY_HOURS
,SUPERVISOR_ID
,REPORTS_TO
,FORCE_PUBLISH
,JOB_DATA_SRC_CD
,ESTABID
,WPP_STOP_FLAG
,LABOR_FACILITY_ID
,LBR_FAC_ENTRY_DT
,LAYOFF_EXEMPT_FLAG
,LAYOFF_EXEMPT_RSN)

SELECT EMPLID
,EMPL_RCD
,EFFDT
,EFFSEQ
,DEPTID
,JOBCODE
,POSITION_NBR
,APPT_TYPE
,MAIN_APPT_NUM_JPN
,POSITION_OVERRIDE
,POSN_CHANGE_RECORD
,EMPL_STATUS
,ACTION
,ACTION_DT
,ACTION_REASON
,LOCATION
,TAX_LOCATION_CD
,JOB_ENTRY_DT
,DEPT_ENTRY_DT
,POSITION_ENTRY_DT
,SHIFT
,REG_TEMP
,FULL_PART_TIME
,COMPANY
,PAYGROUP
,BAS_GROUP_ID
,ELIG_CONFIG1
,ELIG_CONFIG2
,ELIG_CONFIG3
,ELIG_CONFIG4
,ELIG_CONFIG5
,ELIG_CONFIG6
,ELIG_CONFIG7
,ELIG_CONFIG8
,ELIG_CONFIG9
,BEN_STATUS
,BAS_ACTION
,COBRA_ACTION
,EMPL_TYPE
,HOLIDAY_SCHEDULE
,STD_HOURS
,STD_HRS_FREQUENCY
,OFFICER_CD
,EMPL_CLASS
,SAL_ADMIN_PLAN
,GRADE
,GRADE_ENTRY_DT
,STEP
,STEP_ENTRY_DT
,GL_PAY_TYPE
,ACCT_CD
,EARNS_DIST_TYPE
,COMP_FREQUENCY
,COMPRATE
,CHANGE_AMT
,CHANGE_PCT
,ANNUAL_RT
,MONTHLY_RT
,DAILY_RT
,HOURLY_RT
,ANNL_BENEF_BASE_RT
,SHIFT_RT
,SHIFT_FACTOR
,CURRENCY_CD
,BUSINESS_UNIT
,SETID_DEPT
,SETID_JOBCODE
,SETID_LOCATION
,SETID_SALARY
,REG_REGION
,DIRECTLY_TIPPED
,FLSA_STATUS
,EEO_CLASS
,FUNCTION_CD
,TARIFF_GER
,TARIFF_AREA_GER
,PERFORM_GROUP_GER
,LABOR_TYPE_GER
,SPK_COMM_ID_GER
,HOURLY_RT_FRA
,ACCDNT_CD_FRA
,VALUE_1_FRA
,VALUE_2_FRA
,VALUE_3_FRA
,VALUE_4_FRA
,VALUE_5_FRA
,CTG_RATE
,PAID_HOURS
,PAID_FTE
,PAID_HRS_FREQUENCY
,DB2_NULL_DT
,DB2_NULL_DT
,0
,0
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,DB2_NULL_DT
,' '
,' '
,' '
,DB2_NULL_DT
,' '
,' '
,' '
,' '
,' '
,0
,' '
,' '
,0
,0
,0
,0
,0
,0
,0
,0
,0
,' '
,' '
,' '
,' '
,' '
,' '
,0
,0
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,DB2_NULL_DT
,' '
,DB2_NULL_DT
,0
,0
,0
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,UNION_FULL_PART
,UNION_POS
,MATRICULA_NBR
,SOC_SEC_RISK_CODE
,UNION_FEE_AMOUNT
,UNION_FEE_START_DT
,UNION_FEE_END_DT
,EXEMPT_JOB_LBR
,EXEMPT_HOURS_MONTH
,WRKS_CNCL_FUNCTION
,INTERCTR_WRKS_CNCL
,CURRENCY_CD1
,PAY_UNION_FEE
,UNION_CD
,BARG_UNIT
,UNION_SENIORITY_DT
,ENTRY_DATE
,LABOR_AGREEMENT
,EMPL_CTG
,EMPL_CTG_L1
,EMPL_CTG_L2
,SETID_LBR_AGRMNT
,GP_PAYGROUP
,GP_DFLT_ELIG_GRP
,GP_ELIG_GRP
,GP_DFLT_CURRTTYP
,CUR_RT_TYPE
,GP_DFLT_EXRTDT
,GP_ASOF_DT_EXG_RT
,ADDS_TO_FTE_ACTUAL
,CLASS_INDC
,ENCUMB_OVERRIDE
,FICA_STATUS_EE
,FTE
,PRORATE_CNT_AMT
,PAY_SYSTEM_FLG
,BORDER_WALKER
,LUMP_SUM_PAY
,CONTRACT_NUM
,JOB_INDICATOR
,WRKS_CNCL_ROLE_CHE
,BENEFIT_SYSTEM
,WORK_DAY_HOURS
,SUPERVISOR_ID
,REPORTS_TO
,FORCE_PUBLISH
,JOB_DATA_SRC_CD
,ESTABID
,' '
,' '
,DB2_NULL_DT
,' '
,' '
FROM PS_JOB,PS_DB2_NULL_FLDS
WHERE SAL_ADMIN_PLAN = $SalPlan
!  AND GRADE [$Grade_Parm]
end-SQL
end-Procedure

!***********************************************************************
begin-Procedure Refresh-Job-Compensation
!***********************************************************************
!For all employees within the Sal Plan


begin-SELECT

BPC.EMPLID
BPC.EMPL_RCD
BPC.EFFDT

    #DEBUGY DISPLAY 'INSIDE refresh job compensation: ' NOLINE
    #debugy DISPLAY &BPC.EMPLID  NOLINE
    #debugy DISPLAY ' - '        NOLINE
    #debugy DISPLAY &BPC.EMPL_RCD   NOLINE
    #debugy DISPLAY ' - '        NOLINE
    #debugy DISPLAY &BPC.EFFDT

  do Refresh-Emp-Compensation

FROM  PS_JOB BPC
WHERE BPC.SAL_ADMIN_PLAN = $SalPlan
end-SELECT

end-Procedure

!***********************************************************************
begin-Procedure Refresh-JobDist-Rec
!***********************************************************************

let $SQL-Statement = 'BPCMP107.SQR, Refresh Job Earn: Delete-Job-Earn'
begin-SQL on-error=SQL-Error
DELETE FROM PS_BP_JOB_ERN_DIST
WHERE EMPLID = &A.EMPLID
  AND EMPL_RCD = &A.EMPL_RCD
end-SQL

   let $JobRefresh = 'N'

let $SQL-Statement = 'BPCMP107.SQR, Refresh Job Earn: Insert-Job-Earn'
begin-SQL on-error=SQL-Error
INSERT INTO PS_BP_JOB_ERN_DIST
(EMPLID,
 EMPL_RCD,
 EFFDT,
 EFFSEQ,
 DEPTID,
 JOBCODE,
 POSITION_NBR,
 GL_PAY_TYPE,
 ACCT_CD,
 SHIFT,
 LOCATION,
 ERNCD,
 COMPRATE,
 DIST_PCT,
 STD_HOURS,
 BUSINESS_UNIT)
SELECT
 EMPLID,
 EMPL_RCD,
 EFFDT,
 EFFSEQ,
 DEPTID,
 JOBCODE,
 POSITION_NBR,
 GL_PAY_TYPE,
 ACCT_CD,
 SHIFT,
 LOCATION,
 ERNCD,
 COMPRATE,
 DIST_PCT,
 STD_HOURS,
 BUSINESS_UNIT
FROM PS_JOB_EARNS_DIST
WHERE EMPLID = &A.EMPLID
  AND EMPL_RCD = &A.EMPL_RCD
end-SQL
end-Procedure


!***********************************************************************
begin-procedure Save-Current-Job-Fields
!***********************************************************************

Let $EMPLID                                     = &A.EMPLID
Let #EMPL_RCD                                   = &A.EMPL_RCD
Let $EFFDT                                      = &A.EFFDT
Let #EFFSEQ                                     = &A.EFFSEQ
Let $DEPTID                                     = &A.DEPTID
Let $JOBCODE                                    = &A.JOBCODE
Let $POSITION_NBR                               = &A.POSITION_NBR
Let $APPT_TYPE                                  = &A.APPT_TYPE
Let #MAIN_APPT_NUM_JPN                          = &A.MAIN_APPT_NUM_JPN
Let $POSITION_OVERRIDE                          = &A.POSITION_OVERRIDE
Let $POSN_CHANGE_RECORD                         = &A.POSN_CHANGE_RECORD
Let $EMPL_STATUS                                = &A.EMPL_STATUS
Let $ACTION                                     = &A.ACTION
Let $ACTION_DT                                  = &A.ACTION_DT
Let $ACTION_REASON                              = &A.ACTION_REASON
Let $LOCATION                                   = &A.LOCATION
Let $TAX_LOCATION_CD                            = &A.TAX_LOCATION_CD
Let $JOB_ENTRY_DT                               = &A.JOB_ENTRY_DT
Let $DEPT_ENTRY_DT                              = &A.DEPT_ENTRY_DT
Let $POSITION_ENTRY_DT                          = &A.POSITION_ENTRY_DT
Let $SHIFT                                      = &A.SHIFT
Let $REG_TEMP                                   = &A.REG_TEMP
Let $FULL_PART_TIME                             = &A.FULL_PART_TIME
Let $COMPANY                                    = &A.COMPANY
Let $PAYGROUP                                   = &A.PAYGROUP
Let $BAS_GROUP_ID                               = &A.BAS_GROUP_ID
Let $ELIG_CONFIG1                               = &A.ELIG_CONFIG1
Let $ELIG_CONFIG2                               = &A.ELIG_CONFIG2
Let $ELIG_CONFIG3                               = &A.ELIG_CONFIG3
Let $ELIG_CONFIG4                               = &A.ELIG_CONFIG4
Let $ELIG_CONFIG5                               = &A.ELIG_CONFIG5
Let $ELIG_CONFIG6                               = &A.ELIG_CONFIG6
Let $ELIG_CONFIG7                               = &A.ELIG_CONFIG7
Let $ELIG_CONFIG8                               = &A.ELIG_CONFIG8
Let $ELIG_CONFIG9                               = &A.ELIG_CONFIG9
Let $BEN_STATUS                                 = &A.BEN_STATUS
Let $BAS_ACTION                                 = &A.BAS_ACTION
Let $COBRA_ACTION                               = &A.COBRA_ACTION
Let $EMPL_TYPE                                  = &A.EMPL_TYPE
Let $HOLIDAY_SCHEDULE                           = &A.HOLIDAY_SCHEDULE
Let #STD_HOURS                                  = &A.STD_HOURS
Let $STD_HRS_FREQUENCY                          = &A.STD_HRS_FREQUENCY
Let $OFFICER_CD                                 = &A.OFFICER_CD
Let $EMPL_CLASS                                 = &A.EMPL_CLASS
Let $SAL_ADMIN_PLAN                             = &A.SAL_ADMIN_PLAN
Let $GRADE                                      = &A.GRADE
Let $GRADE_ENTRY_DT                             = &A.GRADE_ENTRY_DT
Let #STEP                                       = &A.STEP
Let $STEP_ENTRY_DT                              = &A.STEP_ENTRY_DT
Let $GL_PAY_TYPE                                = &A.GL_PAY_TYPE
Let $ACCT_CD                                    = &A.ACCT_CD
Let $EARNS_DIST_TYPE                            = &A.EARNS_DIST_TYPE
Let $COMP_FREQUENCY                             = &A.COMP_FREQUENCY
Let #COMPRATE                                   = &A.COMPRATE
Let #CHANGE_AMT                                 = &A.CHANGE_AMT
Let #CHANGE_PCT                                 = &A.CHANGE_PCT
Let #ANNUAL_RT                                  = &A.ANNUAL_RT
Let #MONTHLY_RT                                 = &A.MONTHLY_RT
Let #DAILY_RT                                   = &A.DAILY_RT
Let #HOURLY_RT                                  = &A.HOURLY_RT
Let #ANNL_BENEF_BASE_RT                         = &A.ANNL_BENEF_BASE_RT
Let #SHIFT_RT                                   = &A.SHIFT_RT
Let #SHIFT_FACTOR                               = &A.SHIFT_FACTOR
Let $CURRENCY_CD                                = &A.CURRENCY_CD
Let $BUSINESS_UNIT                              = &A.BUSINESS_UNIT
Let $SETID_DEPT                                 = &A.SETID_DEPT
Let $SETID_JOBCODE                              = &A.SETID_JOBCODE
Let $SETID_LOCATION                             = &A.SETID_LOCATION
Let $SETID_SALARY                               = &A.SETID_SALARY
Let $REG_REGION                                 = &A.REG_REGION
Let $DIRECTLY_TIPPED                            = &A.DIRECTLY_TIPPED
Let $FLSA_STATUS                                = &A.FLSA_STATUS
Let $EEO_CLASS                                  = &A.EEO_CLASS
Let $FUNCTION_CD                                = &A.FUNCTION_CD
Let $TARIFF_GER                                 = &A.TARIFF_GER
Let $TARIFF_AREA_GER                            = &A.TARIFF_AREA_GER
Let $PERFORM_GROUP_GER                          = &A.PERFORM_GROUP_GER
Let $LABOR_TYPE_GER                             = &A.LABOR_TYPE_GER
Let $SPK_COMM_ID_GER                            = &A.SPK_COMM_ID_GER
Let $HOURLY_RT_FRA                              = &A.HOURLY_RT_FRA
Let $ACCDNT_CD_FRA                              = &A.ACCDNT_CD_FRA
Let $VALUE_1_FRA                                = &A.VALUE_1_FRA
Let $VALUE_2_FRA                                = &A.VALUE_2_FRA
Let $VALUE_3_FRA                                = &A.VALUE_3_FRA
Let $VALUE_4_FRA                                = &A.VALUE_4_FRA
Let $VALUE_5_FRA                                = &A.VALUE_5_FRA
Let #CTG_RATE                                   = &A.CTG_RATE
Let #PAID_HOURS                                 = &A.PAID_HOURS
Let #PAID_FTE                                   = &A.PAID_FTE
Let $PAID_HRS_FREQUENCY                         = &A.PAID_HRS_FREQUENCY
Let $UNION_FULL_PART                            = &A.UNION_FULL_PART
Let $UNION_POS                                  = &A.UNION_POS
Let #MATRICULA_NBR                              = &A.MATRICULA_NBR
Let $SOC_SEC_RISK_CODE                          = &A.SOC_SEC_RISK_CODE
Let #UNION_FEE_AMOUNT                           = &A.UNION_FEE_AMOUNT
Let $UNION_FEE_START_DT                         = &A.UNION_FEE_START_DT
Let $UNION_FEE_END_DT                           = &A.UNION_FEE_END_DT
Let $EXEMPT_JOB_LBR                             = &A.EXEMPT_JOB_LBR
Let #EXEMPT_HOURS_MONTH                         = &A.EXEMPT_HOURS_MONTH
Let $WRKS_CNCL_FUNCTION                         = &A.WRKS_CNCL_FUNCTION
Let $INTERCTR_WRKS_CNCL                         = &A.INTERCTR_WRKS_CNCL
Let $CURRENCY_CD1                               = &A.CURRENCY_CD1
Let $PAY_UNION_FEE                              = &A.PAY_UNION_FEE
Let $UNION_CD                                   = &A.UNION_CD
Let $BARG_UNIT                                  = &A.BARG_UNIT
Let $UNION_SENIORITY_DT                         = &A.UNION_SENIORITY_DT
Let $ENTRY_DATE                                 = &A.ENTRY_DATE
Let $LABOR_AGREEMENT                            = &A.LABOR_AGREEMENT
Let $EMPL_CTG                                   = &A.EMPL_CTG
Let $EMPL_CTG_L1                                = &A.EMPL_CTG_L1
Let $EMPL_CTG_L2                                = &A.EMPL_CTG_L2
Let $SETID_LBR_AGRMNT                           = &A.SETID_LBR_AGRMNT
Let $GP_PAYGROUP                                = &A.GP_PAYGROUP
Let $GP_DFLT_ELIG_GRP                           = &A.GP_DFLT_ELIG_GRP
Let $GP_ELIG_GRP                                = &A.GP_ELIG_GRP
Let $GP_DFLT_CURRTTYP                           = &A.GP_DFLT_CURRTTYP
Let $CUR_RT_TYPE                                = &A.CUR_RT_TYPE
Let $GP_DFLT_EXRTDT                             = &A.GP_DFLT_EXRTDT
Let $GP_ASOF_DT_EXG_RT                          = &A.GP_ASOF_DT_EXG_RT
Let $ADDS_TO_FTE_ACTUAL                         = &A.ADDS_TO_FTE_ACTUAL
Let $CLASS_INDC                                 = &A.CLASS_INDC
Let $ENCUMB_OVERRIDE                            = &A.ENCUMB_OVERRIDE
Let $FICA_STATUS_EE                             = &A.FICA_STATUS_EE
Let #FTE                                        = &A.FTE
Let $PRORATE_CNT_AMT                            = &A.PRORATE_CNT_AMT
Let $PAY_SYSTEM_FLG                             = &A.PAY_SYSTEM_FLG
Let $BORDER_WALKER                              = &A.BORDER_WALKER
Let $LUMP_SUM_PAY                               = &A.LUMP_SUM_PAY
Let $CONTRACT_NUM                               = &A.CONTRACT_NUM
Let $JOB_INDICATOR                              = &A.JOB_INDICATOR
Let $WRKS_CNCL_ROLE_CHE                         = &A.WRKS_CNCL_ROLE_CHE
Let $BENEFIT_SYSTEM                             = &A.BENEFIT_SYSTEM
Let #WORK_DAY_HOURS                             = &A.WORK_DAY_HOURS
Let $SUPERVISOR_ID                              = &A.SUPERVISOR_ID
Let $REPORTS_TO                                 = &A.REPORTS_TO
Let $FORCE_PUBLISH                              = &A.FORCE_PUBLISH
Let $JOB_DATA_SRC_CD                            = &A.JOB_DATA_SRC_CD
Let $ESTABID                                    = &A.ESTABID
Let $NAME                                       = &B.NAME
Let $COUNTRY                                    = &P.COUNTRY
Let $FREQUENCY_TYPE                             = &F.FREQUENCY_TYPE

End-Procedure


!***********************************************************************
begin-procedure Save-Future-Job-Fields
!***********************************************************************

Let $EMPLID                                     = &A2.EMPLID
Let #EMPL_RCD                                   = &A2.EMPL_RCD
Let $EFFDT                                      = &A2.EFFDT
Let #EFFSEQ                                     = &A2.EFFSEQ
Let $DEPTID                                     = &A2.DEPTID
Let $JOBCODE                                    = &A2.JOBCODE
Let $POSITION_NBR                               = &A2.POSITION_NBR
Let $APPT_TYPE                                  = &A2.APPT_TYPE
Let #MAIN_APPT_NUM_JPN                          = &A2.MAIN_APPT_NUM_JPN
Let $POSITION_OVERRIDE                          = &A2.POSITION_OVERRIDE
Let $POSN_CHANGE_RECORD                         = &A2.POSN_CHANGE_RECORD
Let $EMPL_STATUS                                = &A2.EMPL_STATUS
Let $ACTION                                     = &A2.ACTION
Let $ACTION_DT                                  = &A2.ACTION_DT
Let $ACTION_REASON                              = &A2.ACTION_REASON
Let $LOCATION                                   = &A2.LOCATION
Let $TAX_LOCATION_CD                            = &A2.TAX_LOCATION_CD
Let $JOB_ENTRY_DT                               = &A2.JOB_ENTRY_DT
Let $DEPT_ENTRY_DT                              = &A2.DEPT_ENTRY_DT
Let $POSITION_ENTRY_DT                          = &A2.POSITION_ENTRY_DT
Let $SHIFT                                      = &A2.SHIFT
Let $REG_TEMP                                   = &A2.REG_TEMP
Let $FULL_PART_TIME                             = &A2.FULL_PART_TIME
Let $COMPANY                                    = &A2.COMPANY
Let $PAYGROUP                                   = &A2.PAYGROUP
Let $BAS_GROUP_ID                               = &A2.BAS_GROUP_ID
Let $ELIG_CONFIG1                               = &A2.ELIG_CONFIG1
Let $ELIG_CONFIG2                               = &A2.ELIG_CONFIG2
Let $ELIG_CONFIG3                               = &A2.ELIG_CONFIG3
Let $ELIG_CONFIG4                               = &A2.ELIG_CONFIG4
Let $ELIG_CONFIG5                               = &A2.ELIG_CONFIG5
Let $ELIG_CONFIG6                               = &A2.ELIG_CONFIG6
Let $ELIG_CONFIG7                               = &A2.ELIG_CONFIG7
Let $ELIG_CONFIG8                               = &A2.ELIG_CONFIG8
Let $ELIG_CONFIG9                               = &A2.ELIG_CONFIG9
Let $BEN_STATUS                                 = &A2.BEN_STATUS
Let $BAS_ACTION                                 = &A2.BAS_ACTION
Let $COBRA_ACTION                               = &A2.COBRA_ACTION
Let $EMPL_TYPE                                  = &A2.EMPL_TYPE
Let $HOLIDAY_SCHEDULE                           = &A2.HOLIDAY_SCHEDULE
Let #STD_HOURS                                  = &A2.STD_HOURS
Let $STD_HRS_FREQUENCY                          = &A2.STD_HRS_FREQUENCY
Let $OFFICER_CD                                 = &A2.OFFICER_CD
Let $EMPL_CLASS                                 = &A2.EMPL_CLASS
Let $SAL_ADMIN_PLAN                             = &A2.SAL_ADMIN_PLAN
Let $GRADE                                      = &A2.GRADE
Let $GRADE_ENTRY_DT                             = &A2.GRADE_ENTRY_DT
Let #STEP                                       = &A2.STEP
Let $STEP_ENTRY_DT                              = &A2.STEP_ENTRY_DT
Let $GL_PAY_TYPE                                = &A2.GL_PAY_TYPE
Let $ACCT_CD                                    = &A2.ACCT_CD
Let $EARNS_DIST_TYPE                            = &A2.EARNS_DIST_TYPE
Let $COMP_FREQUENCY                             = &A2.COMP_FREQUENCY
Let #COMPRATE                                   = &A2.COMPRATE
Let #CHANGE_AMT                                 = &A2.CHANGE_AMT
Let #CHANGE_PCT                                 = &A2.CHANGE_PCT
Let #ANNUAL_RT                                  = &A2.ANNUAL_RT
Let #MONTHLY_RT                                 = &A2.MONTHLY_RT
Let #DAILY_RT                                   = &A2.DAILY_RT
Let #HOURLY_RT                                  = &A2.HOURLY_RT
Let #ANNL_BENEF_BASE_RT                         = &A2.ANNL_BENEF_BASE_RT
Let #SHIFT_RT                                   = &A2.SHIFT_RT
Let #SHIFT_FACTOR                               = &A2.SHIFT_FACTOR
Let $CURRENCY_CD                                = &A2.CURRENCY_CD
Let $BUSINESS_UNIT                              = &A2.BUSINESS_UNIT
Let $SETID_DEPT                                 = &A2.SETID_DEPT
Let $SETID_JOBCODE                              = &A2.SETID_JOBCODE
Let $SETID_LOCATION                             = &A2.SETID_LOCATION
Let $SETID_SALARY                               = &A2.SETID_SALARY
Let $REG_REGION                                 = &A2.REG_REGION
Let $DIRECTLY_TIPPED                            = &A2.DIRECTLY_TIPPED
Let $FLSA_STATUS                                = &A2.FLSA_STATUS
Let $EEO_CLASS                                  = &A2.EEO_CLASS
Let $FUNCTION_CD                                = &A2.FUNCTION_CD
Let $TARIFF_GER                                 = &A2.TARIFF_GER
Let $TARIFF_AREA_GER                            = &A2.TARIFF_AREA_GER
Let $PERFORM_GROUP_GER                          = &A2.PERFORM_GROUP_GER
Let $LABOR_TYPE_GER                             = &A2.LABOR_TYPE_GER
Let $SPK_COMM_ID_GER                            = &A2.SPK_COMM_ID_GER
Let $HOURLY_RT_FRA                              = &A2.HOURLY_RT_FRA
Let $ACCDNT_CD_FRA                              = &A2.ACCDNT_CD_FRA
Let $VALUE_1_FRA                                = &A2.VALUE_1_FRA
Let $VALUE_2_FRA                                = &A2.VALUE_2_FRA
Let $VALUE_3_FRA                                = &A2.VALUE_3_FRA
Let $VALUE_4_FRA                                = &A2.VALUE_4_FRA
Let $VALUE_5_FRA                                = &A2.VALUE_5_FRA
Let #CTG_RATE                                   = &A2.CTG_RATE
Let #PAID_HOURS                                 = &A2.PAID_HOURS
Let #PAID_FTE                                   = &A2.PAID_FTE
Let $PAID_HRS_FREQUENCY                         = &A2.PAID_HRS_FREQUENCY
Let $UNION_FULL_PART                            = &A2.UNION_FULL_PART
Let $UNION_POS                                  = &A2.UNION_POS
Let #MATRICULA_NBR                              = &A2.MATRICULA_NBR
Let $SOC_SEC_RISK_CODE                          = &A2.SOC_SEC_RISK_CODE
Let #UNION_FEE_AMOUNT                           = &A2.UNION_FEE_AMOUNT
Let $UNION_FEE_START_DT                         = &A2.UNION_FEE_START_DT
Let $UNION_FEE_END_DT                           = &A2.UNION_FEE_END_DT
Let $EXEMPT_JOB_LBR                             = &A2.EXEMPT_JOB_LBR
Let #EXEMPT_HOURS_MONTH                         = &A2.EXEMPT_HOURS_MONTH
Let $WRKS_CNCL_FUNCTION                         = &A2.WRKS_CNCL_FUNCTION
Let $INTERCTR_WRKS_CNCL                         = &A2.INTERCTR_WRKS_CNCL
Let $CURRENCY_CD1                               = &A2.CURRENCY_CD1
Let $PAY_UNION_FEE                              = &A2.PAY_UNION_FEE
Let $UNION_CD                                   = &A2.UNION_CD
Let $BARG_UNIT                                  = &A2.BARG_UNIT
Let $UNION_SENIORITY_DT                         = &A2.UNION_SENIORITY_DT
Let $ENTRY_DATE                                 = &A2.ENTRY_DATE
Let $LABOR_AGREEMENT                            = &A2.LABOR_AGREEMENT
Let $EMPL_CTG                                   = &A2.EMPL_CTG
Let $EMPL_CTG_L1                                = &A2.EMPL_CTG_L1
Let $EMPL_CTG_L2                                = &A2.EMPL_CTG_L2
Let $SETID_LBR_AGRMNT                           = &A2.SETID_LBR_AGRMNT
Let $GP_PAYGROUP                                = &A2.GP_PAYGROUP
Let $GP_DFLT_ELIG_GRP                           = &A2.GP_DFLT_ELIG_GRP
Let $GP_ELIG_GRP                                = &A2.GP_ELIG_GRP
Let $GP_DFLT_CURRTTYP                           = &A2.GP_DFLT_CURRTTYP
Let $CUR_RT_TYPE                                = &A2.CUR_RT_TYPE
Let $GP_DFLT_EXRTDT                             = &A2.GP_DFLT_EXRTDT
Let $GP_ASOF_DT_EXG_RT                          = &A2.GP_ASOF_DT_EXG_RT
Let $ADDS_TO_FTE_ACTUAL                         = &A2.ADDS_TO_FTE_ACTUAL
Let $CLASS_INDC                                 = &A2.CLASS_INDC
Let $ENCUMB_OVERRIDE                            = &A2.ENCUMB_OVERRIDE
Let $FICA_STATUS_EE                             = &A2.FICA_STATUS_EE
Let #FTE                                        = &A2.FTE
Let $PRORATE_CNT_AMT                            = &A2.PRORATE_CNT_AMT
Let $PAY_SYSTEM_FLG                             = &A2.PAY_SYSTEM_FLG
Let $BORDER_WALKER                              = &A2.BORDER_WALKER
Let $LUMP_SUM_PAY                               = &A2.LUMP_SUM_PAY
Let $CONTRACT_NUM                               = &A2.CONTRACT_NUM
Let $JOB_INDICATOR                              = &A2.JOB_INDICATOR
Let $WRKS_CNCL_ROLE_CHE                         = &A2.WRKS_CNCL_ROLE_CHE
Let $BENEFIT_SYSTEM                             = &A2.BENEFIT_SYSTEM
Let #WORK_DAY_HOURS                             = &A2.WORK_DAY_HOURS
Let $SUPERVISOR_ID                              = &A2.SUPERVISOR_ID
Let $REPORTS_TO                                 = &A2.REPORTS_TO
Let $FORCE_PUBLISH                              = &A2.FORCE_PUBLISH
Let $JOB_DATA_SRC_CD                            = &A2.JOB_DATA_SRC_CD
Let $ESTABID                                    = &A2.ESTABID
Let $NAME                                       = &B2.NAME
Let $COUNTRY                                    = &P2.COUNTRY
Let $FREQUENCY_TYPE                             = &F2.FREQUENCY_TYPE

End-Procedure


!***********************************************************************
begin-procedure Insert-New-Job-Rec
!***********************************************************************

#DEBUGY DISPLAY  'insert-new-job-rec'

let $SQL-Statement = 'BPCMP107.SQR, Insert-New-Job-Rec'

#DEBUGY DISPLAY  &A.EmplID NOLINE
#DEBUGY DISPLAY ',' NOLINE
#DEBUGY DISPLAY  &A.Empl_Rcd
#DEBUGY DISPLAY  $New_EffDt NOLINE
#DEBUGY DISPLAY ',' NOLINE
#DEBUGY DISPLAY  #New_EffSeq
#DEBUGY DISPLAY  'new step: ' NOLINE
#DEBUGY DISPLAY #NewJobStep
#DEBUGY DISPLAY 'new_JobRec_effdt: ' noline
#DEBUGY DISPLAY $new_JobRec_effdt
#DEBUGY DISPLAY '$emplid: ' noline
#DEBUGY DISPLAY $emplid
#DEBUGY DISPLAY ',' NOLINE
#DEBUGY DISPLAY  #Empl_Rcd

 ! initialize job found flag to false
  let #new_job_found = 0

!Determine if the JOB and EFFSEQ already exist

begin-SELECT on-error=SQL-Error
JOBD.EFFSEQ

  let #new_job_found = 1
  #DEBUGY DISPLAY 'New job found'

FROM PS_BP_JOB            JOBD
WHERE JOBD.EMPLID    = &A.EMPLID
AND   JOBD.EMPL_RCD  = &A.Empl_Rcd
AND   JOBD.EFFDT     = $new_JobRec_effdt
AND   JOBD.EFFSEQ    = (SELECT MAX(JOBDD.EFFSEQ)
                        FROM PS_BP_JOB JOBDD
                        WHERE JOBDD.EMPLID = JOBD.EMPLID
                        AND JOBDD.EMPL_RCD = JOBD.EMPL_RCD
                        AND JOBDD.EFFDT    = JOBD.EFFDT)
end-SELECT

 ! Use the max effseq Plus 1 if the job is found if new effective
 ! dated job being created use the effective sequence calculated
  if #new_job_found = 1

     let #new_JobRec_effseq = &JOBD.EFFSEQ + 1

  #DEBUGY DISPLAY 'New job sequence: ' noline
  #DEBUGY DISPLAY #new_JobRec_effseq
  end-if

begin-SQL on-error=SQL-Error
INSERT INTO PS_BP_JOB
(EMPLID
,EMPL_RCD
,EFFDT
,EFFSEQ
,DEPTID
,JOBCODE
,POSITION_NBR
,APPT_TYPE
,MAIN_APPT_NUM_JPN
,POSITION_OVERRIDE
,POSN_CHANGE_RECORD
,EMPL_STATUS
,ACTION
,ACTION_DT
,ACTION_REASON
,LOCATION
,TAX_LOCATION_CD
,JOB_ENTRY_DT
,DEPT_ENTRY_DT
,POSITION_ENTRY_DT
,SHIFT
,REG_TEMP
,FULL_PART_TIME
,COMPANY
,PAYGROUP
,BAS_GROUP_ID
,ELIG_CONFIG1
,ELIG_CONFIG2
,ELIG_CONFIG3
,ELIG_CONFIG4
,ELIG_CONFIG5
,ELIG_CONFIG6
,ELIG_CONFIG7
,ELIG_CONFIG8
,ELIG_CONFIG9
,BEN_STATUS
,BAS_ACTION
,COBRA_ACTION
,EMPL_TYPE
,HOLIDAY_SCHEDULE
,STD_HOURS
,STD_HRS_FREQUENCY
,OFFICER_CD
,EMPL_CLASS
,SAL_ADMIN_PLAN
,GRADE
,GRADE_ENTRY_DT
,STEP
,STEP_ENTRY_DT
,GL_PAY_TYPE
,ACCT_CD
,EARNS_DIST_TYPE
,COMP_FREQUENCY
,COMPRATE
,CHANGE_AMT
,CHANGE_PCT
,ANNUAL_RT
,MONTHLY_RT
,DAILY_RT
,HOURLY_RT
,ANNL_BENEF_BASE_RT
,SHIFT_RT
,SHIFT_FACTOR
,CURRENCY_CD
,BUSINESS_UNIT
,SETID_DEPT
,SETID_JOBCODE
,SETID_LOCATION
,SETID_SALARY
,REG_REGION
,DIRECTLY_TIPPED
,FLSA_STATUS
,EEO_CLASS
,FUNCTION_CD
,TARIFF_GER
,TARIFF_AREA_GER
,PERFORM_GROUP_GER
,LABOR_TYPE_GER
,SPK_COMM_ID_GER
,HOURLY_RT_FRA
,ACCDNT_CD_FRA
,VALUE_1_FRA
,VALUE_2_FRA
,VALUE_3_FRA
,VALUE_4_FRA
,VALUE_5_FRA
,CTG_RATE
,PAID_HOURS
,PAID_FTE
,PAID_HRS_FREQUENCY
,GVT_EFFDT
,GVT_EFFDT_PROPOSED
,GVT_TRANS_NBR
,GVT_TRANS_NBR_SEQ
,GVT_WIP_STATUS
,GVT_STATUS_TYPE
,GVT_NOA_CODE
,GVT_LEG_AUTH_1
,GVT_PAR_AUTH_D1
,GVT_PAR_AUTH_D1_2
,GVT_LEG_AUTH_2
,GVT_PAR_AUTH_D2
,GVT_PAR_AUTH_D2_2
,GVT_PAR_NTE_DATE
,GVT_WORK_SCHED
,GVT_SUB_AGENCY
,GVT_ELIG_FEHB
,GVT_FEHB_DT
,GVT_PAY_RATE_DETER
,GVT_STEP
,GVT_RTND_PAY_PLAN
,GVT_RTND_SAL_PLAN
,GVT_RTND_GRADE
,GVT_RTND_STEP
,GVT_RTND_GVT_STEP
,GVT_PAY_BASIS
,GVT_COMPRATE
,GVT_LOCALITY_ADJ
,GVT_BIWEEKLY_RT
,GVT_DAILY_RT
,GVT_HRLY_RT_NO_LOC
,GVT_DLY_RT_NO_LOC
,GVT_BW_RT_NO_LOC
,GVT_MNLY_RT_NO_LOC
,GVT_ANNL_RT_NO_LOC
,GVT_XFER_FROM_AGCY
,GVT_XFER_TO_AGCY
,GVT_RETIRE_PLAN
,GVT_ANN_IND
,GVT_FEGLI
,GVT_FEGLI_LIVING
,GVT_LIVING_AMT
,GVT_ANNUITY_OFFSET
,GVT_CSRS_FROZN_SVC
,GVT_PREV_RET_COVRG
,GVT_FERS_COVERAGE
,GVT_TYPE_OF_APPT
,GVT_POI
,GVT_POSN_OCCUPIED
,GVT_CONT_EMPLID
,GVT_ROUTE_NEXT
,GVT_CHANGE_FLAG
,GVT_TSP_UPD_IND
,GVT_PI_UPD_IND
,GVT_SF52_NBR
,GVT_S113G_CEILING
,GVT_LEO_POSITION
,GVT_ANNUIT_COM_DT
,GVT_BASIC_LIFE_RED
,GVT_DED_PRORT_DT
,GVT_FEGLI_BASC_PCT
,GVT_FEGLI_OPT_PCT
,GVT_FEHB_PCT
,GVT_RETRO_FLAG
,GVT_RETRO_DED_FLAG
,GVT_RETRO_JOB_FLAG
,GVT_RETRO_BSE_FLAG
,GVT_OTH_PAY_CHG
,GVT_DETL_POSN_NBR
,ANNL_BEN_BASE_OVRD
,BENEFIT_PROGRAM
,UPDATE_PAYROLL
,GVT_PAY_PLAN
,GVT_PAY_FLAG
,GVT_NID_CHANGE
,UNION_FULL_PART
,UNION_POS
,MATRICULA_NBR
,SOC_SEC_RISK_CODE
,UNION_FEE_AMOUNT
,UNION_FEE_START_DT
,UNION_FEE_END_DT
,EXEMPT_JOB_LBR
,EXEMPT_HOURS_MONTH
,WRKS_CNCL_FUNCTION
,INTERCTR_WRKS_CNCL
,CURRENCY_CD1
,PAY_UNION_FEE
,UNION_CD
,BARG_UNIT
,UNION_SENIORITY_DT
,ENTRY_DATE
,LABOR_AGREEMENT
,EMPL_CTG
,EMPL_CTG_L1
,EMPL_CTG_L2
,SETID_LBR_AGRMNT
,GP_PAYGROUP
,GP_DFLT_ELIG_GRP
,GP_ELIG_GRP
,GP_DFLT_CURRTTYP
,CUR_RT_TYPE
,GP_DFLT_EXRTDT
,GP_ASOF_DT_EXG_RT
,ADDS_TO_FTE_ACTUAL
,CLASS_INDC
,ENCUMB_OVERRIDE
,FICA_STATUS_EE
,FTE
,PRORATE_CNT_AMT
,PAY_SYSTEM_FLG
,BORDER_WALKER
,LUMP_SUM_PAY
,CONTRACT_NUM
,JOB_INDICATOR
,WRKS_CNCL_ROLE_CHE
,BENEFIT_SYSTEM
,WORK_DAY_HOURS
,SUPERVISOR_ID
,REPORTS_TO
,FORCE_PUBLISH
,JOB_DATA_SRC_CD
,ESTABID
,WPP_STOP_FLAG
,LABOR_FACILITY_ID
,LBR_FAC_ENTRY_DT
,LAYOFF_EXEMPT_FLAG
,LAYOFF_EXEMPT_RSN)                                !PUBSEC

VALUES
($EMPLID
,#EMPL_RCD
,$new_JobRec_effdt
,#new_JobRec_effseq
,$DEPTID
,$JOBCODE
,$POSITION_NBR
,$APPT_TYPE
,#MAIN_APPT_NUM_JPN
,$POSITION_OVERRIDE
,$POSN_CHANGE_RECORD
,$EMPL_STATUS
,'PAY'
,{DateIn-prefix}$AsOfToday{DateIn-suffix}
,'SPG'
,$LOCATION
,$TAX_LOCATION_CD
,{DateIn-prefix}$JOB_ENTRY_DT{DateIn-suffix}
,{DateIn-prefix}$DEPT_ENTRY_DT{DateIn-suffix}
,{DateIn-prefix}$POSITION_ENTRY_DT{DateIn-suffix}
,$SHIFT
,$REG_TEMP
,$FULL_PART_TIME
,$COMPANY
,$PAYGROUP
,$BAS_GROUP_ID
,$ELIG_CONFIG1
,$ELIG_CONFIG2
,$ELIG_CONFIG3
,$ELIG_CONFIG4
,$ELIG_CONFIG5
,$ELIG_CONFIG6
,$ELIG_CONFIG7
,$ELIG_CONFIG8
,$ELIG_CONFIG9
,$BEN_STATUS
,$BAS_ACTION
,' '
,$EMPL_TYPE
,$HOLIDAY_SCHEDULE
,#STD_HOURS
,$STD_HRS_FREQUENCY
,$OFFICER_CD
,$EMPL_CLASS
,$SAL_ADMIN_PLAN
,$GRADE
,{DateIn-prefix}$GRADE_ENTRY_DT{DateIn-suffix}
,#new_JobRec_step
,$new_JobRec_effdt
,$GL_PAY_TYPE
,$ACCT_CD
,$EARNS_DIST_TYPE
,$COMP_FREQUENCY
,#New_Job_Comprate
,#New_Change_Amt
,#New_Change_Pct
,#New_jobrec_Annual_Rt
,#New_jobrec_Monthly_Rt
,#New_jobrec_Daily_Rt
,#New_jobrec_Hourly_Rt
,#ANNL_BENEF_BASE_RT
,#SHIFT_RT
,#SHIFT_FACTOR
,$CURRENCY_CD
,$BUSINESS_UNIT
,$SETID_DEPT
,$SETID_JOBCODE
,$SETID_LOCATION
,$SETID_SALARY
,$REG_REGION
,$DIRECTLY_TIPPED
,$FLSA_STATUS
,$EEO_CLASS
,$FUNCTION_CD
,$TARIFF_GER
,$TARIFF_AREA_GER
,$PERFORM_GROUP_GER
,$LABOR_TYPE_GER
,$SPK_COMM_ID_GER
,$HOURLY_RT_FRA
,$ACCDNT_CD_FRA
,$VALUE_1_FRA
,$VALUE_2_FRA
,$VALUE_3_FRA
,$VALUE_4_FRA
,$VALUE_5_FRA
,#CTG_RATE
,#PAID_HOURS
,#PAID_FTE
,$PAID_HRS_FREQUENCY
,NULL
,NULL
,0
,0
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,NULL
,' '
,' '
,' '
,NULL
,' '
,' '
,' '
,' '
,' '
,0
,' '
,' '
,0
,0
,0
,0
,0
,0
,0
,0
,0
,' '
,' '
,' '
,' '
,' '
,' '
,0
,0
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,NULL
,' '
,NULL
,0
,0
,0
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,' '
,$UNION_FULL_PART
,$UNION_POS
,#MATRICULA_NBR
,$SOC_SEC_RISK_CODE
,#UNION_FEE_AMOUNT
,{DateIn-prefix}$UNION_FEE_START_DT{DateIn-suffix}
,{DateIn-prefix}$UNION_FEE_END_DT{DateIn-suffix}
,$EXEMPT_JOB_LBR
,#EXEMPT_HOURS_MONTH
,$WRKS_CNCL_FUNCTION
,$INTERCTR_WRKS_CNCL
,$CURRENCY_CD1
,$PAY_UNION_FEE
,$UNION_CD
,$BARG_UNIT
,{DateIn-prefix}$UNION_SENIORITY_DT{DateIn-suffix}
,{DateIn-prefix}$ENTRY_DATE{DateIn-suffix}
,$LABOR_AGREEMENT
,$EMPL_CTG
,$EMPL_CTG_L1
,$EMPL_CTG_L2
,$SETID_LBR_AGRMNT
,$GP_PAYGROUP
,$GP_DFLT_ELIG_GRP
,$GP_ELIG_GRP
,$GP_DFLT_CURRTTYP
,$CUR_RT_TYPE
,$GP_DFLT_EXRTDT
,$GP_ASOF_DT_EXG_RT
,$ADDS_TO_FTE_ACTUAL
,$CLASS_INDC
,$ENCUMB_OVERRIDE
,$FICA_STATUS_EE
,#FTE
,$PRORATE_CNT_AMT
,$PAY_SYSTEM_FLG
,$BORDER_WALKER
,$LUMP_SUM_PAY
,$CONTRACT_NUM
,$JOB_INDICATOR
,$WRKS_CNCL_ROLE_CHE
,$BENEFIT_SYSTEM
,#WORK_DAY_HOURS
,$SUPERVISOR_ID
,$REPORTS_TO
,{DateIn-prefix}$FORCE_PUBLISH{DateIn-suffix}
,$JOB_DATA_SRC_CD
,$ESTABID
,' '
,' '
,NULL
,' '
,' ')                                !PUBSEC

end-SQL
end-procedure

!**************************************************************************
Begin-Procedure Display-Time
!**************************************************************************

  do Get-Current-Datetime
  display $AsOfNow

End-Procedure


#Include 'bprncntl.sqc'  !Get run control parameter values
#Include 'bpgetval.sqc'  !Get values mask routines
#Include 'reset.sqc'     !Reset printer
#Include 'datetime.sqc'  !Routines for date and time formatting
#Include 'number.sqc'    !Routines to format numbers
#Include 'curdttim.sqc'  !Routines to get current date/time
#Include 'bpaskstp.sqc'  !Ask step increase parameters
#Include 'stdapi.sqc'    !Routines to Update Run Status
#Include 'getbalid.sqc'  !Get-Calendar-Year-Id
#Include 'datemath.sqc'  !Routines to calculate dates
#Include 'currency.sqc'  !Currency Conversion Routines